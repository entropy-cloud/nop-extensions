<?xml version="1.0" encoding="UTF-8"?>
<funcs>
<normal>
<F1 desc="Get members of a sequence according to the sequence numbers of members of an integer sequence to create a new sequence." majortype="102" name="A" postfix="" returntype="101">
<options/>
<params>
<P1 desc="p (An integer sequence; the range of its member values is ≥0 and ≤n. If P is an empty sequence, then return an empty sequence.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F1>
<F2 desc="Define a cell name." majortype="101" name="Cr" postfix="" returntype="101">
<options/>
<params/>
</F2>
<F3 desc="Convert a string, two-level sequence, table sequence or record sequence to a specific type" majortype="102" name="E" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Do not use headers" optionchar="b"/>
<O2 defaultselect="false" description="Transpose the two-level sequence" optionchar="p"/>
<O3 defaultselect="false" description="Return a string separated by carriage return or tab when parameter x is a table sequence" optionchar="s"/>
</options>
<params>
<P1 desc="x(A sequence/string/table sequence/record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F3>
<F4 desc="Switch between an Excel date/time value and a numeric value." majortype="102" name="E" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (A numeric/date/time value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F4>
<F5 desc="The function equals the Excel ACCRINT function" majortype="102" name="Faccrint" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O2 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O6 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="first_interest    ( The security's first interest date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="settlement (The security's settlement date, i.e. the date after the issue date by which a buyer must pay for the security)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="issue (The issue date of the security)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="rate (The security's annual coupon rate)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="par (The security's par value. If omitted, it takes the default value of zero for ￥100)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F5>
<F6 desc="The function equals the Excel ACCRINTM function" majortype="102" name="Faccrintm" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O2 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O4 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="maturity  (The security's maturity date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="issue (The security'’s issue date )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="rate (The security's annual coupon rate)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="par (The security's par value. If omitted, it takes the default value of zero for 100 yuan)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F6>
<F7 desc="The function equals the Excel COUPNCD function" majortype="102" name="Fcoupcd" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter." optionchar="2"/>
<O2 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter." optionchar="4"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter." optionchar="1"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter." optionchar="0"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter." optionchar="5"/>
<O6 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter." optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity   (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F7>
<F8 desc="The function equals the Excel COUPNND function" majortype="102" name="Fcoupcd" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Equivalent to Excel COUPNND function. It returns the previous coupon date before the settlement date for a security. Annually. Specify the day count basis method US (NASD) 30/360" optionchar="p"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter." optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter." optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter." optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter." optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter." optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter." optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity   (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F8>
<F9 desc="The function equals the Excel COUPNUN function" majortype="102" name="Fcoups" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O2 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O6 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity    (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F9>
<F10 desc="The function equals the Excel COUPDAYS function" majortype="102" name="Fcoups" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Equivalent to Excel COUPDAYS function. It returns the number of days in a coupon period that contains the settlement date. Annually. Specify the day count basis method US (NASD) 30/360" optionchar="d"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity    (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F10>
<F11 desc="The function equals the Excel COUPDAYBS function" majortype="102" name="Fcoups" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="It is equivalent to Excel COUPDAYS function and returns the number of days in a coupon period that contains the settlement date. Annually. The day count basis method is US (NASD) 30/360." optionchar="b"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter." optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter." optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter." optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter." optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter." optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter." optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity    (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F11>
<F12 desc="The function equals the Excel COUPDAYSNC function" majortype="102" name="Fcoups" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Equivalent to Excel COUPDAYSNC function. It returns the number of days from the settlement date to the next coupon date. Annually. Specify the day count basis method US (NASD) 30/360" optionchar="n"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity    (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F12>
<F13 desc="The function equals the Excel DB function" majortype="102" name="Fdb" postfix="" returntype="101">
<options/>
<params>
<P1 desc="cost      (The initial cost of the asset)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="salvage (The value of the asset at the end of the depreciation (asset residual value))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="life (The number of periods over which the asset is to be depreciated (expected useful life of the asset))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="period (The period number for which you want to calculate the depreciation (it must has the same unit with life))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="month (The number of the months used in the calculation of the first year of depreciation. If omitted, it takes the value of 12 by default)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F13>
<F14 desc="The function equals the Excel DDB function" majortype="102" name="Fddb" postfix="" returntype="101">
<options/>
<params>
<P1 desc="cost    (The initial cost of the asset)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="salvage (The value of the asset at the end of the depreciation (asset residual value))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="life (The number of periods over which the asset is to be depreciated (expected useful life of the asset))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="period (The period number for which you want to calculate the depreciation (It must has the same unit with life))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="factor (The rate of balance declining. If omitted, it takes on the default value of 2 (specifying the double-declining balance method))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F14>
<F15 desc="The function equals the Excel DISC function" majortype="102" name="Fdisc " postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O2 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O4 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity  (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="pr (The security's price)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="redemption (The security's redemption value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F15>
<F16 desc="The function equals the Excel DURATION function" majortype="102" name="Fduration " postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O2 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O6 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="coupon (The security's annual coupon rate)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="yld (The security's annual yield)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F16>
<F17 desc="The function equals the Excel INTRATE function" majortype="102" name="Fintrate" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O2 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O4 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity   (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="investment (The initial amount invested into the security)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="redemption (The security's redemption value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F17>
<F18 desc="The function equals the Excel IRR function" majortype="102" name="Firr" postfix="" returntype="101">
<options/>
<params>
<P1 desc="values (A sequence containing the values of a series of cash flows used to calculate the internal rate of return. It must contain at least one periodic payment (negative value) and at least one periodic income (positive value))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="guess (An estimated value for IRR function’s calculation. If omitted, it will take on the default value of 0.1)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F18>
<F19 desc="The function equals the Excel MIRR function" majortype="102" name="Fmirr" postfix="" returntype="101">
<options/>
<params>
<P1 desc="values (A sequence containing the values of payment (negative value) and income (positive value) at each of the regular periods . At least one negative value and at least one positive value must be contained)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="finance_rate (The interest rate paid on the money invested)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="reinvest_rate (The interest rate paid on the reinvested cash which is the net income from the regular periods)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F19>
<F20 desc="The function equals the Excel NPER function" majortype="102" name="Fnper" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="@t corresponds to Excel type parameter. If using the option, choose type 1; if not, choose type 0" optionchar="t"/>
</options>
<params>
<P1 desc="rate (The interest rate per period; it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="pmt (The amount paid per period, which keeps unchanged during the whole period of paying off the loan. To omit it, pv must exist)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="pv (The present value of the loan, a.k.a. the principal, that is the money that already exist when the payment for an investment (or a loan) begins, or the total amount of present values of a series of future payments)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="fv (The future value of the loan, or the cash balance you hope to achieve after the final payment. If omitted, its value will be assumed as zero (for example the future value of a loan can be zero))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F20>
<F21 desc="Equivalent to Excel NPVfunction" majortype="102" name="Fnpv" postfix="" returntype="101">
<options/>
<params>
<P1 desc="rate (The discount rate over one period (that is equal to inflation rate and the rate of competitive investment); it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="values (A sequence of values representing payments and income that must occur at regular time intervals and at the end of each period)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F21>
<F22 desc="Equivalent to Excel XNPVfunction" majortype="102" name="Fnpv" postfix="" returntype="101">
<options/>
<params>
<P1 desc="rate (The discount rate over one period (that is equal to inflation rate and the rate of competitive investment); it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="values (A sequence of values representing payments and income that must occur at regular time intervals and at the end of each period)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="dates (A sequence of dates corresponding to the array of cash payments. The first date of payment denotes the beginning of the payments for the investment)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F22>
<F23 desc="The function equals the Excel PMT function" majortype="102" name="Fpmt" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="@t corresponds to Excel type parameter. If using the option, choose type 1; if not, choose type 0." optionchar="t"/>
</options>
<params>
<P1 desc="rate   (The interest rate per period; it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nper (The number of periods over which the investment (or loan) requires or is to be paid)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="pv (The present value of the loan /investment, a.k.a. the principal, that is the money that already exist when the payment for an investment (or a loan) begins, or the total amount of present values of a series of future payments)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="fv (The future value of the loan/investment, or the cash balance you hope to achieve after the final payment. If omitted, its value will be assumed as zero (for example the future value of a loan can be zero))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F23>
<F24 desc="The function equals the Excel IPMT function" majortype="102" name="Fpmt" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="This option makes the function equivalent to Excel IPMT function. It enables to calculate the interest payment for a given period, with constant periodic payment and a constant interest rate" optionchar="i"/>
</options>
<params>
<P1 desc="rate   (The interest rate per period; it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nper (The number of periods over which the investment (or loan) requires or is to be paid)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="per (The number of period in which the principal appears. Its value must between 1 and nper)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="pv (The present value of the loan /investment, a.k.a. the principal, that is the money that already exist when the payment for an investment (or a loan) begins, or the total amount of present values of a series of future payments)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="fv (The future value of the loan/investment, or the cash balance you hope to achieve after the final payment. If omitted, its value will be assumed as zero (for example the future value of a loan can be zero))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F24>
<F25 desc="The function equals the Excel PPMT  function" majortype="102" name="Fpmt" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="This option makes the function equivalent to Excel PPMT function. It enables to calculate the principal amount during a specific period of an investment or loan that is paid in constant periodic payments, with a constant interest rate" optionchar="p"/>
</options>
<params>
<P1 desc="rate   (The interest rate per period; it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nper (The number of periods over which the investment (or loan) requires or is to be paid)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="per (The number of period in which the principal appears. Its value must between 1 and nper)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="pv (The present value of the loan /investment, a.k.a. the principal, that is the money that already exist when the payment for an investment (or a loan) begins, or the total amount of present values of a series of future payments)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="fv (The future value of the loan/investment, or the cash balance you hope to achieve after the final payment. If omitted, its value will be assumed as zero (for example the future value of a loan can be zero))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F25>
<F26 desc="The function equals the Excel PRICE function" majortype="102" name="Fprice" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O2 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O6 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="rate (The security's annual coupon rate)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="yld  (The security's annual yield)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="redemption (The security's redemption value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F26>
<F27 desc="The function equals the Excel PRICEDISC function" majortype="102" name="Fprice" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Equivalent to Excel PRICEDISC function. It calculates the price per ¥100 par value of a discounted security. Specify the day count basis method US (NASD) 30/360" optionchar="d"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="discount (The security's discount rate)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="0" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="redemption (The security's redemption value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F27>
<F28 desc="The function equals the Excel PRICEMAT function" majortype="102" name="Fprice" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Equivalent to Excel PRICEMAT function. It calculates the price per ¥100 par value of a security that pays interest at maturity. Specify the day count basis method US (NASD) 30/360" optionchar="m"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="issue (The security’s issue date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="rate (The security's annual coupon rate)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="yld  (The security's annual yield)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F28>
<F29 desc="The function equals the Excel RATE function" majortype="102" name="Frate" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="@t corresponds to Excel type parameter. If using the option, choose type 1; if not, choose type 0" optionchar="t"/>
</options>
<params>
<P1 desc="nper (The number of periods over which the investment or loan is to be paid)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="pmt (The payment amount per period, including the principal and the interest)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="pv (The present value of the loan /investment, a.k.a. the principal, that is the money that already exist when the payment for an investment (or a loan) begins, or the total amount of present values of a series of future payments)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="fv (The future value of the loan/investment, or the cash balance you hope to achieve after the final payment. If omitted, it will take on the default value of zero)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="guess (An estimated interest rate. If omitted, it will take on the assumed value of 10%. Both guess and nper must use the same unit)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F29>
<F30 desc="The function equals the Excel RECEIVED function" majortype="102" name="Freceived" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O2 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O4 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="investment (The initial amount invested into the security)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="discount (The security's discount rate)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F30>
<F31 desc="The function equals the Excel SLN function" majortype="102" name="Fsln" postfix="" returntype="101">
<options/>
<params>
<P1 desc="cost (The initial cost of the asset)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="salvage (The value of the asset at the end of the depreciation (also known as asset residual value))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="life (The number of periods over which the asset is to be depreciated (sometimes called expected useful life of the asset))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F31>
<F32 desc="The function equals the Excel SYD function" majortype="102" name="Fsyd" postfix="" returntype="101">
<options/>
<params>
<P1 desc="cost   (The initial cost of the asset)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="salvage (The value of the asset at the end of the depreciation (also known as asset residual value))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="life (The number of periods over which the asset is to be depreciated (sometimes called expected useful life of the asset))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="period (The period for which the asset’s depreciation is calculated (it must use the same unit as life))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F32>
<F33 desc="The function equals the Excel FV function" majortype="102" name="Fv" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="@t corresponds to the Excel type parameter. If using the option, choose type 1; if not, choose type 0" optionchar="t"/>
</options>
<params>
<P1 desc="rate (The interest rate per period; it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nper (The number of periods over which the investment (or loan) requires or is to be paid)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="pmt (The amount paid per period, which keeps unchanged during the whole period of paying off the loan. To omit it, pv must exist)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="pv (The present value of the loan /investment, a.k.a. the principal, that is the money that already exist when the payment for an investment (or a loan) begins, or an accumulated sum of present values of a series of future payments)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F33>
<F34 desc="The function equals the Excel PV function" majortype="102" name="Fv" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="This option makes the function equivalent to Excel PV function. It enables to calculate the present value of an investment that is the total amount of a series of future payments. For example the amount of borrower’s borrowed money is the present value of the loan delivered by the lender." optionchar="p"/>
</options>
<params>
<P1 desc="rate (The interest rate per period; it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nper (The number of periods over which the investment (or loan) requires or is to be paid)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="pmt (The amount paid per period, which keeps unchanged during the whole period of paying off the loan. To omit it, pv must exist)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="fv (The present value of the loan /investment, a.k.a. the principal, that is the money that already exist when the payment for an investment (or a loan) begins, or an accumulated sum of present values of a series of future payments)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F34>
<F35 desc="The function equals the Excel VDB function" majortype="102" name="Fvdb" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Do not switch to the straight-line depreciation method when depreciation is greater than the declining balance calculation" optionchar="s"/>
</options>
<params>
<P1 desc="cost  (The initial cost of the asset)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="salvage (The value of the asset at the end of the depreciation (also known as asset residual value))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="life (The number of periods over which the asset is to be depreciated (sometimes called expected useful life of the asset))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="start_period (The starting period for which you want to calculate the depreciation. It must use the same unit as life.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="end_period (The ending period for which you want to calculate the depreciation. It must use the same unit as life.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="factor (The rate of depreciation. If omitted, it takes on the default value of 2, specifying the double-declining balance method)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F35>
<F36 desc="The function equals the Excel YIELD function" majortype="102" name="Fyield" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O2 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O6 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="rate (The security's annual coupon rate)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="pr (The security's price)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="redemption (The security's redemption value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F36>
<F37 desc="The function equals the Excel YIELDDISC function" majortype="102" name="Fyield" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Equivalent to Excel YIELDDISC function. It calculates the annual yield rate of a discounted security. Specify the day count basis method US (NASD) 30/360" optionchar="d"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="0" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="pr (The security's price)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="redemption (The security's redemption value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F37>
<F38 desc="The function equals the Excel YIELDMAT function" majortype="102" name="Fyield" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Equivalent to Excel YIELDMAT function. It calculates the yield rate of a security that pays interest at maturity. Specify the day count basis method US (NASD) 30/360" optionchar="m"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="issue (The security’s issue date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="rate (The security's annual coupon rate)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="pr (The security's price)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F38>
<F39 desc="Generate an identity matrix of a specified size." majortype="101" name="I" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s(A separator if the data file is of text format; it is the sheet name if the file is in format of xls or xlsx; can be absent)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F39>
<F40 desc="Read in content of a file according to file extension and return result as a table sequence." majortype="102" name="T" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Won’t read in the column headers; will read in them by default" optionchar="b"/>
<O2 defaultselect="false" description="Read in the file content as a cursor" optionchar="c"/>
</options>
<params>
<P1 desc="fn (A data file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="A (A record sequence/cursor; can be absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="Fi (A column header in the data file, which can be represented by #1,#2,… (column 1, column 2, …); can be absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="s (A separator that can be absent if the data file is of text format; it is the sheet name, which should not exceed 31 characters and contain special characters []:/\?*, if the file is of format of xls or xlsx)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F40>
<F41 desc="Compute the absolute value of the parameter." majortype="102" name="abs" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp (Data for which you want to compute the absolute value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F41>
<F42 desc="Compute the arc cosine value of the parameter." majortype="102" name="acos" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (The real number for which you want to compute the arc cosine)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F42>
<F43 desc="Return the inverse hyperbolic cosine" majortype="102" name="acosh" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (The real number for which you want to find the inverse hyperbolic cosine)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F43>
<F44 desc="Compute the number of whole years between two specified time points." majortype="102" name="age" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The result is accurate to the year" optionchar="y"/>
<O2 defaultselect="false" description="The result is accurate to the month" optionchar="m"/>
</options>
<params>
<P1 desc="dateExp1 (Date expression whose result is the date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="formatExp (Format expression, such as &quot;yyyyMMdd&quot;,&quot;yyyy-MM-dd&quot;)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="dateExp2 (Date expression whose result is the date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="formatExp (Format expression, such as &quot;yyyyMMdd&quot;,&quot;yyyy-MM-dd&quot;)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F44>
<F45 desc="Close connection to Alibaba Cloud." majortype="102" name="ali_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="ali_client (A connection to Alibaba Cloud.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F45>
<F46 desc="Connect to Albaba Cloud and return result as a cursor." majortype="102" name="ali_open" postfix="" returntype="1">
<options/>
<params>
<P1 desc="ali_url (The URL for accessing Alibaba Cloud.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="user (The Access ID for Alibaba Cloud.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="password (The Access Key for Alibaba Cloud.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="dbname (A database name.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F46>
<F47 desc="Return a table sequence." majortype="102" name="ali_query" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The option closes the connection to Alibaba Cloud after the query finishes." optionchar="x"/>
<O2 defaultselect="false" description="The option initiates a query on a certain part of data in reverse order." optionchar="z"/>
</options>
<params>
<P1 desc="ali_client (An object to be connected on Alibaba Cloud.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tableName (A table name.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="keyName (For a one-field key, the parameter is the key name; for a composite key, it is a sequence consisting of field names.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="keyValue (Primary key value. If it is a single value, query one record; if it is a sequence, perform batch query on multiple records. When it is a sequence of single values, query one record; when it is sequence of sequences, perform batch query on multiple records.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="selectCol (The column(s) to be returned. The parameter will be a column name when the target is a single column; and a sequence of column names when multiple columns are desired. All fields will be selected when the parameter isn’t supplied.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="filter (A filtering expression, which can be omitted. In the expression, following operators are allowed: Logical operators including &amp;&amp;, ||, and ! Relational operators including  &gt;, &gt;=, ==, &lt;, &lt;=, and != The format of the expression is like this: &lt;field name&gt; relational operator &lt;value expression&gt; For instance: col1 &gt; arg1 &amp;&amp; col1 &lt; arg2 || col2 != arg3 A boolean field needs to be written in a format like this: &lt;boolean field == false&gt;, instead of &lt;!boolean field&gt;.  )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F47>
<F48 desc="Query a certain part of a table and return the result as a cursor." majortype="102" name="ali_query" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The option closes the connection to Alibaba Cloud after the query finishes." optionchar="x"/>
<O2 defaultselect="false" description="The option initiates a query on a certain part of data in reverse order." optionchar="z"/>
</options>
<params>
<P1 desc="ali_client (An object to be connected on Alibaba Cloud.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tableName (A table name.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="keyName (For a one-field key, the parameter is the key name; for a composite key, it is a sequence consisting of field names.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="startValue (The starting value of the primary key values. When it is null or omitted, it represents an infinitesimal; and the colon shouldn’t be omitted.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="endValue (The ending value of the primary key values. When it is null or omitted, it represents an infinite value; and the colon shouldn’t be omitted.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="selectCol (The column(s) to be returned. The parameter will be a column name when the target is a single column; and a sequence of column names when multiple columns are desired. All fields will be selected when the parameter isn’t supplied.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
<P7 desc="filter (A filtering expression, which can be omitted. In the expression, following operators are allowed: Logical operators including &amp;&amp;, ||, and ! Relational operators including  &gt;, &gt;=, ==, &lt;, &lt;=, and != The format of the expression is like this: &lt;field name&gt; relational operator &lt;value expression&gt; For instance: col1 &gt; arg1 &amp;&amp; col1 &lt; arg2 || col2 != arg3 A boolean field needs to be written in a format like this: &lt;boolean field == false&gt;, instead of &lt;!boolean field&gt;.  )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P7>
</params>
</F48>
<F49 desc="Align the records of a record sequence to a sequence, so as to group the record sequence.  If omitting x,y, then align the current records of P with members of A." majortype="101" name="align" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Of P records, return all members which are aligned according to the members of A, and group the resulting sequence. By default, only the first member will be returned." optionchar="a"/>
<O2 defaultselect="false" description="If A is an ordered sequence, the binary search will be used." optionchar="b"/>
<O3 defaultselect="false" description="y is an integer sequence, and every member of y is taken as the alignment position for aligning P to A. P will be aligned to the designated position repeatedly." optionchar="r"/>
<O4 defaultselect="false" description="The return value is composed of the sequence numbers of members in the P" optionchar="p"/>
<O5 defaultselect="false" description="Return all members of P whose records can be aligned to members of A. Of the result sets, there is an extra group to hold those members whose records fail to be aligned." optionchar="n"/>
<O6 defaultselect="false" description="In P, sort members by the same order as members of A, and put non-corresponding member(s) to A at the tail." optionchar="s"/>
</options>
<params>
<P1 desc="A (Primary record sequence/ primary table sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (The field or field expression for association computation of A. You can omit it. If omitted, then it is  interpreted as ~ )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (The alignment expression of P; If omitted, then it is interpreted as P.~)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F49>
<F50 desc="Align the records of a record sequence to a sequence, so as to group the record sequence.  Equivalent to P.align (to(n),y), and support @r." majortype="101" name="align" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Of P records, return all members which are aligned according to the members of A, and group the resulting sequence. By default, only the first member will be returned." optionchar="a"/>
<O2 defaultselect="false" description="If A is an ordered sequence, the binary search will be used." optionchar="b"/>
<O3 defaultselect="false" description="y is an integer sequence, and every member of y is taken as the alignment position for aligning P to A. P will be aligned to the designated position of n overlappedly" optionchar="r"/>
<O4 defaultselect="false" description="The return value is composed of the sequence numbers of members in the P" optionchar="p"/>
<O5 defaultselect="false" description="Return all members of P whose records can be aligned to members of A. Of the result sets, there is an extra group to hold those members whose records fail to be aligned." optionchar="n"/>
<O6 defaultselect="false" description="In P, sort members by the same order as members of A, and put non-corresponding member(s) to A at the tail." optionchar="s"/>
</options>
<params>
<P1 desc="n (Integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y (The alignment expression of P;iIt is interpreted as P if omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F50>
<F51 desc="Add a column to or modify a column in a table sequence" majortype="101" name="alter" postfix="" returntype="101">
<options/>
<params>
<P1 desc="Fi(Name of a column to be added)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F`i(Name of a column in the table sequence)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F51>
<F52 desc="The function alters fields in a table sequence. " majortype="101" name="alter" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="Fi(Field name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F52>
<F53 desc="Alter one or more fields in an entity table" majortype="101" name="alter" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="F(Name of the to-be-added field)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x(An expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F53>
<F54 desc="Perform bitwise operation on integers" majortype="102" name="and" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (The numerical expression based on which you perform the bitwise AND operation)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F54>
<F55 desc="Perform bitwise operation on integers" majortype="102" name="and" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A (Sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F55>
<F56 desc="Append records in cursor/distributed cursor cs to an entity table T." majortype="101" name="append" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Real-time appending whenever a retrieval happens; force an appending when a composite table is closed; by default an appending is executed only when there is a specified number of new records" optionchar="i"/>
<O2 defaultselect="false" description="Append to a patch file and merge with the existing data for retrieval; create one if there isn’t a corresponding patch file" optionchar="a"/>
<O3 defaultselect="false" description="It is possible that the data in a single cursor corresponds to multiple zones in a multi-zone composite table. In that case the zone expression needs to be calculated at each append" optionchar="x"/>
</options>
<params>
<P1 desc="cs(A cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F56>
<F57 desc="Append-write records of a cursor to a pseudo table" majortype="101" name="append" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Perform append-write through MERGE" optionchar="m"/>
<O2 defaultselect="false" description="Append-write immediately at exit of the program or at retrieval while, by default, perform the operation when the number of records reaches to a specified number" optionchar="i"/>
<O3 defaultselect="false" description="MERGE append-write to a patch file, which will be created if there isn’t one" optionchar="a"/>
<O4 defaultselect="false" description="Calculate the zone table expression is at each append when append-writing data in a single cursor to a pseudo table whose source composite table is a multi-zone one because the cursor could correspond to multiple zones" optionchar="x"/>
</options>
<params>
<P1 desc="cs (A cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F57>
<F58 desc="Return a list of the current .dfx/.splx file’s argument names." majortype="102" name="arguments" postfix="" returntype="101">
<options/>
<params/>
</F58>
<F59 desc="Get the field values from a record respectively and return them as a sequence" majortype="101" name="array" postfix="r." returntype="101">
<options/>
<params>
<P1 desc="Fi (Field name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F59>
<F60 desc="Transform each record of a table sequence/record sequence and return a sequence of sequences" majortype="101" name="array" postfix="P" returntype="101">
<options/>
<params/>
</F60>
<F61 desc="To abtain the unicode value of the character at the specified position, if it is ASCII character, then return its ASCII code" majortype="102" name="asc" postfix="" returntype="101">
<options/>
<params>
<P1 desc="string (The given strings )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nPos  (Integer expression, the default is 1)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F61>
<F62 desc="Compute the arc sine value of the parameter." majortype="102" name="asin" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (The real number for which you want to compute the arcsine value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F62>
<F63 desc="Return the inverse hyperbolic sine" majortype="102" name="asinh" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (The real number for which you want to find the inverse hyperbolic sine)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F63>
<F64 desc="Compute the arc tangent value of the parameter." majortype="102" name="atan" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (Real number for which you want to compute the arctangent)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F64>
<F65 desc="Return the inverse hyperbolic tangent" majortype="102" name="atanh" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (Any real number between -1 and 1)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F65>
<F66 desc="Retrieve an attached table from a cluster composite table." majortype="101" name="attach" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="T`(An attached table)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F66>
<F67 desc="Add an attached table to the base table of a composite table." majortype="101" name="attach" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="T`(An attached table)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="C(Attached table column, can be omitted; return an attached table named T’ if it is absent; a C preceded by # is a dimension )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F67>
<F68 desc="Compute the average value of the non-null members in a sequence.Equivalent to avg(x1,…,xn)" majortype="101" name="avg" postfix="A." returntype="101">
<options/>
<params/>
</F68>
<F69 desc="Compute x on each member of the sequence and then compute the average value of the non-null sequence members.Equivalent to A.(x).avg()" majortype="101" name="avg" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (Generally an expression of a single field name, or a legal expression composed of multiple field names)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F69>
<F70 desc="Base64-encode the given data" majortype="102" name="base64" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (BLOB data or an ordinary string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cs(Charset)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="cs`(Charset)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F70>
<F71 desc="Check if Parameter1 is between Parameter 2 and Parameter 3 according to a passed-in parameter." majortype="102" name="between" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The interval is left-open and right-closed" optionchar="l"/>
<O2 defaultselect="false" description="The interval is right-open and left-closed " optionchar="r"/>
<O3 defaultselect="false" description="Make the function returns -1 if x&lt;a; returns 1 if b&lt;x; and retrun 0 for the rest of the cases" optionchar="b"/>
</options>
<params>
<P1 desc="x (An expression that returns value of any data type that is capable of being compared, including numbers, strings, dates, and sequences.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="a (An expression that returns value of any data type that is capable of being compared, including numbers, strings, dates, and sequences.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="b (An expression that returns value of any data type that is capable of being compared, including numbers, strings, dates, and sequences.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F71>
<F72 desc="Split a low-frequency categorical enumerated sequence variable that contains a number of categories not greater than 6 into multiple binary variables during modeling" majortype="101" name="bi" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="Rec(A sequence of splitting process records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F72>
<F73 desc="Split a low-frequency categorical enumerated table sequence/record sequence variable that contains a number of categories not greater than 6 into multiple binary variables during modeling" majortype="101" name="bi" postfix="P." returntype="101">
<options/>
<params>
<P1 desc="cn(A string/number, which is the name of column (or the column number starting from 1) – the to-be-pre-processed variable – in a table sequence or record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Rec(A sequence of splitting process records)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F73>
<F74 desc="Convert a number represented by a certain numeral system to a decimal number" majortype="102" name="bits" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Convert xi to integer decimal number according to the rules of hexadecimal numeral system if it is the string" optionchar="h"/>
<O2 defaultselect="false" description="First convert xi to an integer if it is the string and then calculate according to the rules of decimal numeral system " optionchar="d"/>
<O3 defaultselect="false" description="Convert to 0 if parameter xi is absent and to 1 if the parameter is present, and then convert them to a decimal number according to the rules of binary system " optionchar="n"/>
<O4 defaultselect="false" description="Won’t convert to a decimal number and should work with another option to return the string forming the number of the corresponding numeral system" optionchar="s"/>
<O5 defaultselect="false" description="Enable returning a long integer" optionchar="b"/>
<O6 defaultselect="false" description="Enable putting lower bits before higher bits" optionchar="r"/>
</options>
<params>
<P1 desc="xi (An integer/string)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F74>
<F75 desc="Convert a blob object into an integer sequence, or vice versa." majortype="102" name="blob" postfix="" returntype="101">
<options/>
<params>
<P1 desc="b(A blob object or an integer sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F75>
<F76 desc="Convert a data object to a boolean value" majortype="102" name="bool" postfix="" returntype="101">
<options/>
<params>
<P1 desc="expression (A constant or an expression that you want to convert to a boolean value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F76>
<F77 desc="Compute an expression against a specified record and return the result.Compute x against the kth member of A" majortype="101" name="calc" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="k (an integer, specifying which record it is)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (an expression, which is generally a field name or a legal expression composed of field names, and &quot;~&quot; is used to reference the current record.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F77>
<F78 desc="Compute an expression against a specified record and return the result. Compute x against the members of A specified by the integer sequence p " majortype="101" name="calc" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="p   (an integer sequence, specifying which records they are)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x   (an expression, which is generally a field name or a legal expression composed of field names, and &quot;~&quot; is used to reference the current record.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F78>
<F79 desc="Call a script file and return the first result set." majortype="102" name="call" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Disable the default buffer call" optionchar="r"/>
</options>
<params>
<P1 desc="spl (Script file .dfx/.splx)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="arg1 (Parameters)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F79>
<F80 desc="Allocate tasks among a sequence of nodes, execute the script, and return a sequence of values returned by all tasks." majortype="102" name="callx" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Enable a random allocation " optionchar="a"/>
<O2 defaultselect="false" description="Enable allocating one task to all available nodes; the task is completed as long as one of the nodes does it successfully, and other nodes are thus terminated" optionchar="l"/>
</options>
<params>
<P1 desc="spl (A script file .dfx/.splx, for which an absolute or a relative path can be set. The relative path is the Search Path under the Tool-&gt;Option-&gt; [Environment] menu.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="...(The parameter for passing value to dfx. It is usually in the form of a sequence. The number of parameters to be passed to dfx is the number of the sequences. The parallel algorithm will divide a computational task into multiple subtasks according to the length of the parameter sequence and pass each member of the sequence to the corresponding subtask as the parameter value of dfx.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="hs (The server sequence in which each server is represented by a string in the form of &quot;address:port number&quot;, like &quot;192. 168. 0. 86: 4001&quot;. The absence of IP address means another process in the current physical machine; the absence of both IP address and port number while maintaining &quot;:&quot; means the current process )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="rdfx(A dfx script used that uses two parameters; it is used to perform reduce action, and can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F80>
<F81 desc="Perform the logical AND operation over members of a table sequence" majortype="102" name="cand" postfix="A." returntype="102">
<options/>
<params/>
</F81>
<F82 desc="Create canvas object" majortype="102" name="canvas" postfix="" returntype="101">
<options/>
<params/>
</F82>
<F83 desc="Return the value of the expression that satisfies the specified condition." majortype="102" name="case" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x  (Judge expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="xi (Value expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="yi (result expression)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="y  (Default expression)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F83>
<F84 desc="Truncate the data at the specified position, and carry the remaining part if any." majortype="102" name="ceil" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp (Data to be truncated)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nExp (Integer number for specifying the truncation position;taken as 0 when it is omitted＞0: Move the decimal point to the right for nExp places,＜0: Move the decimal point to the left for nExp places,=0: Indicate the current decimal places)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F84>
<F85 desc="Return an Excel cell name according to specific row and column" majortype="102" name="cellname" postfix="" returntype="101">
<options/>
<params>
<P1 desc="r(The rth row in an Excel sheet, which is an integer greater than 0)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="c(The cth column in an Excel sheet, which is an integer greater than 0)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F85>
<F86 desc="Perform grouping and aggregation over a pre-summarized data cube" majortype="101" name="cgroups" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="" optionchar="m"/>
</options>
<params>
<P1 desc="Fi(Grouping field)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y(Aggregate function)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Gi(Field names in result set)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="w(Filtering condition)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F86>
<F87 desc="Create a channel." majortype="101" name="channel" postfix="" returntype="101">
<options/>
<params/>
</F87>
<F88 desc="Create a channel/cluster channel and push data in another cluster channel into it; equivalent to cs.push(channel())" majortype="101" name="channel" postfix="" returntype="101">
<options/>
<params>
<P1 desc="cs (A cursor or A cluster cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F88>
<F89 desc="Create a channel/cluster channel and push data in another cluster channel into it; equivalent to ch.push(channel())" majortype="102" name="channel" postfix="" returntype="102">
<options/>
<params>
<P1 desc="ch (A channel or A cluster channel)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F89>
<F90 desc="According to the given Unicode or ASCII code, get the corresponding characters" majortype="102" name="char" postfix="" returntype="101">
<options/>
<params>
<P1 desc="int (Integer expression, Unicode code or ASCII code)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F90>
<F91 desc="Auto-identify the characer set used for a string or a text file." majortype="102" name="chardetect" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Identify the character set used for a string or a binary value" optionchar="v"/>
</options>
<params>
<P1 desc="param(The to-be-identified string or binary vlaue, name of the text file to be identified, or object/URL of the text file to be identified)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F91>
<F92 desc="Generate the binary value of a string according to the character set the latter uses, or vice versa." majortype="102" name="charencode" postfix="" returntype="102">
<options/>
<params>
<P1 desc="str(A string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="rawtest(A binary value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="charset(A character set, such as UTF-8 and GB2312; default is the one currently used by the system)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F92>
<F93 desc="A chi-square inverse cumulative distribution function." majortype="102" name="chi2inv" postfix="" returntype="102">
<options/>
<params>
<P1 desc="P(The p-value within the interval (0,1))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="v(Degrees of freedom (DF))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F93>
<F94 desc="Calculate p-value of chi-square test" majortype="101" name="chi_p" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A sequence, which is a binary target)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(A sequence, which is a binary variable)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F94>
<F95 desc=" Write a number with the Chinese numerals" majortype="102" name="chn" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Write the specific number with the Chinese numeral system in the format of billion, ten thousand, thousand, hundred, ten in order" optionchar="a"/>
<O2 defaultselect="false" description="Write the specific number with upper case Chinese numerals" optionchar="u"/>
<O3 defaultselect="false" description="Write the specific number using Chinese characers used for numbers on renminbi banknotes" optionchar="b"/>
</options>
<params>
<P1 desc="x(If a function doesn’t work with an option or uses @a and @u options, parameter x should be an integer; if it cooperate with @b option, parameter x should be a float)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F95>
<F96 desc="Set system clipboard content." majortype="101" name="clipboard" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="If the clipboard content comes from Excel, record it to return; otherwise the function will return the content previously copied." optionchar="e"/>
</options>
<params>
<P1 desc="s (The content to be copied to clipboard, whose data type can be table sequence, string, numeric, date, time, and datetime; can be omitted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F96>
<F97 desc="Close a cursor." majortype="101" name="close" postfix="cs." returntype="101">
<options/>
<params/>
</F97>
<F98 desc="Close a datasource connection." majortype="1" name="close" postfix="db." returntype="102">
<options/>
<params/>
</F98>
<F99 desc="Close a composite table or a cluster table." majortype="1" name="close" postfix="T." returntype="102">
<options/>
<params/>
</F99>
<F100 desc="Compare the value of two expressions x and y.When comparing the value of two expressions x and y, return 0 if they are equal; return 1 if x is greater than y; return -1 if x is less than y. Note:An error will be reported if x and y cannot be compared." majortype="102" name="cmp" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y (expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F100>
<F101 desc="Compare  two sequences A and B.When comparing two sequences A and B, compare the two members in the same position of A and B one by one. Return 0 if all the members are equal; for the first members those are not equal, return 1 if the one in A is larger and return -1 if the one in A is smaller.An error will be reported if A and B cannot be compared. If the members in the sequence A and B are not the same, and their beginning members are the same, then the value with less members will be smaller." majortype="102" name="cmp" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A   (an n sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B   (an m sequence. If sequence B does not exist, then it will be taken as a 0 sequence by default, that is, comparison will be done between sequences A and [0…0])" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F101>
<F102 desc="When the lengths of sequences A and B are equal, compare members of them in normal order; return 1 if a member in A is larger and return -1 if a member in A is smaller and return 0 if all members are equal. If the length of sequence A is less than that of sequence B, return 1 if a member in A is larger and return -1 if a member in A is smaller; return -1 if members of sequence A are equal to their counterparts in sequence B.  When sequences A and B have same number of members, return 0 if all members are equal, otherwise compare members of them in a normal order; for the first members that are not equal, return 1 if the one in A is larger and return -1 if the one in A is smaller. Return 0 if the number of members in the two sequences are not the same and if the length of sequence A is greater than or equal to that of sequence B and if members in sequence B are equal to their counterparts in sequence A. " majortype="102" name="cmp" postfix="" returntype="102">
<options/>
<params>
<P1 desc="A (A sequence whose length is n; can be a single value which is regarded as a sequence having one member)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B (A sequence whose length is m; can be a single value which is regarded as a sequence having one member )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F102>
<F103 desc="When parameter B is absent, sequence B is by default a sequence having members of 0s, then the comparison becomes one happening between sequence A and sequence [0…0] of the same lengh." majortype="101" name="cmp" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A (A sequence whose length is n; can be a single value which is regarded as a sequence having one member)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="0" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F103>
<F104 desc="Compare two records r1 and r2. An error will be reported if r1 and r2 cannot be compared." majortype="102" name="cmp" postfix="" returntype="101">
<options/>
<params>
<P1 desc="r1 (Record)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="r2 (Record)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F104>
<F105 desc="Return the number of combinations." majortype="102" name="combin" postfix="" returntype="101">
<options/>
<params>
<P1 desc="n (An integer that is the number of given objects)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="k (An integer that is the number of elements you want to pick from the given set of objects)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F105>
<F106 desc="Commit the database transaction manually." majortype="1" name="commit" postfix="db." returntype="102">
<options>
<O1 defaultselect="false" description="" optionchar="k"/>
</options>
<params/>
</F106>
<F107 desc="Concatenate parameters into a string." majortype="102" name="concat" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (Any value that can be converted to a string; if it is a sequence, it will be broken up before concatenation.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F107>
<F108 desc="Concatenate members of a sequence with the delimiter and return result as a string." majortype="101" name="concat" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Add quotation marks to string members when concatenating them into a string. If this option is omitted, do not use the quotation marks." optionchar="q"/>
<O2 defaultselect="false" description="Concatenate with the comma" optionchar="c"/>
<O3 defaultselect="false" description="Enclose string members to be concatenated with single quotes" optionchar="i"/>
<O4 defaultselect="false" description="If members of the sequence are also sequences, create a newl line after concatenate members of each sequence members with the delimiter. The operations are equivalent to A.(~.concat(d)).concat(&quot;\n&quot;). If there are other options, perform the concatenation in the inner layer of the function. " optionchar="n"/>
</options>
<params>
<P1 desc="d (Delimiter)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F108>
<F109 desc="Get concatenation of all sequence-type members in a sequence." majortype="101" name="conj" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Recursively concatenate members until there isn’t any sequence members" optionchar="r"/>
</options>
<params>
<P1 desc="x (An expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F109>
<F110 desc="Split each of the records in a channel, union the members and return the resulting union as a channel." majortype="101" name="conj" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="...  (An expression that returns a record sequence/table sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F110>
<F111 desc="Split each of the records in a cursor, union the members and return the original cursor. " majortype="101" name="conj" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="... (An expression that returns a record sequence (or a table sequence))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F111>
<F112 desc="Union the members of a cursor sequence, and return result as a cursor." majortype="101" name="conjx" postfix="CS." returntype="101">
<options/>
<params/>
</F112>
<F113 desc="Establish a connection to a database." majortype="102" name="connect" postfix="" returntype="1">
<options>
<O1 defaultselect="false" description="Return field names and table names in lower case; by default it’s the database that handles the cases" optionchar="l"/>
<O2 defaultselect="false" description="If there is an error, return an error message to be processed automatically with the code; without the option, an interrupt occurs. " optionchar="e"/>
<O3 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to none" optionchar="n"/>
<O4 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to commit" optionchar="c"/>
<O5 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to uncommit" optionchar="u"/>
<O6 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to repeatable" optionchar="r"/>
<O7 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to serializable" optionchar="s"/>
</options>
<params>
<P1 desc="dataSource (The name of a data source)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F113>
<F114 desc="Connect to a database through its driver and url in which the user name and password are written" majortype="102" name="connect" postfix="" returntype="1">
<options>
<O1 defaultselect="false" description="Return field names and table names in lower case; by default it’s the database that handles the cases" optionchar="l"/>
<O2 defaultselect="false" description="If there is an error, return an error message to be processed automatically with the code; without the option, an interrupt occurs. " optionchar="e"/>
<O3 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to  none" optionchar="n"/>
<O4 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to  commit" optionchar="c"/>
<O5 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to uncommit" optionchar="u"/>
<O6 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to repeatable" optionchar="r"/>
<O7 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to serializable" optionchar="s"/>
</options>
<params>
<P1 desc="drv (Database driver class)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="url (Database driver connection URL)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F114>
<F115 desc="Return the connection to a data source in the file system" majortype="102" name="connect" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Return field names and table names in lower case; by default it’s the database that handles the cases" optionchar="l"/>
<O2 defaultselect="false" description="If there is an error, return an error message to be processed automatically with the code; without the option, an interrupt occurs. " optionchar="e"/>
<O3 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to none" optionchar="n"/>
<O4 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to commit" optionchar="c"/>
<O5 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to uncommit" optionchar="u"/>
<O6 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to repeatable" optionchar="r"/>
<O7 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to serializable" optionchar="s"/>
</options>
<params/>
</F115>
<F116 desc="Check whether a given data object is a member of a certain sequence." majortype="101" name="contain" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="The option means that sequence A is ordered, based on which a binary search is performed in an ascending or descending order" optionchar="b"/>
</options>
<params>
<P1 desc="xi  (Data object, which can be a number, a string or a sequence)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F116>
<F117 desc="Perform logical OR operation over members of a sequence." majortype="101" name="cor" postfix="A." returntype="101">
<options/>
<params/>
</F117>
<F118 desc="Correct skewness of a numeric sequence" majortype="101" name="corskew" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Modify the original data to the corrected result after execution" optionchar="c"/>
</options>
<params>
<P1 desc="Rec(A sequence of correction and handling process records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F118>
<F119 desc="Correct skewness of a numeric variable" majortype="101" name="corskew" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Modify the original data to the corrected result after execution" optionchar="c"/>
</options>
<params>
<P1 desc="cn(A string/number, which is the name of column (or the column number starting from 1) – the to-be-pre-processed variable – in a table sequence or record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Rec(A sequence of correction and handling process records)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F119>
<F120 desc="Compute the cosine value" majortype="102" name="cos" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp (The radian number of the cosine to be computed)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F120>
<F121 desc="Return the hyperbolic cosine" majortype="102" name="cosh" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (The real number for which you want to find the hyperbolic cosine)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F121>
<F122 desc="Compute x with each member of the sequence and then count the number of non-null sequence members of the new sequence.  Equivalent to A.(x).count()" majortype="101" name="count" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x  (Generally an expression of a single field name, or a legal expression composed of multiple field names.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F122>
<F123 desc="Count the number of non-null members in a sequence.Equivalent to count(x1,…,xn)" majortype="101" name="count" postfix="A." returntype="101">
<options/>
<params/>
</F123>
<F124 desc="Calculate the covariance between two vectors." majortype="101" name="cov" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(Vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(Vector)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F124>
<F125 desc="Calculate the covariance matrix for a matrix." majortype="101" name="covm" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(Matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F125>
<F126 desc="Create an empty table sequence." majortype="102" name="create" postfix="" returntype="101">
<options/>
<params>
<P1 desc="Fi    (Field name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F126>
<F127 desc="Create an empty table sequence with one or more keys set." majortype="102" name="create" postfix="" returntype="101">
<options/>
<params>
<P1 desc="#Fi  (Field name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F127>
<F128 desc="Open a composite table." majortype="102" name="create" postfix="" returntype="101">
<options/>
<params>
<P1 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="p (Write password/read password)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F128>
<F129 desc="Create a composite table from a corresponding file." majortype="2" name="create" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Do not compress the file; default is to compress it" optionchar="u"/>
<O2 defaultselect="false" description="Generate a rowwise file while default is columnar storage, which does not support the multicursor" optionchar="r"/>
<O3 defaultselect="false" description="Force to re-create the file even if the target file already exists; defalut is to terminate computation and report error" optionchar="y"/>
<O4 defaultselect="false" description="egment by the first field" optionchar="p"/>
</options>
<params>
<P1 desc="C(A column of the would-be composite table)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x(A zone table expression)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F129>
<F130 desc="Create an empty table sequence by duplicating the data structure of table sequence T." majortype="101" name="create" postfix="T." returntype="101">
<options/>
<params/>
</F130>
<F131 desc="Create a table sequence by copying the data structure of a specified record." majortype="101" name="create" postfix="r." returntype="101">
<options/>
<params/>
</F131>
<F132 desc="Generate a new empty table sequence by copying data structure of a specific record sequence" majortype="101" name="create" postfix="P." returntype="101">
<options/>
<params/>
</F132>
<F133 desc="Create a new composite table file using the data structure of an existing composite table" majortype="101" name="create" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="f(A composite table file or a file group)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x(An integer, which is the zone table expression)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F133>
<F134 desc="Store the result set of grouping an entity table or a multi-zone composite table as a pre-summarized data cube" majortype="101" name="cuboid" postfix="" returntype="101">
<options/>
<params>
<P1 desc="C(Pre-summarized data cube name; delete the pre-summarized cube with the specified name when only this parameter is present)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi(Grouping field)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="y(Aggregate function, support only sum/count/max/min/top/iterate; when working with iterate(x,a;Gi,…) function, parameter Gi isn’t supported )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="Gi(Field name in result set)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F134>
<F135 desc="An interative loop to get a cumulative value over records in which one of its fields has same values." majortype="102" name="cum" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (An expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Gi (Field name)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F135>
<F136 desc="Call a cellset file and return the resut set returned from the execution of the file as a cursor." majortype="102" name="cursor" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The dfx can be represented by a cell that corresponds to a subroutine defined by func() function" optionchar="c"/>
</options>
<params>
<P1 desc="dfx (cellset file name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="... (dfx parameter)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F136>
<F137 desc="Generate a cursor from a sequence." majortype="101" name="cursor" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="With this option: A.        cursor@m(n) returns a multicursor; n is the number of segments; use  the value of【Default number of subcursors in a multicursor】defined in the designer as the number of segments if n is absent  B.        cursor@m(mcs,K:K’,...) divides an ordered sequence into several segments based on the segmentation of key K:K’ in sync with the ordered multicursor mcs and returns segments as a multicursor; when @p option is also present, perform the division according to the comparison of the multicursor mcs’s first field and sequence A’s first field while ignoring parameters K:K’ " optionchar="m"/>
<O2 defaultselect="false" description="Assume data is ordered by the first field and the division won’t put records having same first field to different segments; ignore parameters k and n when this option works" optionchar="p"/>
</options>
<params>
<P1 desc="k (Segment number)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (The number of data segments; retrieve all data out when both k and n are omitted.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F137>
<F138 desc="Create a database cursor by executing an SQL statement and return it." majortype="1" name="cursor" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="If the result set has only one column, the content of the returned cursor is a sequence" optionchar="i"/>
<O2 defaultselect="false" description="Convert the numeric data type to the double data type, instead of the decimal data type" optionchar="d"/>
<O3 defaultselect="false" description="Disconnect from the database automatically when the cursor is closed. This option applies to the database connection with connect only" optionchar="x"/>
</options>
<params>
<P1 desc="sql  (A SQL statement, like select * from table)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="args   (If there are parameters in the sql, they must be converted into arguments; args can be either constants or expressions. Note: Arguments shall be separated by commas)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F138>
<F139 desc="Create a cursor based on a file." majortype="2" name="cursor" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Use the first row of f as the field names. If omitting this option, then use_1,_2,… as the field names" optionchar="t"/>
<O2 defaultselect="false" description="Retrieve data from the exported binary file, with the support for parameters Fi, k and n, and with no support for parameters type and s. Ignore options @t, @s, @i, @q and @m. The segmental retrieval could result in empty segment in cases when a file has only a very small number of records; error report appears if the file isn’t retrieved by segment." optionchar="b"/>
<O3 defaultselect="false" description="Make the function return null when Fi doesn’t exist in the file; raise an error when the option is absent." optionchar="e"/>
<O4 defaultselect="false" description="Delete the source file automatically on closing the cursor." optionchar="x"/>
<O5 defaultselect="false" description="Not split the to-be-retrieved field when it is imported as a cursor whose content is a TSeq consisting of strings of a single field; in this case the parameters will be ignored." optionchar="s"/>
<O6 defaultselect="false" description="If the result set has only one column, the content of the returned cursor will be a sequence." optionchar="i"/>
<O7 defaultselect="false" description="Remove the quotation marks, if any, from the field strings, including the field names, in the first place, and handle escape sequences." optionchar="q"/>
<O8 defaultselect="false" description="Use comma as the separator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option. " optionchar="c"/>
<O9 defaultselect="false" description="With the option, the function - f.cursor@m(Fi:type,…;,s) – returns a multicursor." optionchar="m"/>
<O10 defaultselect="false" description="Use quotation marks as the escape character" optionchar="o"/>
<O11 defaultselect="false" description="Retain the white space on both sides of the data item; without it a trim operation will be automatically performed" optionchar="k"/>
<O12 defaultselect="false" description="Delete a record if it contains unmatching data types or data formats and start examining data by type" optionchar="d"/>
<O13 defaultselect="false" description="Ignore and discard rows whose number of columns don’t match the first row" optionchar="n"/>
<O14 defaultselect="false" description="Throw an exception, terminate the execution and output the content of the problem record when errors appear in @d check and @n check" optionchar="v"/>
</options>
<params/>
</F139>
<F140 desc="Create a cursor based on a file." majortype="2" name="cursor" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="se the first row of f as the field names. If omitting this option, then use_1,_2,… as the field names" optionchar="t"/>
<O2 defaultselect="false" description="Retrieve data from the exported binary file, with the support for parameters Fi, k and n, and with no support for parameters type and s. Ignore options @t, @s, @i, @q and @m. The segmental retrieval could result in empty segment in cases when a file has only a very small number of records; error report appears if the file isn’t retrieved by segment." optionchar="b"/>
<O3 defaultselect="false" description="Make the function return null when Fi doesn’t exist in the file; raise an error when the option is absent." optionchar="e"/>
<O4 defaultselect="false" description="Delete the source file automatically on closing the cursor." optionchar="x"/>
<O5 defaultselect="false" description="Not split the to-be-retrieved field when it is imported as a cursor whose content is a TSeq consisting of strings of a single field; in this case the parameters will be ignored." optionchar="s"/>
<O6 defaultselect="false" description="If the result set has only one column, the content of the returned cursor will be a sequence." optionchar="i"/>
<O7 defaultselect="false" description="Remove the quotation marks, if any, from the field strings, including the field names, in the first place, and handle escape sequences." optionchar="q"/>
<O8 defaultselect="false" description="Use comma as the separator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option." optionchar="c"/>
<O9 defaultselect="false" description="With the option, the f.cursor@m(Fi:type,…;n,s) function returns a multicursor;  parameter n is the number of segments and can be omitted" optionchar="m"/>
<O10 defaultselect="false" description="Use quotation marks as the escape character" optionchar="o"/>
<O11 defaultselect="false" description="Retain the white space on both sides of the data item; without it a trim operation will be automatically performed" optionchar="k"/>
<O12 defaultselect="false" description="Delete a record if it contains unmatching data types or data formats and start examining data by type" optionchar="d"/>
<O13 defaultselect="false" description="Ignore and discard rows whose number of columns don’t match the first row" optionchar="n"/>
<O14 defaultselect="false" description="Verify data type matching, and, if error reports, throw an exception, terminate the execution and output the content of the problem record" optionchar="v"/>
<O15 defaultselect="false" description="Enable not to identify single quotes as the quotes; by defaut both single and double quotes are treated as quotes" optionchar="a"/>
<O16 defaultselect="false" description="Enable handling the matching of parentheses (not including the separators within the parentheses) and quotes, as well as the the escape sequences outside of the quotes; the option covers functionalities defined by @q option" optionchar="p"/>
<O17 defaultselect="false" description="Split the file content into a string by the separator without parsing" optionchar="f"/>
<O18 defaultselect="false" description="Allow line continuation if there is an escape character \ at the end of the line" optionchar="l"/>
</options>
<params>
<P1 desc="Fi (Fields to be retrieved; all fields will be retrieved by default. The to-be-retrieved field(s) can be represented by their sequence numbers headed by the sign #.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="type (Field types. Include bool, int, long, float, decimal,  string, date, time and datetime),Data type of the first row will be used by default." filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="k  (The segment number)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="n(The number of segments. Retrieve the whole file when both k and n are omitted )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="s (The number of segments. Retrieve the whole file when both k and n are omitted  )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F140>
<F141 desc="Segment an entity table or an in-memory table and return the cursor of a specified segment." majortype="101" name="cursor" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="The T.cursor@m(x:C…;wi,...;n) function with this option generates a multicursor segmented into n parts. n is an integer; the function returns an ordinary cursor if n&lt;2; use the max number of segments set in【Tool】-【Options】if n is absent" optionchar="m"/>
<O2 defaultselect="false" description="Generate a pure table sequence-based column-wise cursor, which has higher performance than regular cursors" optionchar="v"/>
<O3 defaultselect="false" description="Automatically close the entity table/in-memory table after data in the cursor is fetched" optionchar="x"/>
</options>
<params>
<P1 desc="x (Expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="C (Column alias; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="wi (Filtering condition; multiple conditions are separated by comma(s) and their relationships are AND. You can use the following three types of syntax in a filtering condition: 1. K:Ti  K is a field in the entity table; Ti is a table sequence whose primary key is K. The expression filters away records where K=Ti.find(K) is false. When K is not a selected field to be output, just do the filtering as usuall. 2.K:Ti:null  Filter away all records that can be found. 3.K:Ti:#  K=Ti(K); locate corresponding records using sequence numbers and delete those out-of-range ones and those where Ti(K) is false or null. )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="k (A positive integer (k≤n) representing the kth segment )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="n (A positive integer representing the number of segments)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F141>
<F142 desc="Return the specified column(s) in a cluster entity table/cluster memory table as a cluster cursor." majortype="101" name="cursor" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="The function with this option generates a cluster multicursor synchronously segmented into n parts and splits a duplicate table on two levels. n is an integer; the function returns an ordinary cursor if n&lt;2; use the max number of segments set in【Tool】-【Options】if n is absent. " optionchar="m"/>
</options>
<params>
<P1 desc="x (Expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="wi (Filtering condition; multiple conditions are separated by comma(s) and they must be met at the same time. You can use expression K:Ti (K is a field in the entity table; Ti is a table sequence whose primary key is K) in a condition. The expression means filtering away records where K=Ti.find(K) is false.By default the whole result set is retrieved)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F142>
<F143 desc="Synchronously segment an entity table according to a multicursor and return a multicursor." majortype="101" name="cursor" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Perform matching using the multicursor’s first field of the key" optionchar="k"/>
<O2 defaultselect="false" description="Generate a pure table sequence-based column-wise cursor, which has higher performance than regular cursors" optionchar="v"/>
<O3 defaultselect="false" description="Automatically close the entity table after data is fetched from the cursor" optionchar="x"/>
</options>
<params>
<P1 desc="x (Expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="C (Column alias )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="wi (Filtering condition; multiple conditions are separated by comma(s) and their relationships are AND. You can use the following three types of syntax in a filtering condition: 1. K:Ti  K is a field in the entity table; Ti is a table sequence whose primary key is K. The expression filters away records where K=Ti.find(K) is false. When K is not a selected field to be output, just do the filtering as usuall. 2.K:Ti:null  Filter away all records that can be found. 3.K:Ti:#  K=Ti(K); locate corresponding records using sequence numbers and delete those out-of-range ones and those where Ti(K) is false or null. )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="msc (A multicursor generated from an entity table)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F143>
<F144 desc="Synchronously segment a cluster entity table according to a cluster multicursor and return a cluster multicursor." majortype="101" name="cursor" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="x(Expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="C(To-be-displayed columns; by default all columns are displayed)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="wi(Filering condition;  multiple conditions are separated by comma(s) and they must be met at the same time. You can use expression K:Ti (K is a field in the entity table; Ti is a table sequence whose primary key is K) in a condition. The expression means filtering away records where K=Ti.find(K) is false. By default the whole result set is retrieved)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="mcs(A cluster multicursor generated from a cluster entity table)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F144>
<F145 desc="Segment a memory table/cluster memory table and return cursor of the specified segment." majortype="101" name="cursor" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="T.cursor@m(...;n) returns a multicursor segmented into n parts; n is an integer; the function returns an ordinary cursor if n&lt;2; use the max number of segments set in【Tool】-【Options】if n is absent " optionchar="m"/>
</options>
<params>
<P1 desc="C(Column name in the memory table)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="wi(Filtering condition; multiple conditions are separated by comma(s) and they must be met at the same time. You can use expression K:Ti (K is a field in the entity table; Ti is a table sequence whose primary key is K) in a condition. The expression means filtering away records where K=Ti.find(K) is false.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="k(A positive integer (k≤n) representing the kth segment)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="n(A positive integer representing the number of segments)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F145>
<F146 desc="Divide a memory table in sync with a memory multicursor and return it also as a memory multicursor." majortype="102" name="cursor" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="..." filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="w(Filtering condition)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="mcs(A multicursor generated from a memory table or a composite table)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F146>
<F147 desc="Merge subcursors in a multicursor into a single cursor or a new multicursor with a smaller number of parallel subcursors." majortype="101" name="cursor" postfix="mcs." returntype="101">
<options/>
<params>
<P1 desc="n(Subcursor column name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F147>
<F148 desc="Get a cursor based on a pseudo table object" majortype="101" name="cursor" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description=" Store the composite table in the column-wise format when loading it the first time, which helps to increase performance" optionchar="v"/>
</options>
<params>
<P1 desc="xi (A field expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ci (Field name in a result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F148>
<F149 desc="Get the date part of the datetime value." majortype="102" name="date" postfix="" returntype="101">
<options/>
<params>
<P1 desc="datetimeExp (Datetime value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F149>
<F150 desc="Convert stringExp to a date value according to the format defined by format and return null if the conversion fails; parameter loc is the language used in stringExp; the default is the system language" majortype="102" name="date" postfix="" returntype="101">
<options/>
<params>
<P1 desc="stringExp (String expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="format (Format string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="loc (Language name, which is case insensitive. The most commonly used languages are Chinese (zh) and English (en); see A.sort() to know other languages supported in esProc)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F150>
<F151 desc="The format of the result returned by stringExp should be in consistent with the date format in configuration information; if time is contained in the result, the time will not be converted; return null if the conversion fails" majortype="102" name="date" postfix="" returntype="101">
<options/>
<params>
<P1 desc="stringExp (String expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F151>
<F152 desc="Convert year,month,day of integer type to date type; return null if the conversion fails" majortype="102" name="date" postfix="" returntype="101">
<options/>
<params>
<P1 desc="year (Integer) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="month (Integer) " filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="day (Integer )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F152>
<F153 desc="Convert integer ym and day into date data" majortype="102" name="date" postfix="" returntype="102">
<options/>
<params>
<P1 desc="ym (6-bit integer interpreted as year and month)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="day (Integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F153>
<F154 desc="Convert long integer longExp to date type data" majortype="102" name="date" postfix="" returntype="102">
<options/>
<params>
<P1 desc="longExp(64-bit loing integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F154>
<F155 desc="Return the time and date of a file last modified." majortype="2" name="date" postfix="f." returntype="101">
<options/>
<params/>
</F155>
<F156 desc="Generate multiple derivative variables from a datetime sequence variable" majortype="101" name="datederive" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Each option specifies a target type, and options are mutual-exclusive; automatically judge the type when no option is used; the order of priorities of the options is binary, numeric, integer and enumerated" optionchar="bnie"/>
</options>
<params>
<P1 desc="T(The target variable value used to perform potential data smoothing)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Rec(A sequence of generation process records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F156>
<F157 desc="Generate multiple derivative variables from a date table sequence/record sequence variable" majortype="101" name="datederive" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Each option specifies a target type, and options are mutual-exclusive; automatically judge the type when no option is used; the order of priorities of the options is binary, numeric, integer and enumerated" optionchar="bnie"/>
</options>
<params>
<P1 desc="cn(A string/number, which is the name of column (or the column number starting from 1) – the to-be-pre-processed variable – in a table sequence or record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="T(The target variable value used to perform potential data smoothing)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Rec(A sequence of generation process records)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F157>
<F158 desc="Generate multiple date difference variables for a datetime sequence/table sequence variable" majortype="101" name="dateinterval" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Each option specifies a target type, and options are mutual-exclusive; automatically judge the type when no option is used; the order of priorities of the options is binary, numeric, integer and enumerated" optionchar="bnie"/>
</options>
<params>
<P1 desc="T(The target variable value used to perform potential data smoothing)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Rec(A sequence of generation process records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F158>
<F159 desc="Generate multiple date difference variables for a datetime table sequence/record sequence variable" majortype="101" name="dateinterval" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Each option specifies a target type, and options are mutual-exclusive; automatically judge the type when no option is used; the order of priorities of the options is binary, numeric, integer and enumerated" optionchar="bnie"/>
</options>
<params>
<P1 desc="cns(A sequence of names of columns ( or column numbers starting from 1) of a record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="T(A sequence of target variable values used to perform potential data smoothing)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Rec(A sequence of generation process records)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F159>
<F160 desc="Adjust the precision of the datetime expression and return it." majortype="102" name="datetime" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Measure to minute" optionchar="m"/>
<O2 defaultselect="false" description="Measure to second" optionchar="s"/>
</options>
<params>
<P1 desc="datetimeExp (datetime value )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F160>
<F161 desc="Convert the data type of string to datetime type according to the format defined by format and return null if the conversion fails; if parameter format doesn’t exist, the format of string of string type should be the same as the format of datatime value in configuration informationt; parameter loc is the language used in stringExp; the default is the system language" majortype="102" name="datetime" postfix="" returntype="101">
<options/>
<params>
<P1 desc="string (String)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="format (Format string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="loc (Language name, which is case insensitive. The most commonly used languages are Chinese (zh) and English (en); see A.sort() to know other languages supported in esProc)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F161>
<F162 desc="Convert long of long integer type to datetime value" majortype="102" name="datetime" postfix="" returntype="101">
<options/>
<params>
<P1 desc="long (Long integer counted in microseconds)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F162>
<F163 desc="Concatenate date type data and time type data into data of datetime type" majortype="102" name="datetime" postfix="" returntype="101">
<options/>
<params>
<P1 desc="date (Date type)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="time (Time type)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F163>
<F164 desc="Convert y,m,d,h,m,s of integer type to datetime data" majortype="102" name="datetime" postfix="" returntype="101">
<options/>
<params>
<P1 desc="y   (Positive integer, year)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="m  (Positive integer, month)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="d  (Positive integer, day)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="h  (Positive integer, hour)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="m (Positive integer, minute)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="s  (Positive integer, second)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F164>
<F165 desc="Convert integer ym, d, h, m, s into datetime data" majortype="102" name="datetime" postfix="" returntype="102">
<options/>
<params>
<P1 desc="ym (6-bit positive integer interpreted as year and month)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="d (Positive integer, day)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="h (Positive integer, hour)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="m (Positive integer, minute)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="s (Positive integer, second)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F165>
<F166 desc="Get the day from a date value." majortype="102" name="day" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Get the day of the week from the specified date. For Sunday, return 1; For Monday, return 2, and so on. By default, get the day of the month from the specified date." optionchar="w"/>
</options>
<params>
<P1 desc="dateExp     (Date expression whose result is the date or the string of Chinese date and time format. dateExp can be an integer, which we can regard as the value of computing days@o().)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F166>
<F167 desc="Get the number of days of the year, quarter or month to which the specified date belongs." majortype="102" name="days" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Get the number of days of the quarter to which the specified date belongs" optionchar="q"/>
<O2 defaultselect="false" description="Get the number of days of the year to which the specified date belongs By default get the number of days of the month to which the specified date belongs " optionchar="y"/>
<O3 defaultselect="false" description="Get an integer according to the specified date" optionchar="o"/>
</options>
<params>
<P1 desc="dateExp     (A date or a date string of standard format)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F167>
<F168 desc="Convert a string or a numeric value to a big decimal number" majortype="102" name="decimal" postfix="" returntype="101">
<options/>
<params>
<P1 desc="valueExp (A numeric string or a number)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F168>
<F169 desc="Delete specified records from a table sequence.  Delete the kth record" majortype="102" name="delete" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the deleted record or a record sequence of the deleted records" optionchar="n"/>
</options>
<params>
<P1 desc="k (A positive integer, which specifies the position of a record to be deleted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F169>
<F170 desc="Delete specified records from a table sequence.  Delete the records whose sequence numbers exist in p" majortype="101" name="delete" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the deleted record or a record sequence of the deleted records" optionchar="n"/>
</options>
<params>
<P1 desc="p (An integer sequence with the length of n, which specifies the positions of the records to be deleted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F170>
<F171 desc="Delete specified records from a table sequence.  Delete the records that exist in sequence  A" majortype="101" name="delete" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the deleted record or a record sequence of the deleted records" optionchar="n"/>
</options>
<params>
<P1 desc="A (A sequence, which specifies the records to be deleted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F171>
<F172 desc="Delete the kth member" majortype="101" name="delete" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return the deleted record or a record sequence of the deleted records" optionchar="n"/>
</options>
<params>
<P1 desc="k  (A positive integer that indicates the position of a member to be deleted in the sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F172>
<F173 desc="Delete the members whose sequence numbers exist in p" majortype="101" name="delete" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return the deleted record or a record sequence of the deleted records" optionchar="n"/>
</options>
<params>
<P1 desc="p  (An integer sequence with the length of n that specifies the positions of the members to be deleted) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F173>
<F174 desc="Delete specified record(s) from an entity table." majortype="101" name="delete" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the deleted record(s)  from the record sequence" optionchar="n"/>
</options>
<params>
<P1 desc="P  (A record sequence having same structure as T)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F174>
<F175 desc="Delete one or more specified records from a pseudo table" majortype="101" name="delete" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the deleted records" optionchar="n"/>
</options>
<params>
<P1 desc="P (A record sequence having the same structure with T)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F175>
<F176 desc="Compare the specified two dates." majortype="102" name="deq" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Accurate to the year" optionchar="y"/>
<O2 defaultselect="false" description="Accurate to the quarter" optionchar="q"/>
<O3 defaultselect="false" description="Accurate to the month" optionchar="m"/>
<O4 defaultselect="false" description="Accurate to the ten-day period" optionchar="t"/>
<O5 defaultselect="false" description="Accurate to the week" optionchar="w"/>
</options>
<params>
<P1 desc="datetimeExp1 (Date or standard datetime formate string  such as yyyy-MM-dd HH:mm:ss, yyyy-MM-dd, or HH:mm:ss )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="datetimeExp2 (Date or standard datetime formate string  such as yyyy-MM-dd HH:mm:ss, yyyy-MM-dd, or HH:mm:ss )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F176>
<F177 desc="Add one or more fields to a table sequence or a record sequence. " majortype="101" name="derive" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Use parallel algorithm to handle data-intensive or computation-intensive tasks to enhance performance; no definite order for the records in the result set. " optionchar="m"/>
<O2 defaultselect="false" description="Won’t generate a record if there is expression xi and its result is null (this won’t affect a record with null value in the original table sequence)" optionchar="i"/>
<O3 defaultselect="false" description="@x(…;n) Unfold original fields whose values are records into n levels; default of n is 2" optionchar="x"/>
<O4 defaultselect="false" description="When parameter A is a pure table sequence, add columns directly to it instead of generating a new table sequence" optionchar="o"/>
</options>
<params>
<P1 desc="xi      (Expression, whose results are used as the values of the derived fields )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi      (Field name, which shouldn’t have the same name as any of the original fields in P)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F177>
<F178 desc="Generate a table sequence according to a record sequence." majortype="101" name="derive" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Do not copy the record sequence’s data structure, which will change the record sequence’s structure and which will adjust the number of fields as needed. The option will achieve a better performance as well as an increased risk of error. It’s recommended to be used only when the original record sequence is no longer needed. The option is disabled when there are pure table sequence records in the record sequence. " optionchar="o"/>
</options>
<params/>
</F178>
<F179 desc="Add fields to records in a channel." majortype="101" name="derive" postfix="ch." returntype="101">
<options>
<O1 defaultselect="false" description="Won’t generate a corresponding record if there is expression xi  and its result is null; won’t affect the field values of existing fields." optionchar="i"/>
</options>
<params>
<P1 desc="xi  (An expression, whose results will be the values of the new fields)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi  (Field name, which shouldn’t be same as one of the existing ones)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F179>
<F180 desc="Add one or more fields to a cursor." majortype="101" name="derive" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Won’t generate a record if there is expression xi and its result  is null (this won’t affect a record with null value in the original table sequence)" optionchar="i"/>
</options>
<params>
<P1 desc="xi (Expression, whose computed results are the field values)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi ( Field name. In this case, Fi cannot be of the same name to the existing fields in cs )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F180>
<F181 desc="Calculate the determinant of a square matrix." majortype="101" name="det" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(Square matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F181>
<F182 desc="Generate a new sequence by removing from the first sub-sequence of a sequence the members that exist in the other sub-sequences of the sequence." majortype="101" name="diff" postfix="A." returntype="101">
<options/>
<params/>
</F182>
<F183 desc="Calculate difference between the sequence-type members in a specified sequence to generate a new sequence where the first subsequence won’t contain members that exist in the other sub-sequences. " majortype="101" name="diff" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (An expression that returns a sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F183>
<F184 desc="Convert a numeric string of certain numeral system to a specific numeral system" majortype="102" name="digits" postfix="" returntype="102">
<options/>
<params>
<P1 desc="x(Numeric string; use letters to represent a number greater than 10 )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="ds(An integer specifying a numeral system)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="dd(An integer specifying a numeral system)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F184>
<F185 desc="List the file name(s) satisfying a wildcard path." majortype="101" name="directory" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="List the subdirectory ofpath" optionchar="d"/>
<O2 defaultselect="false" description="List the name of returned file, and the returned results will enclose the name of full path" optionchar="p"/>
<O3 defaultselect="false" description="Create directory" optionchar="m"/>
<O4 defaultselect="false" description="Delete record and the record must be null" optionchar="r"/>
<O5 defaultselect="false" description="Perform recursive query to get all file names under all subdirectories; mutually exclusive with @m and @r" optionchar="s"/>
<O6 defaultselect="false" description="Make case-insensitive; without it the OS will have a say" optionchar="c"/>
</options>
<params>
<P1 desc="path   (wildcard path, * indicates 0 or several characters, and ? indicates a single character)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F185>
<F186 desc="Calculate the Euclidean distance between two vectors." majortype="101" name="dis" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Calculate the sum of absolute values of the differences between numbers at same positions in vector A and vector B" optionchar="a"/>
<O2 defaultselect="false" description="Average out the Euclidean distance before getting its square root " optionchar="m"/>
</options>
<params>
<P1 desc="A(Vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(Vector)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F186>
<F187 desc="Calculate Mahalanobis distance between two vectors on covariance matrix. " majortype="101" name="dism" postfix="" returntype="101">
<options/>
<params>
<P1 desc="X(Vectors of same dimension with the covariance matrix C)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Y(Vectors of same dimension with the covariance matrix C)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="C(A covariance matrix)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F187>
<F188 desc="Draw canvas" majortype="101" name="draw" postfix="G." returntype="101">
<options>
<O1 defaultselect="false" description="Return a JPG canvas" optionchar="j"/>
<O2 defaultselect="false" description="Return a GIF canvas" optionchar="g"/>
<O3 defaultselect="false" description="Return a PNG canvas" optionchar="p"/>
</options>
<params>
<P1 desc="w (Width of canvas in pixels)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="h (Height of canvas inpixels)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F188>
<F189 desc="Join up cluster memory table into a local memory table." majortype="101" name="dup" postfix="T." returntype="101">
<options/>
<params/>
</F189>
<F190 desc="Copy a local memory table onto nodes to create a duplicate cluster memory table." majortype="101" name="dup" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="h(A node or a node sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F190>
<F191 desc="Connect to Amazon DynamoDB." majortype="102" name="dyna_open" postfix="" returntype="102">
<options/>
<params>
<P1 desc="dyna_url(URL for accessing DynamoDB)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="region(The AWS service region for use)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="AccessKey(Access Key for accessing DynamoDB; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="SecretKey(Secret Key for accessing DynamoDB; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F191>
<F192 desc="Close connection to Amazon DynamoDB." majortype="102" name="dynadb.close" postfix="" returntype="102">
<options/>
<params/>
</F192>
<F193 desc="Execute a calculation on data in a DynamoDB table" majortype="102" name="dynadb.execute" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A sequence on which the sql statement is executed circularly while calculating different parameter values  to pass to sql for execution )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql(A sql statement)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F193>
<F194 desc="Query data stored in DynamoDB." majortype="102" name="dynadb.query" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A sequence on which the sql statement is executed circularly while calculating different parameter values  to pass to sql for execution )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql(A SQL statement)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F194>
<F195 desc="Create or delete a Dynamodb table" majortype="102" name="dynadb.table" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Perform table deletion" optionchar="d"/>
</options>
<params>
<P1 desc="tableName(Table name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="partitionKey(The main partition key)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="type1/type2(Data types S, N and B, which represent string, number and binary respectively; default type is S; when type2 is present, type1 cannot be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="sortKey(The sorting key, which can be omitted at table creation)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F195>
<F196 desc="Get the date/time which is a certain time period before or after a given date/time." majortype="102" name="elapse" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Compute the date which is n years before or after the specified date." optionchar="y"/>
<O2 defaultselect="false" description="Compute the date which is n quarters before or after the specified date." optionchar="q"/>
<O3 defaultselect="false" description="Compute the date which is n months before or after the specified date." optionchar="m"/>
<O4 defaultselect="false" description="If the specified date is the last day of a month, the new date will not be adjusted to the last day of the month to which it belongs. Without the option the new date will be automatically adjusted to the last day of the corresponding month. This option works with @yqm." optionchar="e"/>
<O5 defaultselect="false" description="Compute the datetime which is n seconds before or after the specified datetime" optionchar="s"/>
<O6 defaultselect="false" description="Compute the datetime which is n milliseconds before or after the specified datetime; by default the function computes the date which is n days after the specified date." optionchar="ms"/>
</options>
<params>
<P1 desc="dateExp (A specified date expression that should return a date or a string of standard date format.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (An integer expression according to which a date/time n days/years/months/seconds after or before a given date/time is computed, depending on whether n is positive or negative.) " filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F196>
<F197 desc="An external libaray function that builds models and performs predictions using the elastic net regression method." majortype="102" name="elasticnet" postfix="" returntype="102">
<options/>
<params>
<P1 desc="X(A matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Y(A vector having the same number of rows as matrix X)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="learning_rate(Learning rate that is a decimal between 0 and 1; default value is 0.01)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="iterations(Number of iterations; default is 1000)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="l1(Coefficient 11; default is 0.9)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="l2(Coefficient 12; default is 0.1)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
<P7 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P7>
</params>
</F197>
<F198 desc="Generate a new record sequence by performing enumeration grouping on an record sequence according to another record sequence." majortype="101" name="enum" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Repetitive enum, that is, allocate a certain record of P to multiple groups. " optionchar="r"/>
<O2 defaultselect="false" description="The return value is composed of the sequence numbers of members that exist in P" optionchar="p"/>
<O3 defaultselect="false" description="Group P’s records according to E’s members and return the result groups. In the result set, there is a group to store the unaligned member(s)." optionchar="n"/>
</options>
<params>
<P1 desc="E (Record sequence/sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y (A field name or an expression in P. y is allowed to be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F198>
<F199 desc="Assign value to the global variable." majortype="102" name="env" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Set the global variable v as a task variable" optionchar="j"/>
</options>
<params>
<P1 desc="v (The global variable )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Variable value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F199>
<F200 desc="Judge if a sequence can be generated by swapping the positions of the members of another sequence" majortype="101" name="eq" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="B    (a sequence expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F200>
<F201 desc="Obtain the last error information from a database connection." majortype="1" name="error" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="Use the option to return information in string" optionchar="m"/>
</options>
<params/>
</F201>
<F202 desc=" Close REST Client connection." majortype="102" name="es_close" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd(A REST Client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F202>
<F203 desc="Execute the delete command and return a boolean value." majortype="102" name="es_delete" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd(A REST Client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="endpoint(Rest API address)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="entity(A parameter transmitted through http body, which is a JSON string or a block of data in JSON format)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="header(A variable parameter that passes http header; it is a key type JSON string )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F203>
<F204 desc="Export data to the local." majortype="102" name="es_export" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd(restclient object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="fileName(Name of the local file to which data is exported)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="cs(Character set, which is GBK by default)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="indexName(Index name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="colX(Column names represented by a sequence; export all fields by default )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F204>
<F205 desc="Execute the get command and return a table sequence or a cursor." majortype="102" name="es_get" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Query a cursor and by default return all records" optionchar="c"/>
<O2 defaultselect="false" description="Parameter entity can be a filefd" optionchar="f"/>
</options>
<params>
<P1 desc="fd(A REST Client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="endpoint(Rest API address)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="entity(A parameter transmitted through http body, which is a JSON string or the name of JSON file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="header(A variable parameter that passes http header; it is a key type JSON string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F205>
<F206 desc="Execute head command and return a table sequence." majortype="102" name="es_head" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd(A REST Client object )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="endpoint(The address of to-be-checked document/record)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F206>
<F207 desc="Connect to Elasticsearch (ES) server in the default http protocol. " majortype="102" name="es_open" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The https protocol" optionchar="s"/>
</options>
<params>
<P1 desc="host(URL of the ES server, the format is: http(s)://hostname:port, in which http(s) can be omitted; the default is http protocol)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="user(Username for connectiong to an ES server)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="passwd(Password for connectiong to an ES server)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F207>
<F208 desc="Execute the post command and return a table sequence or a cursor." majortype="102" name="es_post" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Query a cursor " optionchar="c"/>
<O2 defaultselect="false" description="Parameter entity can be a file" optionchar="f"/>
</options>
<params>
<P1 desc="fd(A REST Client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="endpoint(Rest API address)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="entity(A parameter transmitted through http body, which is a JSON string or the name of JSON file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="header(A variable parameter that passes http header; it is a key type JSON string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F208>
<F209 desc=" Execute the put command and return a table sequence." majortype="102" name="es_put" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Parameter entity can be a file" optionchar="f"/>
</options>
<params>
<P1 desc="fd(A REST Client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="endpoint(Rest API address)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="entity(A parameter transmitted through http body, which is a JSON string or the name of JSON file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="header(A variable parameter that passes http header; it is a key type JSON string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F209>
<F210 desc="Dynamically parse and compute the expression" majortype="102" name="eval" postfix="" returntype="101">
<options/>
<params>
<P1 desc="StringExp (An expression string to be calculated)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="argExp (Parameter expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F210>
<F211 desc="Execute the SQL statement sql in database db. args,… is the parameter of sql, which can also be a sequence consisting of parameter values" majortype="1" name="execute" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="" optionchar="k"/>
</options>
<params>
<P1 desc="sql      (A SQL statement in the form of select * from table, for example.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="args     (An argument value passed into the specified SQL command sql. It can be a constant or an expression. The comma is used to separate multiple arguments.) " filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F211>
<F212 desc="Execute the SQL statement sql in database db over sequence A. args,… is the parameter of sql. Executions of SQL statements will be committed in BATCHSQL mode, which reduces the frequency of database access. Here args shouldn’t be a a sequence type parameter." majortype="1" name="execute" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="" optionchar="k"/>
</options>
<params>
<P1 desc="A            (A sequence. the SQL statement is executed on each member of A. Generally args is computed against each member of A and the value is passed to the SQL statement for execution.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql         (A SQL statement in the form of select * from table, for example.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="args      (An argument value passed into the specified SQL command sql. It can be a constant or an expression. The comma is used to separate multiple arguments.) " filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F212>
<F213 desc="Execute the SQL statement sql in database db over cursor cs. args,… is the parameter of sql. Executions of SQL statements will be committed in BATCHSQL mode, which reduces the frequency of database access. Here args shouldn’t be a a sequence type parameter." majortype="1" name="execute" postfix="db." returntype="102">
<options>
<O1 defaultselect="false" description="" optionchar="k"/>
</options>
<params>
<P1 desc="cs (A cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL statement in the form of select * from table, for example.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="args (An argument value passed into the specified SQL command sql. It can be a constant or an expression. The comma is used to separate multiple arguments.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F213>
<F214 desc="Check if a file exists." majortype="2" name="exists" postfix="f." returntype="101">
<options/>
<params/>
</F214>
<F215 desc="Compute e to the nth power." majortype="102" name="exp" postfix="" returntype="101">
<options/>
<params>
<P1 desc="n (The exponent)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F215>
<F216 desc="Convert a sequence into a string." majortype="102" name="export" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="The column name will be written to the beginning of the character string as the first record." optionchar="t"/>
<O2 defaultselect="false" description="Use comma as the separator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option. " optionchar="c"/>
<O3 defaultselect="false" description="Use Windows-style \r\n line break; by default the line break is specified by the operating system." optionchar="w"/>
<O4 defaultselect="false" description="Enclose the exported text field values and headers with quotation marks " optionchar="q"/>
<O5 defaultselect="false" description="Perfrom escaping according to the Excel rule, which treats two double quotation marks as one and does not escape the other characters Need to work with @q" optionchar="o"/>
</options>
<params>
<P1 desc="x (Fields to be exported. If omitted, then export all fields of A.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Name of the resulting field in the string. If omitted, then use the original field name.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="s (User-defined field separator. The default is tab.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F216>
<F217 desc="Write a sequence/table sequence/record sequence into a file." majortype="2" name="export" postfix="f." returntype="102">
<options>
<O1 defaultselect="false" description="Export field description, or the headers, as the first row of the file" optionchar="t"/>
<O2 defaultselect="false" description="Append. By default, overwrite the original file. The option and @t are mutual exclusive. The appended records and the original records should be of the same structure, otherwise error will be reported" optionchar="a"/>
<O3 defaultselect="false" description="Convert into binary file to speed up the processing and ignore @t options; won’t segment A if it is small enough, otherwise it will be segmented when being converted into the binary format; A is ordered by s when the latter is present and create a new segment whenever s is changed; s should be different for the newly-added data at append " optionchar="b"/>
<O4 defaultselect="false" description="Use comma as the separator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option." optionchar="c"/>
<O5 defaultselect="false" description="Force the execution of @b and write the sequence to the binary file f in segment by segment. The sequence won’t be segmented without this option. With this option, the parameter s, when it exists, is the grouping expression according which sequence A is ordered; perform data segmentation only when s changes. The option is used to export a large amount of data to a binary file with parallel processing in segments, which can make sure the integrity of records in each segment. " optionchar="z"/>
<O6 defaultselect="false" description="Use Windows-style \r\n line break; by default the line break is specified by the operating system." optionchar="w"/>
<O7 defaultselect="false" description="Enclose the exported text field values and headers with quotation marks " optionchar="q"/>
<O8 defaultselect="false" description="" optionchar="o"/>
</options>
<params>
<P1 desc="A    (The record sequence/sequence to be exported.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x     (The field to be exported. If omitted, all the fields of A that can be textualized will be exported. The sign # is used to represent a field with a sequence number.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="F     (Resulting field name. If omitted, then use the original field name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="s     (The user-defined separator used in the text file, and the default separator is tab)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F217>
<F218 desc="Retrieve data from a cursor and write it to a text file." majortype="2" name="export" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Export field description, or the headers, as the first row of the file" optionchar="t"/>
<O2 defaultselect="false" description="Append. If omitting , overwrite the original file. This option cannot co-exist with @t. f and cs must be of the same structure, otherwise error will be reported." optionchar="a"/>
<O3 defaultselect="false" description="Convert into binary file to speed up the processing. It ignores @t and does not support the parameter s." optionchar="b"/>
<O4 defaultselect="false" description="Use comma as the separator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option." optionchar="c"/>
<O5 defaultselect="false" description="Force the execution of @b and write the sequence to the binary file f in segment by segment. The sequence won’t be segmented without this option. With this option, the parameter s is the grouping expression ruling that sequence A is ordered by s, if the parameter exists, and perform the segmentation only when s changes. The binary file is used to export a large sequenece in segments with parallel processing, which will make sure records in each segment won’t be split.  " optionchar="z"/>
<O6 defaultselect="false" description="Use Windows-style \r\n line break; by default the line break is specified by the operating system. " optionchar="w"/>
<O7 defaultselect="false" description="Enclose the exported text field values and headers with quotation marks " optionchar="q"/>
<O8 defaultselect="false" description="Perfrom escaping according to the Excel rule, which identifies two double quotation marks as one and does not escape the other characters" optionchar="o"/>
</options>
<params>
<P1 desc="cs (Cursor whose data to be exported.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Fields to be exported. If omitted, then export all fields in the record sequence A that can be textualized. The sign # is used to represent a field with a sequence number.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="F (Resulting field name. If omitted, then use the original field name.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="s (User-defined separator; the default is tab.b)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F218>
<F219 desc="Create a matrix whose major diagonal element is 1 and other elements are 0." majortype="102" name="eye" postfix="" returntype="102">
<options/>
<params>
<P1 desc="n1/n2(Positive integers)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F219>
<F220 desc="Perform an aggregate operation over an attached table’s column" majortype="102" name="f" postfix="T." returntype="102">
<options/>
<params>
<P1 desc="T (An attached table)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="C (An attached table’s column)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F220>
<F221 desc="Compute the factorial of the parameter." majortype="102" name="fact" postfix="" returntype="101">
<options/>
<params>
<P1 desc="nExp (Data for which you want to compute the factorial)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F221>
<F222 desc="Fetch one or more records from a cursor/cluster cursor" majortype="101" name="fetch" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Won’t actually fetched out the selected data from the cursor. The option enables an action functionally equivalent to copying the data; it doesn’t support x." optionchar="0"/>
<O2 defaultselect="false" description="Close the cursor after data is fetched." optionchar="x"/>
</options>
<params>
<P1 desc="n ( An integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Grouping expression, according to which cs is sorted. With x, n will be ignored.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F222>
<F223 desc="Fetch and store the existing data in a channel." majortype="101" name="fetch" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="f(A bin file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F223>
<F224 desc="Get records from a multicursor." majortype="101" name="fetch" postfix="mcs" returntype="101">
<options/>
<params/>
</F224>
<F225 desc="Get the value of a specified field in a record." majortype="101" name="field" postfix="r." returntype="101">
<options/>
<params>
<P1 desc="F    (Sequence number of a field, or the string parameter in which a variable can be used to reference the field name.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F225>
<F226 desc="Modify a value of the specified field of a record." majortype="101" name="field" postfix="r." returntype="102">
<options/>
<params>
<P1 desc="F (Sequence number of a field, or the string parameter in which a variable can be used to reference the field name.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Expression whose computing result is the value of the Fth field, or the value of the string parameter F.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F226>
<F227 desc="Get values of a specified field of a sequence." majortype="101" name="field" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="When the return value is a record or record sequence, loop its members iteratively to get desired values" optionchar="r"/>
</options>
<params>
<P1 desc="F  (The sequence number of a field, or the string parameter in which a variable can be used to reference the field name.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F227>
<F228 desc="Modify the value of a specified field in a sequence." majortype="101" name="field" postfix="A." returntype="102">
<options/>
<params>
<P1 desc="F (Sequence number of a field, or the string parameter in which a variable can be used to reference the field name.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (A sequence whose length is equal to the number of values in Fth field, or a single value, which can be considered as a sequence in which members have the same value and their number is equal to the number of values in Fth field.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F228>
<F229 desc="Open a file with the specified name. " majortype="101" name="file" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Search the file names on the non-absolute paths in a specified order: Class path -&gt; Search path-&gt; Main path. The search path is the one configured on the option menu of esProc, and the default main path is the current directory. With this option, the function returns the name of a read-only file. " optionchar="s"/>
<O2 defaultselect="false" description="Generate a temporary file under the directory of fn file. Without the fn file, create the temporary file through the Tempory directory, one of esProc options under the Tool menu. When the relative path is used to point to the temporary directory, it is relative to the configured main directory" optionchar="t"/>
<O3 defaultselect="false" description="Make the write action wait when sharing violation happens" optionchar="a"/>
<O4 defaultselect="false" description="Import file into the memory and generate a file object; the in-memory file is read-only" optionchar="i"/>
</options>
<params>
<P1 desc="fn(Name of the file to load. Both the absolute path and the relative path are acceptable. If using the relative path, then it is relative to the main path, which is the one configured on the option menu of esProc, and which by default is the current directory (the directory holding the script file) )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cs(Character set, which supports jvm's built-in character set and which by default is the default value set by OS)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F229>
<F230 desc="Generate a new cluster file that has same distribution type as an existing cluster file." majortype="102" name="file" postfix="" returntype="2">
<options/>
<params>
<P1 desc="fn  (A cluster file; supports only the composite table file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="f (A cluster file; supports only the composite table file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F230>
<F231 desc="Return a file or file group preceded by the corresponding zone table number(s). " majortype="101" name="file" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fn(A composite table file.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="z(An integer or an integer sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F231>
<F232 desc="Return a remote file from a node" majortype="102" name="file" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fn(To-be-loaded file represented by an absolute path or a relative path that is relative to the main directory)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cs(Character set, which is a JVM built-in one; use the system default when the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="h(A node)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F232>
<F233 desc="Return a remote file from a sequence of nodes" majortype="102" name="file" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fn(To-be-loaded file represented by an absolute path or a relative path that is relative to the main directory)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cs(Character set, which is a JVM built-in one; use the system default when the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="hs(A sequence of nodes)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F233>
<F234 desc="Generate a cluster file or a cluster homo-name files group on one or more nodes" majortype="102" name="file" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Enable a remote generation with parameter z and parameter hs have a one-one-one correspondence; and is equivalent to to(hs.len()) when parameter z is absent" optionchar="w"/>
</options>
<params>
<P1 desc="fn(A composite table file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="z(Zone table number(s), which is an integer or an integer sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="hs(A node or a sequence of nodes)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F234>
<F235 desc="Generate a new cluster homo-name files group using the distribution style of an existing homo-name files group" majortype="102" name="file" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fn(A would-be cluster homo-name files group)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="z(Zone table number, which is an integer or an integer sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="f(A cluster homo-name files group)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F235>
<F236 desc="Create a new string by concatenating strings together." majortype="102" name="fill" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s (Source strings for making up a new string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (Number of source strings that constitute the new string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F236>
<F237 desc="Find a record according to its primary key value." majortype="101" name="find" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Enable the dichotomizing search. Here, A must be ordered by the primary key; otherwise, the result will be wrong, and the index table will be ignored." optionchar="b"/>
<O2 defaultselect="false" description="Return members of A matching the sequence of key values specified by parameter k" optionchar="k"/>
</options>
<params>
<P1 desc="k (Primary key, which will be written as a sequence if it is a multi-field primary key.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F237>
<F238 desc="Find the record(s) according to the specified primary key value(s) from a memory table." majortype="101" name="find" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Find multiple records according to multiple primay keys and return them as a record sequence; write multiple primary keys in the format of [[k1,k2],[...],...]" optionchar="k"/>
</options>
<params>
<P1 desc="k(The primary key; write multiple keys as a sequence)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F238>
<F239 desc="Find the record(s) according to the specified primary key value(s) from a base table." majortype="101" name="find" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Find multiple records according to multiple primay keys and return them as a record sequence; write multiple primary keys in the format of [[k1,k2],[...],...]" optionchar="k"/>
</options>
<params>
<P1 desc="k (The primary key; write multiple keys as a sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Column name; retrieve all field if omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="C (Column alias; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F239>
<F240 desc="F inverse cumulative distribution function." majortype="102" name="finv" postfix="" returntype="102">
<options/>
<params>
<P1 desc="p(Probabilty, within the interval of (0,1))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="v1(Numerator degrees of freedom)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="v2(Denominator degrees of freedom)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F240>
<F241 desc="Calculate p-value for Fisher’s exact test" majortype="101" name="fisher_p" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A sequence, which is a multi-value target)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(A sequence, which is a numeric variable)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F241>
<F242 desc="Convert a string or a numeric value  to a 64-bit double-precision floating-point number" majortype="102" name="float" postfix="" returntype="101">
<options/>
<params>
<P1 desc="valueExp (A numeric string or a number)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F242>
<F243 desc="Truncate the data at the specified positions, and reject all the remaining part if any" majortype="102" name="floor" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp (Data to be intercepted) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nExp (An integer to specify the position from which data is to be truncated; taken as 0 when it is omitted &gt;0: Move the decimal point to the right for nExp places &lt;0: Move the decimal point to the left for nExp places =0: Indicate the current decimal place.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F243>
<F244 desc="Get the names of fields of the table sequence according to the serial numbers of these fields." majortype="101" name="fname" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="i (Sequence number of field)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F244>
<F245 desc="Get the field names from records according to the serial numbers of these fields." majortype="101" name="fname" postfix="r." returntype="101">
<options/>
<params>
<P1 desc="i (Sequence number of field)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F245>
<F246 desc="Get the serial number of a field in a table sequence." majortype="101" name="fno" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="F (field name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F246>
<F247 desc="Get the serial number of a field of a record in a table sequence." majortype="101" name="fno" postfix="r." returntype="101">
<options/>
<params>
<P1 desc="F (field name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F247>
<F248 desc="Generate a formatted string in Java." majortype="101" name="format" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s (A string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="... (The format parameter of the specified string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F248>
<F249 desc="Calculate the frequency of a specified member in a sequence" majortype="101" name="freq" postfix="" returntype="101">
<options/>
<params>
<P1 desc="o(A string/number)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F249>
<F250 desc="Set the remote working directory/directories on the FTP server" majortype="102" name="ftp_cd" postfix="" returntype="101">
<options/>
<params>
<P1 desc="client (An FTP client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="remotePath (The path name of a remote working directory; when it is omitted, the remote working directory on the FTP server is by default regarded as the root directory)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F250>
<F251 desc="Exit an FTP client program" majortype="102" name="ftp_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="client (An FTP client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F251>
<F252 desc="List all directories and files under the current directory on an FTP server." majortype="102" name="ftp_dir" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Only list directories; parameter multiFiles is a wildcard-specified server file" optionchar="d"/>
<O2 defaultselect="false" description="List full paths of directories and files; parameter multiFiles is a wildcard-specified server file" optionchar="p"/>
<O3 defaultselect="false" description="Create new directories; parameter multiFiles is a file with fixed name" optionchar="m"/>
<O4 defaultselect="false" description="Delete empty directories; parameter multiFiles is a file with fixed name" optionchar="r"/>
</options>
<params>
<P1 desc="client (An FTP client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="multiFiles(The path name of a remote working directory)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F252>
<F253 desc="Download a file from the FTP server." majortype="102" name="ftp_get" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Overwrite the local namesake file" optionchar="f"/>
</options>
<params>
<P1 desc="client (An FTP client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="remoteFile(A remote file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="localFile (A local file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F253>
<F254 desc="Download multiple files from a FTP server." majortype="102" name="ftp_mget" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Overwrite a namesake file" optionchar="f"/>
<O2 defaultselect="false" description="Skip a namesake file" optionchar="t"/>
</options>
<params>
<P1 desc="client (An FTP client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="serverFolder (A server folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="localFolder (A local folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="multiServerFiles (Wildcard-specified server files; can be duplicated)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F254>
<F255 desc="Upload multiple files onto a FTP server." majortype="102" name="ftp_mput" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Overwrite a namesake file" optionchar="f"/>
<O2 defaultselect="false" description="Skip a namesake file" optionchar="t"/>
</options>
<params>
<P1 desc="client (An FTP client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="serverFolder (A server folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="localFolder (A local folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="multiLocalFiles (Wildcard-specified server files; can be duplicated)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F255>
<F256 desc="Create an FTP client" majortype="102" name="ftp_open" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Start the FTP passive mode" optionchar="d"/>
</options>
<params>
<P1 desc="server (An FTP server’s IP address)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="port (An FTP server’s port number, which is by default 21 and can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="user (The username to access an FTP server)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="pwd (The password to access an FTP server)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F256>
<F257 desc="Upload a file to the FTP server." majortype="102" name="ftp_put" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Overwrite the local namesake file" optionchar="f"/>
</options>
<params>
<P1 desc="client (An FTP client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="remoteFile (A remote file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="localFile (A local file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F257>
<F258 desc="Call a subroutine" majortype="102" name="func" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Increase performance by not using recursive invocation; by default, the function will copy cells to enable recursive invocation" optionchar="i"/>
<O2 defaultselect="false" description="Enable macro invocation when the func function body only consists of an expression, whose variables must not be changed" optionchar="m"/>
</options>
<params>
<P1 desc="c (The master cell of a subroutine; it is usually the cell where the func is located )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="xi (The parameter used in a subroutine; can be a numerical value, a sequence, or other types of value )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F258>
<F259 desc="Return the greatest common divisor" majortype="102" name="gcd" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (A numeric expression that will be ignored if its value is not a number)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F259>
<F260 desc="Return the greatest common divisor" majortype="102" name="gcd" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A (Sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F260>
<F261 desc="Get information about base members at a superior level in a multilayer loop function" majortype="102" name="get" postfix="" returntype="101">
<options/>
<params>
<P1 desc="level (The number of levels between the current level, which is recorded as 0, and the desired superior level)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Field name, which is sometimes represented by #, denoting the ordial number of a field; get members directly when it is absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="a (Expression of the ordinal number of a member; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="b (Expression of the ordinal number of a member; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F261>
<F262 desc="Perform equi-grouping according one or more fields or expressions." majortype="101" name="group" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Group records by comparing adjacent ones, which is equal to the merging operation, and the result set won’t be sorted" optionchar="o"/>
<O2 defaultselect="false" description="Get the first record of each group to form a record sequence and return it (Please note that 1 is a number instead of a letter)" optionchar="1"/>
<O3 defaultselect="false" description="x gets assigned with group numbers which can be used to define the groups. @n and @0 are mutually exclusive" optionchar="n"/>
<O4 defaultselect="false" description="Do not sort the result set by x. It doesn’t work with @o/@n" optionchar="u"/>
<O5 defaultselect="false" description="x is a bool expression. If the result of x is true, then start a new group. This option is equivalent to A.group@o(a+=if(x,1,0)), in which a=0 and there is only one x" optionchar="i"/>
<O6 defaultselect="false" description="Discard the group over which the result of grouping expression x is null. Use it when there’s only one expression x" optionchar="0"/>
<O7 defaultselect="false" description="Perform a concatenation of sequences/records sequences after the grouping. It is equivalent to A.group(xi,…).conj()" optionchar="s"/>
<O8 defaultselect="false" description="Return a sequence of integer sequences, each of which contains the positions of members in each group in sequence A" optionchar="p"/>
<O9 defaultselect="false" description="Used over a grouped table with each group ordered to speed up grouping" optionchar="h"/>
</options>
<params>
<P1 desc="xi (Grouping expression. When grouping data by multiple fields or expressions, separate grouping expressions from each other by commas)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F262>
<F263 desc="Group a sequence and then perform aggregate operations." majortype="101" name="group" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Group records by comparing adjacent ones, which is equal to the merging operation, and the result set won’t be sorted." optionchar="o"/>
<O2 defaultselect="false" description="x gets assigned with group numbers which can be used to define a group. @n and @0 are mutually exclusive." optionchar="n"/>
<O3 defaultselect="false" description="Do not sort the result set by x. It doesn’t work with @o/@n" optionchar="u"/>
<O4 defaultselect="false" description="x is a bool expression. If the result of x is true, then start a new group. There is only one x." optionchar="i"/>
<O5 defaultselect="false" description="Discard the group over which the result of grouping expression x is null" optionchar="0"/>
<O6 defaultselect="false" description="Used over a grouped table with each group ordered to speed up grouping" optionchar="h"/>
<O7 defaultselect="false" description="Return an empty table sequence with data structure if the grouping and aggregate operation over the sequence returns null" optionchar="t"/>
<O8 defaultselect="false" description="Summarize data cumulatively" optionchar="s"/>
</options>
<params>
<P1 desc="x (Grouping expression. If omitting x:F, aggregate the whole set without grouping; in this case ;must not be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Field name of the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (Aggregate expression in which ~ is used to reference a group)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G (Names of summary fields in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F263>
<F264 desc="Group records in a channel by comparing each one with its neighbor(s) and return a channel." majortype="101" name="group" postfix="ch." returntype="101">
<options>
<O1 defaultselect="false" description="With this option and with grouping expression x being a bool expression, start a new group if the result of x is true. Be sure there’s only one x in this case" optionchar="i"/>
</options>
<params>
<P1 desc="x  (Grouping expression. Use the comma to separate multiple grouping fields/expressions.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F264>
<F265 desc="Group cursor records by comparing only adjacent records and return the original cursor. " majortype="101" name="group" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="x is a bool expression. Begin a new group when a record makes it return true. In this case there should be only one x." optionchar="i"/>
<O2 defaultselect="false" description="Get the first record of every group to form a record sequence and return it; here it is number 1, instead of letter l" optionchar="1"/>
<O3 defaultselect="false" description="Return result as a table sequence on which an index can be directly created; by default, the function sorts the result" optionchar="t"/>
</options>
<params>
<P1 desc="x (Grouping expression. Multiple fields/expressions for grouping will be separated from each other with the comma.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F265>
<F266 desc="Group a cluster cursor by comparing each record with its next neighbor. " majortype="101" name="group" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="x(Grouping expression; use comma to separate multiple grouping fields or expressions)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F266>
<F267 desc="Group records of a given cursor by comparing each with its neighbours, peform aggregation over each group and return the original cursor." majortype="101" name="group" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Cumulative aggregation" optionchar="s"/>
<O2 defaultselect="false" description="@q(x:F,…;x’:F’,…;…)Used when parameter cs is ordered by x,… and only fields after it need to be sorted; support in-memory sorting" optionchar="q"/>
<O3 defaultselect="false" description="@sq(x:F,…;x’:F’,…;…)Only sort without grouping when parameters y:G are absent, and perform cumulative aggregation when the parameters are present; @s works only when @q option is present" optionchar="sq"/>
</options>
<params>
<P1 desc="x  (Grouping expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F  (Field name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y  (Aggregate expression)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G  (Aggregation field name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F267>
<F268 desc="Group records of a pseudo table by comparing the grouping field in each with its next neighbor." majortype="101" name="group" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="x is a boolean expression. Begin a new group when a record makes it return true. In this case there should be only one x" optionchar="i"/>
<O2 defaultselect="false" description="Get the first record of every group to form a record sequence and return it; here it is number 1, instead of letter l" optionchar="1"/>
<O3 defaultselect="false" description="Return result as a table sequence on which an index can be directly created; by default, the function sorts the result" optionchar="t"/>
<O4 defaultselect="false" description="Store the composite table in the column-wise format when loading it the first time, which helps to increase performance" optionchar="v"/>
</options>
<params>
<P1 desc="xi (Grouping expression; use comma to separate multiple grouping fields or expressions)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F268>
<F269 desc="Generate a sequence for use in a data-input sheet." majortype="101" name="groupi" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Assume that the sequence is ordered, perform a merge by comparing each record with its next neighbor and won’t sort the result set" optionchar="o"/>
</options>
<params>
<P1 desc="Di (A data-input sheet’s dimension)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F269>
<F270 desc="Group records in a cursor and push them respectively into a sequence of channels." majortype="101" name="groupn" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="x (Grouping expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="C (A sequence of channels)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F270>
<F271 desc="Group records in channel ch and push them respectively into a sequence of channels." majortype="101" name="groupn" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="x (Gouping expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="C (A sequence of channels)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F271>
<F272 desc="Group records of a cursor and write the subset groups as a sequence of bin files." majortype="101" name="groupn" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="x (Grouping expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (A sequence of bin file objects)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F272>
<F273 desc="Group and aggregate a TSeq cumulatively." majortype="101" name="groups" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Group records by comparing adjacent ones, which is equal to the merging operation, and the result set won’t be sorted." optionchar="o"/>
<O2 defaultselect="false" description="x gets assigned with group numbers which can be used to define the groups. @n and @o are mutually exclusive." optionchar="n"/>
<O3 defaultselect="false" description="Do not sort the result set by x. It doesn’t work with @o/@n" optionchar="u"/>
<O4 defaultselect="false" description="x is a bool expression. If the result of x is true, then start a new group. There is only one x." optionchar="i"/>
<O5 defaultselect="false" description="Use parallel algorithm to handle data-intensive or computation-intensive tasks; no definite order for the records in the result set; can’t be used with @oi options. " optionchar="m"/>
<O6 defaultselect="false" description="Discard the group over which the result of grouping expression x is null" optionchar="0"/>
<O7 defaultselect="false" description="Used over a grouped table with each group ordered to speed up grouping" optionchar="h"/>
<O8 defaultselect="false" description="Return an empty table sequence with data structure if the grouping and aggregate operation over the sequence returns null" optionchar="t"/>
</options>
<params>
<P1 desc="x (Group expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Field name of the result table sequence.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (y is the function with which A is traversed. When y is an aggregate function, it only supports sum/count/max/min/top/avg/iterate/icount/median/maxp/minp. When the function work with iterate(x,a;Gi,…) function, the latter’s parameter Gi should be omitted. When y isn’t an aggregate function, perform calculation over only the first record in each group. )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G (Summary field name in the result table sequence.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F273>
<F274 desc="Group records in a channel." majortype="101" name="groups" postfix="ch." returntype="101">
<options>
<O1 defaultselect="false" description="With the option the value of expression x is a group number, which points to the desired group" optionchar="n"/>
<O2 defaultselect="false" description="Won’t sort the resulting set by expression x; the option and @n are mutually exclusive" optionchar="u"/>
</options>
<params>
<P1 desc="x  (Grouping expression, by which an aggregation over the whole grouped set is performed if x:F is omitted. In that case the semicolon should not be omitted.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F  (Field names of the resulting table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y  (An aggregate function which only supports sum/count/max/min/top /avg/iterate; the parameter Gi should be given up if function iterate(x,a;Gi,…) is used.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G  (The aggregate fields in the resulting table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="n  (The maximum number of groups that can be divided. Stop execution if the number is exceeded. The parameter is defined for a situation where the number of groups to be divided is large yet indefinite. It doesn’t work with @n option.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F274>
<F275 desc="Group records in a cluster cursor, sort them by the grouping field and peform aggregation over each group and add each aggregate to the result set." majortype="102" name="groups" postfix="cs." returntype="102">
<options>
<O1 defaultselect="false" description="Perform the group operation over data in every node and compose the result sets into a cluster memory table in the segmentation way of the cursor; suppport a cluster dimension table" optionchar="c"/>
</options>
<params>
<P1 desc="x (Grouping expression; if omitting parameters x:F, aggregate the whole set; in this case, the semicolon (;) must not be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Field name in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (Aggregate function that only supports sum/count/max/min/top /avg/iterate; when the function works with iterate(x,a;Gi,…) function, the latter’s parameter Gi should be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G (Aggregate field name in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="n (The specified maximum number of groups; stop executing the function when the number of data groups is bigger than n to prevent memory overflow; the parameter is used in scenarios when it is predicted that data will be divided into a large number of groups that are greater than n )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F275>
<F276 desc="Group records in a cursor." majortype="101" name="groups" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="The value of grouping expression is group number used to locate the group; you can use n to specify the number of groups and generate corresponding number of zones first." optionchar="n"/>
<O2 defaultselect="false" description="Do not sort the result set by x. It doesn’t work with @n" optionchar="u"/>
<O3 defaultselect="false" description="Compare each record only with its neighboring record to group, which is equivalent to the merge operation, and won’t sort the result set" optionchar="o"/>
<O4 defaultselect="false" description="With this option, the function only has one parameter x that is a bool expression; start a new group if its result is true" optionchar="i"/>
<O5 defaultselect="false" description="Used over a grouped table with each group ordered to speed up grouping" optionchar="h"/>
</options>
<params>
<P1 desc="x (Grouping expression; if omitting parameters x:F, aggregate the whole set; in this case, the semicolon (;) must not be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Field name in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (Aggregate function that only supports sum/count/max/min/top/avg/iterate; when the function works with iterate(x,a;Gi,…) function, the latter’s parameter Gi should be omitted )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G (Aggregate field name in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="n (The specified maximum number of groups; stop executing the function when the number of data groups is bigger than n to prevent memory overflow; the parameter is used in scenarios when it is predicted that data will be divided into a large number of groups that are greater than n; it doesn’t work with @n option. Support a multicuror when this parameter is absent.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F276>
<F277 desc="Group records in a pseudo table" majortype="101" name="groups" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="The value of grouping expression is group number used to locate the group; you can use n to specify the number of groups and generate corresponding number of zones first" optionchar="n"/>
<O2 defaultselect="false" description="Do not sort the result set by the grouping expression; it doesn’t work with @n" optionchar="u"/>
<O3 defaultselect="false" description="Compare each record only with its neighboring record to group, which is equivalent to the merge operation, and won’t sort the result set" optionchar="o"/>
<O4 defaultselect="false" description="With this option, the function only has one parameter x that is a boolean expression; start a new group if its result is true" optionchar="i"/>
<O5 defaultselect="false" description="Used over a grouped table with each group ordered to speed up grouping" optionchar="h"/>
<O6 defaultselect="false" description="Enable returning a resut set containing aggregates only without group-level data" optionchar="b"/>
<O7 defaultselect="false" description="Store the composite table in the column-wise format when loading it the first time, which helps to increase performance" optionchar="v"/>
</options>
<params>
<P1 desc="x (Grouping expression; if omitting parameters x:F, aggregate the whole set; in this case, the semicolon “;” must not be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Field name in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (An aggregate function on T, which only supports sum/count/max/min/top/avg/iterate; when the function works with iterate(x,a;Gi,…) function, the latter’s parameter Gi should be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G (Aggregate field name in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="n (The specified maximum number of groups; stop executing the function when the number of data groups is bigger than n to prevent memory overflow; the parameter is used in scenarios when it is predicted that data will be divided into a large number of groups that are greater than n)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F277>
<F278 desc="Group records, in a channel and return a channel." majortype="101" name="groupx" postfix="ch." returntype="101">
<options>
<O1 defaultselect="false" description="With the option the value of expression x is a group number, which points to the desired group" optionchar="n"/>
</options>
<params>
<P1 desc="x  (Grouping expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F  (Field name in the resulting table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y  (An aggregate function which only supports sum/count/max/min/top /avg/iterate; the parameter Gi should be given up if function iterate(x,a;Gi,…) is used)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G  (The aggregate fields in the resulting table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F278>
<F279 desc="Group the ordered records in a cursor and return result as a cursor. " majortype="101" name="groupx" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="x gets assigned with group numbers which can be used to define the groups. " optionchar="n"/>
<O2 defaultselect="false" description="Won’t sort the result set by parameter x; mutually exclusive with @n." optionchar="u"/>
<O3 defaultselect="false" description="Treat parameter n as the segmentation expression by which records are first segmented and then grouped and sorted" optionchar="g"/>
</options>
<params>
<P1 desc="x(Grouping expression.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F(Result field name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y(Aggregate function which only supports sum/count/max/min/top/ avg/iterate. When the function works with the iterate(x,a;Gi,…) function, the latter’s parameter Gi should be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G(Aggregate field name )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="n(Number of buffer rows; if the number of groups reaches n, write the grouping result to a temporary file; its value is n times of the default, which is automatically calculated, if n&lt;1)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F279>
<F280 desc="Group records in a cluster cursor and return a synchronously segmented cursor." majortype="102" name="groupx" postfix="cs." returntype="102">
<options/>
<params>
<P1 desc="x (Grouping expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Resulting field name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (Aggregate function that only supports sum/count/max/min/top/avg/iterate; when the function works with iterate(x,a;Gi,…) function, the latter’s parameter Gi should be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G (Aggregate field name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="n (Number of buffer rows; if the number of groups reaches n, write the grouping result to a temporary file; its value is n times of the default, which is automatically calculated, if n&lt;1)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F280>
<F281 desc="Return a hash value" majortype="101" name="hash" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (Data of any type)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (An integer greater than 1)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F281>
<F282 desc="Close a HBase connection." majortype="102" name="hbase_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F282>
<F283 desc="Compare data with the HBase-supplied comparator." majortype="102" name="hbase_cmp" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Match the current value with the prefix" optionchar="p"/>
<O2 defaultselect="false" description="Check if the current value is null but won’t perform matching" optionchar="n"/>
<O3 defaultselect="false" description="Use a regular expression to match table data" optionchar="r"/>
<O4 defaultselect="false" description="Use the threshold and table data, both of which are string type, to match up a string" optionchar="s"/>
<O5 defaultselect="false" description="Convet a string type or a date/time/datatime type parameter to a Long type one" optionchar="l"/>
<O6 defaultselect="false" description="Perform bit-level comparison using AND, OR and XOR operations" optionchar="b"/>
</options>
<params>
<P1 desc="str (A string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="r (Only use this parameter with @r option; its value can only be one of the following letters: i=case insensitive  (Case-insensitive)  m=multiline,     (^ and $ can match up a line break within a string) d=dotall,        (The dot symbol can match up a line break) u=unicode case,  (Case-insensitive in matching up Unicode characters ) q=canon_eq     (Consider same characters in different character encodings as equal)  x=unix_lines,    (Consider \n as a line break only) l=literal,        (Text mode) c=comments    (Comment mode) The value must be in quotation marks. )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="b (Only use this parameter with @b option; its value can only be one of the following: AND, OR, XOR; the value must be in quotation marks. )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F283>
<F284 desc="Filter data with the HBase-supplied filter." majortype="102" name="hbase_filter" postfix="" returntype="101">
<options/>
<params>
<P1 desc="filterName (HBase filter name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="filterArg (Filter parameter)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F284>
<F285 desc="Filter data with multiple filters." majortype="102" name="hbase_filterlist" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Every filter is independent in filtering data." optionchar="o"/>
</options>
<params>
<P1 desc="filterHandle (Filter handle)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F285>
<F286 desc="Query data in HBase database and return a single row." majortype="102" name="hbase_get" postfix="" returntype="101">
<options/>
<params>
<P1 desc="client (Database connection information)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tableName (Table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="rowName (Row name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="family (Column family name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="column (Colum name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="type (Data type; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P6>
<P7 desc="alias (Another name of a column; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P7>
<P8 desc="filter:f (‘filter:’ is a fixed format, and parameter f means filter handle; can be omitted )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P8>
<P9 desc="timeRange:[t1,t2] (‘timeRange:’ is a fixed format, and parameters t1 and t2 specify a range of timestamp; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P9>
</params>
</F286>
<F287 desc="Create a HBase connection." majortype="102" name="hbase_open" postfix="" returntype="101">
<options/>
<params>
<P1 desc="hdfsUrl (HDFS connection information )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="zkUrl (Zookeeper connection information)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F287>
<F288 desc="Query a HBase database and return result as a cursor or a table sequence." majortype="102" name="hbase_scan" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Return a cursor" optionchar="c"/>
</options>
<params>
<P1 desc="client (Database connection information)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tableName (Table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="family (Column family name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="column (Column name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="Type (Data type; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="alias (Another name of a column; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P6>
<P7 desc="rowPrefix:x (‘rowPrefix:’ is a fixed format; parameter x is the prefix of rowKey )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P7>
<P8 desc="filter:f (Filter handle)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P8>
<P9 desc="startRow:startrow (‘startRow:’ is a fixed format; parameter startrow represents the starting row, which will be included in data retrieval )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P9>
<P10 desc="stopRow:stoprow (‘stopRow:’ is a fixed format; parameter stoprow represents the ending row, which will be excluded in data retrieval )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P10>
<P11 desc="timeRange:[t1,t2] (‘timeRange:[,]’ is a fixed format; parameter t1 is the starting timestamp whose value will be retrieved, and parameter t2 is the ending timestamp whose value won’t be retrieved)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P11>
</params>
</F288>
<F289 desc="Close the HDFS connection." majortype="102" name="hdfs_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="HdfsClient (An HDFS connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F289>
<F290 desc="Get the list of all files in a specified path." majortype="102" name="hdfs_dir" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="List names of all directories in the specified path" optionchar="d"/>
<O2 defaultselect="false" description="List the full paths of all directories and files in the specified path" optionchar="p"/>
<O3 defaultselect="false" description="Create a directory; return true if the directory is created, otherwise return false" optionchar="m"/>
<O4 defaultselect="false" description="Delete a directory; return true if the operation is successful, otherwise return false" optionchar="r"/>
</options>
<params>
<P1 desc="hd (An hd connecton)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="path (A relative path within the path containing the HDFS file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F290>
<F291 desc="Download a local file to a specific position" majortype="102" name="hdfs_download" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Download all files in the specified folder to the local machine, and require both the source and directories are folders" optionchar="d"/>
</options>
<params>
<P1 desc="hd(An hd connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="local(A local file or folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="remote(A remote file or folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F291>
<F292 desc="Check whether there is a specified file or folder in HDFS and return a boolean value" majortype="102" name="hdfs_exists" postfix="" returntype="101">
<options/>
<params>
<P1 desc="hd (An hd connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="file/path(Hadoop file name/Hadoop path name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F292>
<F293 desc="Open a specified directory and return an HDFS file flow." majortype="102" name="hdfs_file" postfix="" returntype="101">
<options/>
<params>
<P1 desc="hd (An hd connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="file (The name of the to-be-loaded Hadoop file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="cs (The charset embedded in JVM; by default it is the default value for a virtual machine)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F293>
<F294 desc="Connect to the HDFS file system and return a connection object." majortype="102" name="hdfs_open" postfix="" returntype="101">
<options/>
<params>
<P1 desc="url(The URL format is scheme://authority/path. Scheme is the HDFS protocol name; authority is the host name; and path is a string of the file (or directory) path) " filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="user(A Hadoop user; default is root)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F294>
<F295 desc="Upload a local file to a specific position" majortype="102" name="hdfs_upload" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Upload all files in the specified folder to the specified path, and require both the source and directories are folders" optionchar="d"/>
</options>
<params>
<P1 desc="hd(An hd connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="local(A local file or folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="remote(A remote file or folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F295>
<F296 desc="Upload data to the specified location in HDFS" majortype="101" name="hdfs_write" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Appen-write; the to-be-appended content should have same structure as the original file content, otherwise error will be reported; ignore @t option when the target file already has content; overwrite the original file by default" optionchar="a"/>
<O2 defaultselect="false" description="Write the field name information (titles) to the target file as the first row" optionchar="t"/>
</options>
<params>
<P1 desc="hd(An hd connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="file(The location and name of the file to be loaded to HDFS; can be .txt file or .csv file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="A/cs(A table sequence/record sequence/cursor; do not support a random access file, such as .btx)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="x(The field(s) to be uploaded; upload all fields when the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F(The result field name(s) in the form of string; use original field names when the parameter is absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F296>
<F297 desc="Close a Hive database connection." majortype="102" name="hive_close" postfix="" returntype="102">
<options/>
<params/>
</F297>
<F298 desc="Query a Hive database and return the result as a cursor." majortype="102" name="hive_cursor" postfix="" returntype="101">
<options/>
<params>
<P1 desc="con (Database connection string.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL query statement, like select * from table.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F298>
<F299 desc="Execute Hive’s SQL-like queries. " majortype="102" name="hive_execute" postfix="" returntype="101">
<options/>
<params>
<P1 desc="con (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL query statement, which supports Hive’s SQL-like queries such as create table, drop table, load data, insert into, insert owerwrite, and create view)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F299>
<F300 desc="Create a Hive database connection." majortype="102" name="hive_open" postfix="" returntype="1">
<options/>
<params>
<P1 desc="hdfsUrl (HDFS file connection information )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="thriftUrl (Thrift file connection information)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="dbname (A database name.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="hdfsUserName  (HDFS file user name )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F300>
<F301 desc="uery a Hive database and return the result as a sequence." majortype="102" name="hive_query" postfix="" returntype="101">
<options/>
<params>
<P1 desc="con (Database connection string.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL query statement, like select * from table.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F301>
<F302 desc="Return the hyperlink string of a canvas" majortype="102" name="hlink" postfix="G." returntype="101">
<options/>
<params/>
</F302>
<F303 desc="Set or get the number of memory zone holding a specified task on the current node." majortype="102" name="hosts" postfix="" returntype="101">
<options/>
<params>
<P1 desc="i(An integer that represents memory zone number)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="j(Task name; can be absent)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F303>
<F304 desc="Return a sequence of available nodes." majortype="102" name="hosts" postfix="" returntype="101">
<options/>
<params>
<P1 desc="n(The number of nodes)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="hs(A node sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="j(Task name)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F304>
<F305 desc="Get the hour from a specified time" majortype="102" name="hour" postfix="" returntype="101">
<options/>
<params>
<P1 desc="datetimeExp   (Date or standard datetime format string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F305>
<F306 desc="Get text data under a specified tag in an html file" majortype="101" name="htmlparse" postfix="s." returntype="101">
<options/>
<params>
<P1 desc="tag(A tag in an html file; if the tag’s value is “table”, get all data under it)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="i(An integer)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="j(An integer)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F306>
<F307 desc="Package the returned result of URL as the file flow and return it." majortype="102" name="httpfile" postfix="" returntype="101">
<options/>
<params>
<P1 desc="url (HTTP service in the URL string format.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cs (Character set, which supports JVM's built-in character set, and which by default is the default value of virtual machine.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="post (A parameter submitted with POST method with a syntax like p1=v1&amp;p2=v2…. Can be omitted.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="cs (Character set, which supports JVM's built-in character set, and which by default is the default value of virtual machine.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="header(The header property can have multiple items, like headerName1:value1,headerName2:value2,... (the format is &quot;property&quot;:&quot;value&quot;,…); or can be omitted. The execution of .property() function over a returned file object will return the header property.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F307>
<F308 desc="Upload parameters and files to an URL using the HTTP protocol." majortype="101" name="httpupload" postfix="" returntype="101">
<options/>
<params>
<P1 desc="url (HTTP service’s URL string format)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F308>
<F309 desc="Count the number of distinct members in a sequence" majortype="101" name="icount" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Remove duplicates by comparing neighboring members" optionchar="o"/>
</options>
<params/>
</F309>
<F310 desc="Use index to filter an entity table or a multi-zone composite table according to the filtering condition." majortype="101" name="icursor" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Make sure the result set is ordered by the index and large result sets are supported " optionchar="s"/>
<O2 defaultselect="false" description="Handle multiple conditions joined up with &amp;&amp; from left to right while the default is handling them in an optimal order" optionchar="u"/>
</options>
<params>
<P1 desc="C (To-be-retrieved columns in the cluster table; get all columns when the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="w (Filtering condition, in which the filtering field for T must be the same as the indexing field; support &gt;, &gt;=, &lt;, &lt;=, == and contain in its syntax)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="I (Index name; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F310>
<F311 desc="Use index to filter a cluster table according to the filtering condition." majortype="101" name="icursor" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Make the result set ordered by the index and support a big result set" optionchar="s"/>
</options>
<params>
<P1 desc="C(To-be-retrieved columns in the cluster table; get all columns when the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="w(Filtering condition, in which the filtering field for T must be the same as the indexing field; support &gt;, &gt;=, &lt;, &lt;=, == and contain in its syntax)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="I(Index name; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F311>
<F312 desc="Get distinct values from a sequence." majortype="101" name="id" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Without sorting, remove the repetitive neighboring members only" optionchar="o"/>
<O2 defaultselect="false" description="Do not sort the result set by x. It doesn’t work with @o" optionchar="u"/>
<O3 defaultselect="false" description="Used over a grouped table with each group ordered to speed up grouping" optionchar="h"/>
</options>
<params>
<P1 desc="xi (An expression; use ~ to represent x if the latter is omitted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (The number of to-be-retrieved distinct values counting from the beginning; return all values if it is absent)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F312>
<F313 desc="Return a channel consisting of values of one or more fields." majortype="101" name="id" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="xi  (Expression; use comma to separate multiple expressions)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n  (Integer; can’t be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F313>
<F314 desc="Return a sequence consisting of values of fields in a given cursor." majortype="101" name="id" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Do not sort data while removing neighboring duplicate members; require that data is ordered by expression x" optionchar="o"/>
<O2 defaultselect="false" description="Do not sort result set by expression x; the option and @o are mutually exclusive" optionchar="u"/>
<O3 defaultselect="false" description="Used to segment ordered data, which increases efficiency" optionchar="h"/>
</options>
<params>
<P1 desc="xi  (Expression; use comma to separate multiple expressions)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n  (Integer; return all values when omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F314>
<F315 desc="If a is true, then return true. Otherwise, return false" majortype="102" name="if" postfix="" returntype="101">
<options/>
<params>
<P1 desc="a (Boolean expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F315>
<F316 desc="If a is non-null and non-false, then return b; otherwise return c, which is null by default." majortype="102" name="if" postfix="" returntype="101">
<options/>
<params>
<P1 desc="a (Boolean expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b  (Value expression. If the result of a is true, then return the result of b)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="c (Value expresssion. If the result of a is false, then return the result of c)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F316>
<F317 desc="Calculate the boolean expression from left to right.if bool is true, then return the result of trueValue, and the computation will be terminated; If bool is false, then calculate the next bool. If none of the Boolean expression boolis true, and there is a default expression default, then return the result of default, otherwise return null." majortype="102" name="if" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xk (Boolean expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="yk (Value expression. If the result of xk is true, then return its result.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (Default value expression. If all the results of boolean expressions are false, then return the result of this expression.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F317>
<F318 desc="To judge if an object is a sequence" majortype="102" name="ifa" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x    (the object to be judged)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F318>
<F319 desc="Find whether the type of parameter is date or datetime" majortype="102" name="ifdate" postfix="" returntype="101">
<options/>
<params>
<P1 desc="exp (Expression of any data type)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F319>
<F320 desc="Get the first non-null member of a sequence.Equivalent to ifn(x1,…,xn)" majortype="101" name="ifn" postfix="A." returntype="101">
<options/>
<params/>
</F320>
<F321 desc="Compute x with each member of the sequence and return the first non-null member of the new sequence.Equivalent to A.(x).ifn()" majortype="101" name="ifn" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (Generally ann expression of a single field name, or a legal expression composed of multiple field names)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F321>
<F322 desc="Find whether the parameter is of numeric data type." majortype="102" name="ifnumber" postfix="" returntype="101">
<options/>
<params>
<P1 desc="Exp (Expression of any data type)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F322>
<F323 desc="Find whether an object is a record." majortype="102" name="ifr" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x  (Any data object, for example a constant, an expression, a record, a record sequence, a sequence or a table sequence.) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F323>
<F324 desc="Find whether the parameter is of string data type" majortype="102" name="ifstring" postfix="" returntype="101">
<options/>
<params>
<P1 desc="Exp    (Expression of any data type)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F324>
<F325 desc="Judge if an object is a table sequence" majortype="102" name="ift" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x   (any object, for example: a constant, an expression, a record, a record sequence, a sequence or a  table sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F325>
<F326 desc="Find whether the parameter is of time data type." majortype="102" name="iftime" postfix="" returntype="101">
<options/>
<params>
<P1 desc="exp   (Data expression of any type)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F326>
<F327 desc="Judge if a variable exists" majortype="102" name="ifv" postfix="" returntype="101">
<options/>
<params>
<P1 desc="v (Parameter name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F327>
<F328 desc="Close Informix database connection" majortype="101" name="ifx_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="ifxconn (Ifxconn object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F328>
<F329 desc="Create Informix database connection" majortype="101" name="ifx_conn" postfix="" returntype="101">
<options/>
<params>
<P1 desc="url (The URL to connect to Informix server)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="fragfile (Fragmentation information file that records the fields and every field’s max and min values in each fragmented file)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F329>
<F330 desc="Create Informix database connection" majortype="101" name="ifx_conn" postfix="" returntype="101">
<options/>
<params>
<P1 desc="driver (Name of JDBC driver for connecting to Informix database; the format is com.informix.jdbc.IfxDriver)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F330>
<F331 desc="Query data in fragmented files from k1 to k2 using a SQL statement" majortype="101" name="ifx_cursor" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Allow unordered data" optionchar="o"/>
<O2 defaultselect="false" description="Require data to be ordered" optionchar="f"/>
<O3 defaultselect="false" description="Enable the use of multiple channels" optionchar="m"/>
</options>
<params>
<P1 desc="ifxconn (Ifxconn object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL statement)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="k1 (A fragmented file; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="k2 (A fragmented file; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F331>
<F332 desc="List the fragmentation information of table table with cursors and search fragmented file k1 and fragmented file k2 according to the where condition. Parameter f is the table’s column name and parameter alias is the column’s another name. Parameter where can be omitted; parameter k2 will be omitted if parameter k1 is absent; search only framted file k1 when k2 is absent" majortype="101" name="ifx_cursor" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Allow unordered data" optionchar="o"/>
<O2 defaultselect="false" description="Require data to be ordered" optionchar="f"/>
<O3 defaultselect="false" description="Enable the use of multiple channels" optionchar="m"/>
</options>
<params>
<P1 desc="ifxconn (Ifxconn object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="table (A table being fragmented)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="where (Query condition; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="f (A column name of a fragmented file)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="alias (Another name of column f)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="k1 (A fragmented file; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
<P7 desc="k2 (A fragmented file; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P7>
</params>
</F332>
<F333 desc="Query data over the fragmented file specified by the parameter ifxCursor quries with a SQL statement; parameter f2 is the fragmented field, which, if absent, is the fragmented field of the fragmented file ifxCursor" majortype="101" name="ifx_cursor" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Allow unordered data" optionchar="o"/>
<O2 defaultselect="false" description="Require data to be ordered" optionchar="f"/>
<O3 defaultselect="false" description="Enable the use of multiple channels" optionchar="m"/>
</options>
<params>
<P1 desc="ifxconn (Ifxconn object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL statement)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="ifxCursor (The fragmented file recorded with cursor)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="f2 (A fragmented field; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F333>
<F334 desc="Query table table according to where condition over the fragmented file specified by parameter ifxCursor; parameter f is the table’s column name and parameter alias is its another name; f2 is the fragmented field, which, if absent, is the fragmented field of the fragmented file ifxCursor" majortype="101" name="ifx_cursor" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Allow unordered data" optionchar="o"/>
<O2 defaultselect="false" description="Require data to be ordered" optionchar="f"/>
<O3 defaultselect="false" description="Enable the use of multiple channels" optionchar="m"/>
</options>
<params>
<P1 desc="ifxconn (Ifxconn object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="table (A table being fragmented)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="where (Query condition; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="f (A column name of a fragmented file)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="alias (Another name of column f)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="ifxCursor (The fragmented file recorded with cursor)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
<P7 desc="f2 (A fragmented field; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P7>
</params>
</F334>
<F335 desc="List the fragmentation information of a specified table with table sequences" majortype="101" name="ifx_listfrag" postfix="" returntype="101">
<options/>
<params>
<P1 desc="ifxconn (The ifxconn object which holds the fragmentation information)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="table (A table being fragmented)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F335>
<F336 desc="Save the fragmentation information file stored in the memory as a new file" majortype="101" name="ifx_savefrag" postfix="" returntype="101">
<options/>
<params>
<P1 desc="ifxconn (An ifxconn object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="file (A fragmentation information file, which can be the same file as fragfile or not.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F336>
<F337 desc="Set the fragmentation file of a specified table" majortype="101" name="ifx_setfrag" postfix="" returntype="101">
<options/>
<params>
<P1 desc="ifxconn (An ifxconn object )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="table (A table being fragmented)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="fieldName (Fragmented field)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="min (The minimum value in a fragmented file; can be omitted and can have multiple values)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F337>
<F338 desc="Extract fragmentation information from the database" majortype="101" name="ifx_takefrag" postfix="" returntype="101">
<options/>
<params>
<P1 desc="ifxconn (An Ifxconn object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="table (The table being fragmented; can be omitted and can have multiple number of it)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F338>
<F339 desc="Fi is the retrieved fields. By default, all fields will be retrieved.s is the optional separator. By default, the separator is tab. The format of character string: Separate the records with space, and the fields with optional separators. The default separator is tab." majortype="101" name="import" postfix="S." returntype="101">
<options>
<O1 defaultselect="false" description="In f, take the record in the first row as the field name. If not using this option, then use _1, and _2,… as the field name." optionchar="t"/>
<O2 defaultselect="false" description="Use comma as the separator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option." optionchar="c"/>
<O3 defaultselect="false" description="Won’t split strings and data will be imported as a table sequence consisting of strings of single field values; ignor the parameters" optionchar="s"/>
<O4 defaultselect="false" description="Return the result set as a sequence if it only contains one field" optionchar="i"/>
<O5 defaultselect="false" description="Remove the quotation marks, if any, from both ends of each data item, including those in the field names and handle the escape sequences; quotation marks not located at the ends are left alone" optionchar="q"/>
<O6 defaultselect="false" description="Perfrom escaping according to the Excel rule, which identifies two double quotation marks as one and does not escape the other characters" optionchar="o"/>
<O7 defaultselect="false" description="Retain the whitespaces on both sides of the data item; without it a trim operation will be automatically performed" optionchar="k"/>
<O8 defaultselect="false" description="Generate null if parameter Fi isn’t included in the imported strings; by default there will be an error report " optionchar="e"/>
<O9 defaultselect="false" description="Delete a record if it contains unmatching data types or data formats and start examining data by type" optionchar="d"/>
<O10 defaultselect="false" description="Ignore a row whose number of columns don’t match the first row" optionchar="n"/>
<O11 defaultselect="false" description="In corporation with @d or @n, if a mismatch appears, throw an exception, terminate the execution and output the content of the problem record; error will be reported if parentheses or quotation marks does not match when @p option or @q option is present " optionchar="v"/>
<O12 defaultselect="false" description="Enable not to identify single quotes as the quotes; by defaut both single and double quotes are identified as quotes" optionchar="a"/>
<O13 defaultselect="false" description="Enable handling the matching of parentheses (not including the separators within the parentheses) and quotes, as well as the the escape sequences outside of the quotes; the option covers functionalities defined by @q option" optionchar="p"/>
<O14 defaultselect="false" description="Split the file content into a string by the separator without parsing" optionchar="f"/>
<O15 defaultselect="false" description="Allow line continuation and put an escape character \ at the end the line" optionchar="l"/>
</options>
<params>
<P1 desc="Fi (Fields retrieved. By default, all fields will be retrieved)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="type (Field types include bool, int, long, float, decimal, number, string, date, time and datetime; data type of the first row will be used by default. Its value can only be 16 when it is the length of a serial byte)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="fmt (Date\time format)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="s (User-defined separator; the default is tab.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F339>
<F340 desc="Read contents from a file and return them as a table sequence. " majortype="2" name="import" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Use the first row of f as the field name. If this option is not used, _1, _2,… will be used as field names." optionchar="t"/>
<O2 defaultselect="false" description="Retrieve data from the exported binary file, with the support for parameter Fi, k and n, and with no support available for parameters type and s. Options @t, @s, @i, @q and @m will be ignored. The segmental retrieval could result in empty segment in cases when a file has only a very small number of records or it is unable to be segmented. " optionchar="b"/>
<O3 defaultselect="false" description="Make the function return null when Fi doesn’t exist in the file; raise an error when the option is absent." optionchar="e"/>
<O4 defaultselect="false" description="Do not split the to-be-retrieved field when it is imported as a cursor whose content is a TSeq consisting of strings of a single field; in this case the parameters will be ignored." optionchar="s"/>
<O5 defaultselect="false" description="If the result set has only one column, return it as a sequence" optionchar="i"/>
<O6 defaultselect="false" description="Remove the quotation marks, if any, of the field strings, including the field names, in the first place, and handle the escape sequences. " optionchar="q"/>
<O7 defaultselect="false" description="Use multithreads to increase data retrieval speed, but this will leave an indefinite order for members of the result set. This option will be ignored when parameters k and n exist and it is often used to retrieve data from big files. More than one parallel thread should be specified in license file and configuration information. " optionchar="m"/>
<O8 defaultselect="false" description="Use comma as the seperator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option. " optionchar="c"/>
<O9 defaultselect="false" description="Use quotation marks as the escape character" optionchar="o"/>
<O10 defaultselect="false" description="Retain the whitespaces on both sides of the data item; without it a trim operation will be automatically performed" optionchar="k"/>
<O11 defaultselect="false" description="Delete a record if it contains unmatching data types or data formats and start examining data by type" optionchar="d"/>
<O12 defaultselect="false" description="Ignore and discard rows whose number of columns don’t match the first row" optionchar="n"/>
<O13 defaultselect="false" description="Verify data type matching, and, if error reports, throw an exception, terminate the execution and output the content of the problem record" optionchar="v"/>
</options>
<params/>
</F340>
<F341 desc="Read contents from a file and return them as a table sequence. " majortype="2" name="import" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Use the first row of f as the field name. If this option is not used, _1, _2,… will be used as field names." optionchar="t"/>
<O2 defaultselect="false" description="Retrieve data from the exported binary file, with the support for parameter Fi, k and n, and with no support available for parameters type and s. Options @t, @s, @i, @q and @m will be ignored. The segmental retrieval could result in empty segment in cases when a file has only a very small number of records or it is unable to be segmented." optionchar="b"/>
<O3 defaultselect="false" description="Make the function return null when Fi doesn’t exist in the file; raise an error when the option is absent." optionchar="e"/>
<O4 defaultselect="false" description="Do not split the to-be-retrieved field when it is imported as a cursor whose content is a TSeq consisting of strings of a single field; in this case the parameters will be ignored." optionchar="s"/>
<O5 defaultselect="false" description="If the result set has only one column, return it as a sequence" optionchar="i"/>
<O6 defaultselect="false" description="Remove the quotation marks, if any, of the field stringsfrom both ends of each data item, including those in the field names, in the first place, and handle the escape sequences; quotation marks not located in the ends are left alone " optionchar="q"/>
<O7 defaultselect="false" description="Use multithreads to increase data retrieval speed, but this will leave an indefinite order for members of the result set. This option will be ignored when parameters k and n exist and it is often used to retrieve data from big files. More than one parallel thread should be specified in configuration information. errors may appear when @o option or parameters k:n are present " optionchar="m"/>
<O8 defaultselect="false" description="Use comma as the seperator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option. " optionchar="c"/>
<O9 defaultselect="false" description="Perfrom escaping according to the Excel rule, which identifies two double quotation marks as one and does not escape the other characters" optionchar="o"/>
<O10 defaultselect="false" description="Retain the whitespaces on both sides of the data item; without it a trim operation will be automatically performed" optionchar="k"/>
<O11 defaultselect="false" description="Delete a record if it contains unmatching data types or data formats and start examining data by type" optionchar="d"/>
<O12 defaultselect="false" description="Ignore and discard rows whose number of columns don’t match the first row" optionchar="n"/>
<O13 defaultselect="false" description="Perfrom escaping according to the Excel rule, which identifies two double quotation marks as one and does not escape the other characters" optionchar="v"/>
<O14 defaultselect="false" description="Enable not to identify single quotes as the quotes; by defaut both single and double quotes are identified as quotes" optionchar="a"/>
<O15 defaultselect="false" description="Enable handling the matching of parentheses (not including the separators within the parentheses) and quotes, as well as the the escape sequences outside of the quotes; the option covers functionalities defined by @q option" optionchar="p"/>
<O16 defaultselect="false" description="Enable handling the matching of parentheses (not including the separators within the parentheses) and quotes, as well as the the escape sequences outside of the quotes; the option covers functionalities defined by @q option" optionchar="f"/>
<O17 defaultselect="false" description="Allow line continuation where there is an escape character \ at the end of the line" optionchar="l"/>
</options>
<params>
<P1 desc="Fi      (Fields to be retrieved. All fields will be retrieved by default. The sign # is used to represent a field with a sequence number.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="type (Field types include bool, int, long, float, decimal, string, date, time and datetime. Data type of the first row will be used by default. Its value can only be 16 when it is the length of a serial byte)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="fmt(Date\time format)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="k (The segment number.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="n (The number of segments. Retrieve the whole file when both k and n are omitted.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="s ( User-defined separator. The default separator is tab. When the parameter is omitted, the comma preceding it can be omitted, too. )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F341>
<F342 desc="Read in records from an entity table and return them as a sequence, record sequence or table sequence." majortype="102" name="import" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Enable generating a pure table sequence-based, column-wise cursor" optionchar="v"/>
<O2 defaultselect="false" description="Automatically close the entity table after data is fetched from the cursor" optionchar="x"/>
</options>
<params/>
</F342>
<F343 desc="Get a table sequence based on a pseudo table" majortype="101" name="import" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="xi (A field expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ci (Field name in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F343>
<F344 desc="Impute missing values to a sequence type variable during modeling" majortype="101" name="impute" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Modify the original data to the imputation result after execution" optionchar="c"/>
<O2 defaultselect="false" description="Each option specifies a target type, and options are mutual-exclusive; automatically judge the type when no option is used; the order of priorities of the options is binary, numeric, integer and date" optionchar="BNIED"/>
</options>
<params>
<P1 desc="Rec(A sequence of imputation process records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F344>
<F345 desc="Impute missing values to a table sequence/record sequence type variable during modeling" majortype="101" name="impute" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Modify the original data to the imputation result after execution" optionchar="c"/>
<O2 defaultselect="false" description="Each option specifies a target type, and options are mutual-exclusive; automatically judge the type when no option is used; the order of priorities of the options is binary, numeric, integer and date" optionchar="BNIED"/>
</options>
<params>
<P1 desc="cn(A string/number, which is the name of column (or the column number starting from 1) – the to-be-pre-processed variable – in a table sequence or record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Rec(A sequence of imputation process records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F345>
<F346 desc="Create an index on the key of an in-memory table." majortype="101" name="index" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Create index on the serial byte key" optionchar="s"/>
<O2 defaultselect="false" description="Create the index with parallel processing" optionchar="m"/>
<O3 defaultselect="false" description="Create index on the sequence number key, which can be absent but should be present when there is the time key" optionchar="n"/>
</options>
<params>
<P1 desc="n (Index length)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F346>
<F347 desc="Create an index table for the key of a table sequence" majortype="101" name="index" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Create a multilevel tree-structure index and ignore parameter n if the TSeq’s basic key is serial byte values" optionchar="s"/>
<O2 defaultselect="false" description="Enable parallel processing" optionchar="m"/>
<O3 defaultselect="false" description="Indicate that the basic key values are ordinal numbers; use sequence numbers of records when the option is absent; the option cannot be omitted when time key is present; ignore parameter n when the option works" optionchar="n"/>
</options>
<params>
<P1 desc="n(The length of index)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F347>
<F348 desc="Create an index file for an entity table or a multi-zone composite table" majortype="101" name="index" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Auto-load and maintain the second-level index when only parameter I is present" optionchar="2"/>
<O2 defaultselect="false" description="Auto-load and maintain the third-level index when only parameter I is present" optionchar="3"/>
<O3 defaultselect="false" description="Close the index to release resources when only parameter I is present" optionchar="0"/>
<O4 defaultselect="false" description="Create a full-table index based on a certain column and support like(“*X*”) style search" optionchar="w"/>
</options>
<params>
<P1 desc="I(Index name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="h(Index length)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="w(Filtering condition; retrieve the whose set if the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="C(The field for which an index is created)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F (Field name in an entity table; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F348>
<F349 desc="Return a positive infinity value; with a negative sign before the function, it will return a negative infinity value. " majortype="101" name="inf" postfix="" returntype="101">
<options/>
<params/>
</F349>
<F350 desc="Close InfluxDB connection." majortype="102" name="influx_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hd(Connection object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F350>
<F351 desc="Insert one or more records to InfluxDB database." majortype="102" name="influx_insert" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hd(Connecton object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="string(Line protocol characters or line protocol arrays of characters. Data format should meet the requirements of InfluxDB line protocol; time stamp is represented in UTC or is in the format of yyyy-MM-ddTHH:mm:ss/yyyy-MM-ddTHH:mm:ssXXZ)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F351>
<F352 desc="Connect to InfluxDB." majortype="102" name="influx_open" postfix="" returntype="102">
<options/>
<params>
<P1 desc="url(Database connection URL)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="database(The database)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="retentionPolicy(The retention plicy for defining how long InfluxDb needs to keep the data or which time period of data the database needs to store)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="username(The user name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="password(The password)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F352>
<F353 desc="Query InfluxDB database." majortype="102" name="influx_query" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hd(Connecton object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql(The SQL query statement or database search statement)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F353>
<F354 desc="Insert the members of X before position k in A, and return A." majortype="101" name="insert" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return the inserted record or a record sequence of the inserted records." optionchar="n"/>
</options>
<params>
<P1 desc="k (The position before which one or more members are inserted, when k==0, the member(s) will be appended in the end.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="X (a sequence composed of the members to be inserted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F354>
<F355 desc="Insert member x before position k in A, and return A." majortype="101" name="insert" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return the inserted record or a record sequence of the inserted records." optionchar="n"/>
</options>
<params>
<P1 desc="k  (The position before which one or more members are inserted, when k==0, the member(s) will be appended in the end.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x   (a member)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F355>
<F356 desc="Insert an empty record before the position k in the T. If k is 0, then append it in the end and return the new T" majortype="101" name="insert" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the inserted record or a record sequence of the inserted records" optionchar="n"/>
<O2 defaultselect="false" description="T.insert@r(k:A)        Insert sequence A into table squence T from the kth record according to the order of the fields" optionchar="r"/>
<O3 defaultselect="false" description="T.insert@f(k:A)        Insert sequence A into table squence T from the kth record; only the common fields are inserted. " optionchar="f"/>
</options>
<params>
<P1 desc="k (The position before which the member, or the record, is inserted. When k==0, append it in the end.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F356>
<F357 desc="Insert a record into T before the position k where the value of Fi is xi and return the new T. When parameter k is omitted, we assume the table sequence T is already ordered by the key and insert records; if the key value has already existed, the function won’t perform the insertion." majortype="101" name="insert" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the inserted record or a record sequence of the inserted records" optionchar="n"/>
<O2 defaultselect="false" description="T.insert@r(k:A)        Insert sequence A into table squence T from the kth record according to the order of the fields" optionchar="r"/>
<O3 defaultselect="false" description="T.insert@f(k:A)        Insert sequence A into table squence T from the kth record; only the common fields are inserted. " optionchar="f"/>
</options>
<params>
<P1 desc="k      (The position before which the member, or the record, is inserted. When k==0, append it in the end.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="xi      (The Fi field value before which the new record is to be inserted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi     (The name of field where xi resides; without Fi, it will be the corresponding ith field.)" filtertype="1" identifieronly="true" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F357>
<F358 desc="Insert multiple records into T before the position k where the value of Fi is xi and return the new T . The number of the records to be inserted is determined by the length of sequence A." majortype="101" name="insert" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the newly-inserted or -modified records or record sequences " optionchar="n"/>
<O2 defaultselect="false" description="T.insert@r(k:A)        Insert sequence A into table squence T from the kth record according to the order of the fields" optionchar="r"/>
<O3 defaultselect="false" description="T.insert@f(k:A)        Insert sequence A into table squence T from the kth record; only the common fields are inserted. " optionchar="f"/>
</options>
<params>
<P1 desc="k           (The position before which the member, or the record, is inserted. When k==0, append it in the end.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="A           (A sequence or an integer; If A is an integer, then it is equals to to(A))" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="xi           (The Fi field value before which the new record is to be inserted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="Fi          (The name of field where xi resides; without Fi, it will be the corresponding ith field.))" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F358>
<F359 desc="To obtain the integer part of a numeric value from a numeric string or a number, and convert its data type to 32-bit integer." majortype="102" name="int" postfix="" returntype="101">
<options/>
<params>
<P1 desc="valueExp (an expression, the result of which must be a numeric string or a number.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F359>
<F360 desc="Compute the interval between two datetime values" majortype="102" name="interval" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Compute the years between two date time data" optionchar="y"/>
<O2 defaultselect="false" description="Compute the months between two date time data" optionchar="m"/>
<O3 defaultselect="false" description="Compute the seconds between two date time data" optionchar="s"/>
<O4 defaultselect="false" description="Compute the milliseconds between two date time data" optionchar="ms"/>
<O5 defaultselect="false" description="Compute the quarters between two date time data" optionchar="q"/>
<O6 defaultselect="false" description="Compute the timespan between two date time data and return Real valuer" optionchar="r"/>
<O7 defaultselect="false" description="Compute the weeks between two datetime values" optionchar="w"/>
<O8 defaultselect="false" description="Compute the number of Sundays between two datetime values according to a left-open interval" optionchar="7"/>
<O9 defaultselect="false" description="Compute the number of Mondays between two datetime values according to a left-open interval" optionchar="1"/>
</options>
<params>
<P1 desc="datetimeExp1     (The date expression whose value is a datetime or a string of standard datetime format)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="datetimeExp2     (The date expression whose value is a datetime or a string of standard datetime format)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F360>
<F361 desc="Adjust the order of members of a sequence." majortype="101" name="inv" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="p  (an integer sequence, members of which is the rankings of A, so the number of its members is the same as that of A , and it is a unique n sequence (n=A.len()))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F361>
<F362 desc="Compute the sequence numbers of an integer’s members in another integer sequence." majortype="101" name="inv" postfix="p." returntype="101">
<options/>
<params>
<P1 desc="k (An integer, which is p.len() by default)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F362>
<F363 desc="Calculate the inverse of a square matrix. " majortype="101" name="inverse" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A square matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F363>
<F364 desc="Call the static function of class in the package" majortype="102" name="invoke" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Convert the sequence type parameter or return value; can be performed recursively" optionchar="x"/>
</options>
<params>
<P1 desc="p (package path)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="c (class name)" filtertype="0" identifieronly="false" presign="." repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="f (static method name)" filtertype="0" identifieronly="false" presign="." repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="ai (parameter)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F364>
<F365 desc="Check if a string is composed of letters" majortype="102" name="isalpha" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s (String/ numeric expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F365>
<F366 desc="Check if a string is composed of numbers." majortype="102" name="isdigit" postfix="" returntype="101">
<options/>
<params>
<P1 desc="string (String/ numeric expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F366>
<F367 desc="Compute x with each member of the sequence whose members are sequences, and then perform intersection operation between members of the new sequence" majortype="101" name="isect" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (Generally an expression of a single field name, or a legal expression composed of multiple field names)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F367>
<F368 desc="Compute the intersection of all the member sequences of a sequence" majortype="101" name="isect " postfix="A." returntype="101">
<options/>
<params/>
</F368>
<F369 desc="Retrieve records from file f that is ordered by x field, according to the criterion that the values of x should be members of sequence A" majortype="2" name="iselect" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Use the first row of f as the field names. If omitting this option, then use_1,_2,… as the field names" optionchar="t"/>
<O2 defaultselect="false" description="Retrieve data from an exported binary file, with the support for parameters A, x and Fi, and with no support available for parameter s. Ignore options @t and @c. Segments containing no records may appear if it is a file containing a small number of records; an error report will appear if the file isn’t segmented when being retrieved." optionchar="b"/>
<O3 defaultselect="false" description="Use comma as the separator. By default parameter s is the separator, and use \t as the separator when s is absent. But the user-defined separator s should take priority when there is one." optionchar="c"/>
<O4 defaultselect="false" description="Find all records with the same value of x field; by default x is distinct in the file f." optionchar="r"/>
<O5 defaultselect="false" description="First remove quotation marks surrounding strings, including the headers, and then handle the escaping" optionchar="q"/>
<O6 defaultselect="false" description="Use quotation marks as the escape character" optionchar="o"/>
<O7 defaultselect="false" description="Retain the white space on both sides of the data item; without it a trim operation will be automatically performed" optionchar="k"/>
<O8 defaultselect="false" description="Return a null column if parameter Fi doesn’t exist; the default way of handling is to report error" optionchar="e"/>
<O9 defaultselect="false" description="Perform type matching and delete a record if there is mismatching data type or format in it " optionchar="d"/>
<O10 defaultselect="false" description="Throw an exception, terminate execution, and output the content of the current record whenerrors appear in @d check and @n check" optionchar="v"/>
<O11 defaultselect="false" description="Discard a row whose number of columns doesn’t match the number in the first row" optionchar="n"/>
</options>
<params>
<P1 desc="A (A single value or a sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Field name/expression; the sign # is used to represent a field with a sequence number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi (Fields to be retrieved, and all fields will be retrieved by default)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="s (User-defined separator. The default is tab. When the parameter is omitted, the comma preceding it can be omitted, too)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F369>
<F370 desc="Rtrieve records from file f that is ordered by x field, according to the criterion that the values of x should fall in the interval [a:b]" majortype="2" name="iselect" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Use the first row of f as the field names. If omitting this option, then use_1,_2,… as the field names" optionchar="t"/>
<O2 defaultselect="false" description="Retrieve data from an exported binary file, with the support for parameters A, x and Fi, and with no support available for parameter s. Ignore options @t and @c. Segments containing no records may appear if it is a file containing a small number of records; an error report will appear if the file isn’t segmented when being retrieved." optionchar="b"/>
<O3 defaultselect="false" description="Use comma as the separator. By default parameter s is the separator, and use \t as the separator when s is absent. But the user-defined separator s should take priority when there is one." optionchar="c"/>
<O4 defaultselect="false" description="Find all records with the same value of x field; by default x is distinct in the file f." optionchar="r"/>
<O5 defaultselect="false" description="First remove quotation marks surrounding strings, including the headers, and then handle the escaping" optionchar="q"/>
<O6 defaultselect="false" description="Use quotation marks as the escape character" optionchar="o"/>
<O7 defaultselect="false" description="Retain the white space on both sides of the data item; without it a trim operation will be automatically performed" optionchar="k"/>
<O8 defaultselect="false" description="Return a null column if parameter Fi doesn’t exist; the default way of handling is to report error" optionchar="e"/>
<O9 defaultselect="false" description="Perform type matching and delete a record if there is mismatching data type or format in it " optionchar="d"/>
<O10 defaultselect="false" description="Throw an exception, terminate execution, and output the content of the current record when errors appear in @d check and @n check" optionchar="v"/>
<O11 defaultselect="false" description="Discard a row whose number of columns doesn’t match the number in the first row" optionchar="n"/>
</options>
<params>
<P1 desc="a (Field value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b (Field value)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="x (Field name/expression; the sign # is used to represent a field with a sequence number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="Fi (Fields to be retrieved, and all fields will be retrieved by default)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="s (User-defined separator. The default is tab. When the parameter is omitted, the comma preceding it can be omitted, too)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F370>
<F371 desc="Check if a string is composed of lower case letters" majortype="102" name="islower" postfix="" returntype="101">
<options/>
<params>
<P1 desc="string (String expression/ Integer expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F371>
<F372 desc="Define transaction isolation level for the connection according to the option and return the original level" majortype="102" name="isolate" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="Correspond respectively to NONE" optionchar="n"/>
<O2 defaultselect="false" description="Correspond respectively to READ_COMMITTED" optionchar="c"/>
<O3 defaultselect="false" description="Correspond respectively to READ_UNCOMMITTED" optionchar="u"/>
<O4 defaultselect="false" description="Correspond respectively to REPEATABLE_READ" optionchar="r"/>
<O5 defaultselect="false" description="Correspond respectively to SERIALIZABLE" optionchar="s"/>
</options>
<params/>
</F372>
<F373 desc="Check if a string is composed of upper case letters" majortype="102" name="isupper" postfix="" returntype="101">
<options/>
<params>
<P1 desc="string (String expression/ Integer expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F373>
<F374 desc="Perform interative loop on a record sequence and return the result of the last calculation of a given expression." majortype="101" name="iterate" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (An expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="a (An initial value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="c (A boolean expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F374>
<F375 desc="Perform interative loop on record sequences in a channel and return the result of the last calculation of a given expression" majortype="101" name="iterate" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="x(An expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="a(Initial value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="c(An expression returns true/false)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F375>
<F376 desc="Perform interative loop on record sequences in a cursor and return the result of the last calculation of a given expression" majortype="101" name="iterate" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="x(An expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="a(Initial value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="c(An expression returns true/false)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F376>
<F377 desc="An iterative loop for calculating an expression." majortype="102" name="iterate" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (An expression containing ~~)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="a (Initial value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Gi (Field name)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F377>
<F378 desc="Join multiple sequences together." majortype="102" name="join" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Full join. If no matches are found, then correspond to the null" optionchar="f"/>
<O2 defaultselect="false" description="Left join. Please note that this is the number &quot;1&quot; instead of the letter &quot;l&quot;" optionchar="l"/>
<O3 defaultselect="false" description="Supporse if all Ai are in order for xj, then use merge operation instead." optionchar="m"/>
<O4 defaultselect="false" description="Perform a join according to positions while ignoring parameter xj" optionchar="p"/>
<O5 defaultselect="false" description="Used only to filter A1 and ignore parameter Fi; do not work with @f@1 options" optionchar="i"/>
<O6 defaultselect="false" description="Used only to filter A1 to retain records that cannot be found and ignore parameter Fi; do not work with @f@1 options" optionchar="d"/>
</options>
<params>
<P1 desc="Ai (Sequences or record sequences to be joined)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi  (Field name of the resulting table sequence)" filtertype="0" identifieronly="true" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="xj (Relational field/ expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F378>
<F379 desc="A foreign-key-style join between table sequences/record sequences, or a table sequence and a record sequence." majortype="101" name="join" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Delete a record with a non-matching foreign key value; by default a non-matching record will be represented by null." optionchar="i"/>
<O2 defaultselect="false" description="Use the record as the value of F field to generate a new record; here expression x can be represented by ~. " optionchar="o"/>
<O3 defaultselect="false" description="If parameter x:F is absent, delete the records matching the foreign key and perform the filtering operation only over table sequence/record sequence A" optionchar="d"/>
<O4 defaultselect="false" description="When parameter x is ~, record the relationship between parameter F and parameter C to identify the potentially associative foreign key" optionchar="k"/>
<O5 defaultselect="false" description="Enable a merge join when A is ordered by C and T is ordered by K" optionchar="m"/>
</options>
<params>
<P1 desc="C (A’s foreign key; separate multiple fields in a composite key with the colon)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="T (Table sequence/record sequence/memory table)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="K (T’s key)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="x (T’s field expression, which can be represented by ~ and #; the pound sign # represents the sequence number of a record in T; record the sequence number as 0 if a record doesn’t exist in T)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F (Field name in expression x)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F379>
<F380 desc="A foreign-key-style join between a channel and a record sequence." majortype="101" name="join" postfix="ch." returntype="101">
<options>
<O1 defaultselect="false" description="Delete the whole record if the foreign key can’t be matched; by default make it null." optionchar="i"/>
<O2 defaultselect="false" description="@o(F;…),Generate a new record by introducing the original record as a new field; field expression x can be represented by ~." optionchar="o"/>
</options>
<params>
<P1 desc="C  (Foreign key of a given channel; use comma to separate a composite key)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="T  (Table sequence/record sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="K  (Key of the given table sequence/record sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="x  (A field expression of the given table sequence/record sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F  (Name of the field expression)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F380>
<F381 desc="A foreign-key-style join between a cursor and a table sequence/record sequence.  " majortype="102" name="join" postfix="cs." returntype="102">
<options>
<O1 defaultselect="false" description="Delete a record with a non-matching foreign key value; by default a non-matching record will be represented by null" optionchar="i"/>
<O2 defaultselect="false" description="@o(F;…)   Use the record as the value of F field to generate a new record; here expression x can be represented by ~, which is T’s record" optionchar="o"/>
<O3 defaultselect="false" description="If parameters x:F are absent, only perform a filtering over the cursor by deleting its records where the foreign key is matched " optionchar="d"/>
<O4 defaultselect="false" description="Enable a merge join when A is ordered by C and T is ordered by K" optionchar="m"/>
</options>
<params>
<P1 desc="C (Cursor cs’s foreign key; separate multiple fields in a composite key with the colon)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="T (A table sequence/A record sequence )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="K (T’s key)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="x (T’s field expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F (Field name in expression x)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F381>
<F382 desc="A foreign-key-style join between a cluster cursor and a record sequence." majortype="101" name="join" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="With a distributed cluster table, the operation won’t involve a cross-node reference but it assumes that the referenced records are local" optionchar="c"/>
</options>
<params>
<P1 desc="C(cs’s foreign key; separate multiple fields in a composite key with the colon)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="T(A cluster memory table)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="K(T’s key)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="x(T’s field expression )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F(Name of T’s field expression)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F382>
<F383 desc="A foreign-key-style join beween an in-memory table and a table sequence or two in-memory tables" majortype="101" name="join" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Delete records of T that cannot match the foreign key, and by default, will record corresponding values as nulls. When parameters x:F are absent, just perform the fileting on Ai" optionchar="i"/>
<O2 defaultselect="false" description="@o(F;…) Use the original records of Ai as a new field F to generate new records; here x is equivalent to ~" optionchar="o"/>
<O3 defaultselect="false" description="Delete records of T that match the foreign key when parameters x:F are absent, which is equivalent to performing fileting on Ai" optionchar="d"/>
<O4 defaultselect="false" description="When x is represented by ~, record the correspondence relationship between F and C,…in the result set to identify the foreign key for a pre-join" optionchar="k"/>
</options>
<params>
<P1 desc="C(T’s foreign key; use colon to separate multiple fields of a composite foreign key)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ai(A table sequence or an in-memory table)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="K(Ai’s key)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="x(Expression of an Ai’s field)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="F(Field name of expression x)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F383>
<F384 desc="Join table sequences retrieved from a series of cursors." majortype="102" name="joinx" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Full join. If no matched value is found, then it corresponds to null" optionchar="f"/>
<O2 defaultselect="false" description="Left join. Note that it is the number “1”, instead of letter “l”. " optionchar="1"/>
<O3 defaultselect="false" description="Perform a join according to positions, while ignoring the parameter xj" optionchar="p"/>
<O4 defaultselect="false" description="Used only to filter A1 cs1 and ignore parameter Fi; do not work with @f@1 options" optionchar="i"/>
<O5 defaultselect="false" description="Used only to filter cs1 to retain records that cannot be found and ignore parameter Fi; do not work with @f@1 options" optionchar="d"/>
</options>
<params>
<P1 desc="csi (Cursors/table sequences/cluster cursors being joined.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Field name of result TSeq)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="xj (Join field/expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F384>
<F385 desc="Join up synchronously segmented cluser cursors." majortype="101" name="joinx" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Full join; use null to correspond when there is no matching value" optionchar="f"/>
<O2 defaultselect="false" description="Left join; the option is number 1 instead of letter l" optionchar="1"/>
<O3 defaultselect="false" description="Join by positions; ignore parameter xj" optionchar="p"/>
</options>
<params>
<P1 desc="csi (To-be-joined cluster cursors)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (The resulting field)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="xi (Joining field/expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F385>
<F386 desc="Join up a cursor and a segmentable bin file by the foreign key." majortype="101" name="joinx" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Discard the records whose foreign key values can’t be matched" optionchar="i"/>
<O2 defaultselect="false" description="Generate a new record by adding a F field whose values are referenced records; expression x can be represented by ~, which means a record" optionchar="o"/>
<O3 defaultselect="false" description="When parameters x:F are absent, discard the records whose foreign key values are matching" optionchar="d"/>
<O4 defaultselect="false" description="Speed up the matching action according to a certain order when the cursor contains a relatively small amount of data or it is a sequence; return a sequence when cursor/multicursor cs is a sequence  " optionchar="q"/>
<O5 defaultselect="false" description="Speed up the matching operation by shuffling records in the cursor" optionchar="u"/>
<O6 defaultselect="false" description="Perform a merge join when cs is ordered by C and f is ordered by K; with this option, the bin file f can be a cursor, and when cs is a multicursor, it is the multicursor partitioned in the same way" optionchar="m"/>
</options>
<params>
<P1 desc="C (cs’s foreign key)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="f (A bin file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="K (The bin file’s key; it is treated as row number when written as # )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="x (An expression of the field of f)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F (Name of the field of expression x)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="n (Number of buffer rows)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F386>
<F387 desc="Join up a cursor and an entity table by the foreign key." majortype="101" name="joinx" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Discard the records whose foreign key values can’t be matched" optionchar="i"/>
<O2 defaultselect="false" description="@o(F;…)   Generate a new record by adding a F field whose values are referenced records; expression x can be represented by ~, which means a record" optionchar="o"/>
<O3 defaultselect="false" description="When parameters x:F are absent, discard the records whose foreign key values are matching" optionchar="d"/>
<O4 defaultselect="false" description="Speed up the matching action according to a certain order when the cursor contains a relatively small amount of data or it is a sequence cs Speed up the join when the cursor contains relatively small amount of data or is a sequence" optionchar="q"/>
<O5 defaultselect="false" description="Speed up the matching action if the cursor is ordered by the first foreign key field.When the cursor is ordered by the first field of its foreign key, use it to speed up the join; can work with @q" optionchar="c"/>
<O6 defaultselect="false" description="Speed up the matching operation by shuffling records in the cursor" optionchar="u"/>
</options>
<params>
<P1 desc="C (cs’s foreign key)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P1>
<P2 desc="T (An entity table)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="K (The entity table’s key; it is treated as row number when written as #)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="x (An expression of the field of T)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F (Name of the field of expression x)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="n (Number of buffer rows)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F387>
<F388 desc="Join up a channel and a bin file or an entity table by the foreign key." majortype="102" name="joinx" postfix="ch." returntype="102">
<options>
<O1 defaultselect="false" description="Discard the records whose foreign key values can’t be matched" optionchar="i"/>
<O2 defaultselect="false" description="@o(F;…)   Generate a new record by adding a F field whose values are referenced records; expression x can be represented by ~, which means a record" optionchar="o"/>
<O3 defaultselect="false" description="When parameters x:F are absent, discard the records whose foreign key values are matching" optionchar="d"/>
<O4 defaultselect="false" description="Speed up the matching action according to a certain order when the channel contains a relatively small amount of data or it is a sequence " optionchar="q"/>
<O5 defaultselect="false" description="Speed up the matching action if the channel is ordered by the first foreign key field; can work with @q" optionchar="c"/>
<O6 defaultselect="false" description="Speed up the matching operation by shuffling records in the channel" optionchar="u"/>
</options>
<params>
<P1 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F388>
<F389 desc="Join up multiple pseudo tables" majortype="102" name="joinx" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Full join; if no matching records are found, then use nulls to correspond" optionchar="f"/>
<O2 defaultselect="false" description="Left join; note that it is the number “1”, instead of letter “l”" optionchar="1"/>
<O3 defaultselect="false" description="Perform the join according to positions while ignoring the parameter xj" optionchar="p"/>
</options>
<params>
<P1 desc="Ti (Pseudo tables being joined)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Field name of the result pseudo table)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="xj (The join field or join expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F389>
<F390 desc="Parse a string, a record or a table sequence in JSON format." majortype="102" name="json" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Treat parameter x as an expression and calculate its result" optionchar="v"/>
<O2 defaultselect="false" description="Arrange the returned result set as a same-structure table sequence" optionchar="t"/>
</options>
<params>
<P1 desc="x(A JSON string/record/sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F390>
<F391 desc="Get environment information of the current JVM" majortype="102" name="jvm" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (Key name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F391>
<F392 desc="Generate a serial byte with a specified number of bytes" majortype="102" name="k" postfix="" returntype="102">
<options/>
<params>
<P1 desc="n (An integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="l (The length of bytes)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F392>
<F393 desc="Generate a serial byte with a specified number of bytes" majortype="101" name="k" postfix="" returntype="101">
<options/>
<params>
<P1 desc="ni (Byte value)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F393>
<F394 desc="Close a Consumer connection" majortype="101" name="kafka_close" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd (A consumer object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F394>
<F395 desc="Commit the current consumer offset position" majortype="101" name="kafka_commit" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Asynchronous commit" optionchar="a"/>
</options>
<params>
<P1 desc="fd (A consumer object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F395>
<F396 desc="Connect to Kafka server" majortype="102" name="kafka_open" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="For the use of clustering and related operations" optionchar="c"/>
</options>
<params>
<P1 desc="filename/fileObject(The attribute parameter file with the extension .properties, which contains the send key, value encoding and message decoding; all of them should correspond to each other one by one/A file object)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="topic(Query one or more specified topics)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="partitionSize(The number of zones on a topic, which can be absent and is valid only in the context of a cluster)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F396>
<F397 desc="Return records in a Consumer topic as a table sequence" majortype="101" name="kafka_poll" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd (A Consumer object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="timeout (The interval of consumer poll loop; default is 1000ms)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="partition(A Kafka topic partition in the cluster mode, which is an integer or an array of integers)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F397>
<F398 desc="A producer publishes messages to topics" majortype="102" name="kafka_send" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd(A consumer object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="partition(The index number of a topic partition in a cluster, which is an integer beginning from 0)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="key(The key word of a message)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="value(Value of a message)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F398>
<F399 desc="Connect to Kafka server" majortype="101" name="kafka_subscribe" postfix="" returntype="101">
<options/>
<params>
<P1 desc="prop:value (The property parameter Properties, which will be input in the form of k:v and which can include multiple property parameters; refer to Kaka documents to learn more about this)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="topic (Query a topic or multiple topics)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="keyType (The data type of a Consumer key, which is by default the string; it supports int, integer, float, long and string)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="ValueType (The data type of a Consumer key, which is by default the string; it supports int, integer, float, long and string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F399>
<F400 desc="Connect to Kafka server" majortype="101" name="kafka_subscribe" postfix="" returntype="101">
<options/>
<params>
<P1 desc="filename (The property parameter file suffixed with .properties)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="fileObject  (A file object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="topic (Query a topic or multiple topics)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="keyType (The data type of a Consumer key, which is by default the string; it supports int, integer, float, long and string)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="valueType (The data type of a Consumer key, which is by default the string; it supports int, integer, float, long and string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F400>
<F401 desc="Get the primary key value of a record." majortype="101" name="key" postfix="r." returntype="101">
<options/>
<params>
<P1 desc="Fi (Key)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F401>
<F402 desc="Set a key for a table sequence." majortype="101" name="keys" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Set the last parameter KT as the time key, and make all other parameters the basic keys" optionchar="t"/>
</options>
<params>
<P1 desc="Ki(Key name; can be one or multiple keys; delete all keys of a memory table when the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F402>
<F403 desc="Define the key(s) for a memory table." majortype="101" name="keys" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="@t(…,KT)   Set the last parameter KT as the time key and all other key fields constitute the basic key" optionchar="t"/>
</options>
<params>
<P1 desc="Ki(Key name; can be one or multiple keys; delete all keys of a memory table when the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F403>
<F404 desc="Create an index over a primary key when the latter is set" majortype="101" name="keys" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Create a hash index" optionchar="i"/>
<O2 defaultselect="false" description="Create a serial byte index for a serial byte primary key; omit parameter n when using this option" optionchar="s"/>
<O3 defaultselect="false" description="Enable parallel processing" optionchar="m"/>
<O4 defaultselect="false" description="Indicate that a table has a time key" optionchar="t"/>
<O5 defaultselect="false" description="Indicate that a table has a sequence number key" optionchar="n"/>
</options>
<params>
<P1 desc="Ki(Primary key, which can be one or multiple; delete all keys of a memory table when this parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(An integer greater than 1, which is length of the hash table; its default lenght is the table length. Will be omitted when creating a serial byte index with @s option)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F404>
<F405 desc="Perform an unsupervised clustering algorithm that divides a dataset into predetermined number of clusters based on the minimum error function" majortype="101" name="kmeans" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A sequence, which is the training set)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F405>
<F406 desc="An external libaray function that builds models and performs predictions using the Lasso regression method." majortype="102" name="lasso" postfix="" returntype="102">
<options/>
<params>
<P1 desc="X(A matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Y(A vector having the same number of rows as matrix X)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="learning_rate(Learning rate that is a decimal between 0 and 1; default value is 0.01)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="iterations(Number of iterations; default is 1000)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F406>
<F407 desc="Return the least common multiple" majortype="102" name="lcm" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (The expression, which will be ignored if its value is not a number)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F407>
<F408 desc="Return the least common multiple" majortype="102" name="lcm" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A (Sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F408>
<F409 desc="Get the substring from the left of a string" majortype="102" name="left" postfix="" returntype="101">
<options/>
<params>
<P1 desc="string (Get the source string of the substring)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n   (Get the length of the substring)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F409>
<F410 desc="Get the length of a sequence" majortype="101" name="len" postfix="A." returntype="101">
<options/>
<params/>
</F410>
<F411 desc="Get the number of records in a memory table." majortype="101" name="len" postfix="T." returntype="101">
<options/>
<params/>
</F411>
<F412 desc="Compute the length of string" majortype="102" name="len" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s (String for which you want to compute the length)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cs (Charset; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F412>
<F413 desc="Compute the logarithm with 10 as its base" majortype="102" name="lg" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp (Data to compute the logarithm with 10 as its base)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F413>
<F414 desc="Find if a string matches a format string" majortype="102" name="like" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Indicate not case-sensitive during matching, otherwise, case sensitive by default" optionchar="c"/>
<O2 defaultselect="false" description="Use SQL wildcard characters; % matches zero or multiple characters and __ matches a single character; This option does not work with @c option. " optionchar="s"/>
</options>
<params>
<P1 desc="stringExp      (Expression of character sting) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="formatExp     (Expression of format string) " filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F414>
<F415 desc="Perform linear fitting using the least squares method." majortype="101" name="linefit" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Enable returning a vector since parameter Y is a vector" optionchar="1"/>
</options>
<params>
<P1 desc="A(A matrix or a vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Y(A matrix or a vector)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F415>
<F416 desc="For linear programming and calculate absolute value in linear objective function under linear constraints" majortype="101" name="lineplan" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A sequence representing coefficient matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(A sequence representing a constraints matrix)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="C(The objective function matrix)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F416>
<F417 desc="Compute the natural logarithm of parameters" majortype="102" name="ln" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp (Data for which you want to compute the natural logarithm)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F417>
<F418 desc="Use a synchronization lock." majortype="101" name="lock" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Unlock the restriction" optionchar="n"/>
</options>
<params>
<P1 desc="n (Lock name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s (Timeout (in millisecond); waiting to be locked if the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F418>
<F419 desc="Convert the value of a string  to a 64-bit long integer." majortype="102" name="long" postfix="" returntype="101">
<options/>
<params>
<P1 desc="stringExp (The string expression you want to return as a long integer.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F419>
<F420 desc="Convert the value of  a number to a 64-bit long integer." majortype="102" name="long" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp(The number you want to return as a long integer. If the number contains decimal fractions, the fractional part will be truncated. )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F420>
<F421 desc="Convert a date to a 64-bit long integer" majortype="102" name="long" postfix="" returntype="101">
<options/>
<params>
<P1 desc="dateExp(Date type expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F421>
<F422 desc="Convert all characters to lower case" majortype="102" name="lower" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="A quoted string won’t be converted" optionchar="q"/>
</options>
<params>
<P1 desc="s      (Strings you want to convert to the lower case)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F422>
<F423 desc="Get members at specified positions.-n&lt;=i&lt;=n and i is not equal to 0; For 1≤i≤n, it indicates to get the ith member; For -n≤i≤-1,  it indicates to get the ith member from the last " majortype="101" name="m" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Turn back the position exceeding the boundary of A, that is, to set i=if(i%n==0,n,i%n), where n is the length of A." optionchar="r"/>
<O2 defaultselect="false" description="The position exceeding the boundary of A will be ignored." optionchar="0"/>
</options>
<params>
<P1 desc="i (an integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F423>
<F424 desc="P is a non-zero n-integer sequence " majortype="101" name="m" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Turn back the position exceeding the boundary of A, that is, to set i=if(i%n==0,n,i%n), where n is the length of A." optionchar="r"/>
<O2 defaultselect="false" description="The position exceeding the boundary of A will be ignored." optionchar="0"/>
</options>
<params>
<P1 desc="P (A non-zero n-integer sequence) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F424>
<F425 desc="Get members of a sequence at specified positions to form a new sequence." majortype="101" name="m" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="a (Integer; 1 by default)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b (Integer; -1 by default)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="c (Integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="d (Integer; 1 by default)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="e (Integer; -1 by default)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F425>
<F426 desc="Calculate the mean absolute error between two vectors." majortype="101" name="mae" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(Vectors)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(Vectors)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F426>
<F427 desc="Compute the maximum value of all the non-null members in a sequence.Equivalent to max(x1,…,xn)" majortype="101" name="max" postfix="A." returntype="101">
<options/>
<params/>
</F427>
<F428 desc="Compute x with each member of the sequence and then compute the maximum value of the members of the new sequence,Equivalent to A.(x).max()" majortype="102" name="max" postfix="A." returntype="102">
<options/>
<params>
<P1 desc="x (Generally an expression of a single field name, or a legal expression composed of multiple field names)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F428>
<F429 desc="Pick out the maximum member of a sequence" majortype="101" name="maxp" postfix="A." returntype="101">
<options>
<O1 defaultselect="true" description="Return the first member that fulfills the conditions" optionchar="1"/>
<O2 defaultselect="false" description="Return all the members that fulfill the conditions. By default, it is @1" optionchar="a"/>
<O3 defaultselect="false" description="Search the members from back to front" optionchar="z"/>
</options>
<params>
<P1 desc="x  (The expression to be computed)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F429>
<F430 desc="Perform cumulative sum on a matrix or a multidimensional matrix." majortype="102" name="mcumsum" postfix="" returntype="102">
<options/>
<params>
<P1 desc="A(A matix or a multidimensional matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(A positive integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F430>
<F431 desc="Generate a multicursor based on a sequence of cursors." majortype="101" name="mcursor" postfix="CS." returntype="101">
<options/>
<params/>
</F431>
<F432 desc="Generate a multicursor based on one cursor." majortype="101" name="mcursor" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="n  (An integer, which should be no greater than the number of parallel tasks set in TOOL&gt;OPTION.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F432>
<F433 desc="Return a string’s MD5 signature. " majortype="101" name="md5" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s (A string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F433>
<F434 desc="Divide a sequence into multiple segments and return the specified bordering member(s)" majortype="101" name="median" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="k (The kth segment (1=&lt;k&lt;=n); return the bordering members of between every two segments as sequence when k is absent )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (The number of to-be-divided segments, which is greater than 1 and whose default is 2; can be omitted when parmeter k is absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F434>
<F435 desc="Divide a sequence into multiple segments and return the specified bordering member(s)." majortype="102" name="median" postfix="A." returntype="102">
<options/>
<params>
<P1 desc="k (The kth segment (1=&lt;k&lt;=n); return the bordering members of between every two segments as sequence when k is absent )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (The number of to-be-divided segments, which is greater than 1 and whose default is 2; can be omitted when parmeter k is absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="x (An expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F435>
<F436 desc="Generate an in-memory table from a cursor." majortype="102" name="memory" postfix="cs." returntype="102">
<options>
<O1 defaultselect="false" description="Group the would-be in-memory table by the first field, which must be ordered; when the first field is already segmented and the to-be-retrieved field, the result table will inherit the segmentation" optionchar="p"/>
<O2 defaultselect="false" description="Use pure table sequence" optionchar="v"/>
</options>
<params>
<P1 desc="K (The key; can be omitted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F436>
<F437 desc="Generate a cluster memory table from a cluster cursor." majortype="101" name="memory" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="K(The key; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F437>
<F438 desc="Generate a cluster memory table from a local memory table" majortype="101" name="memory" postfix="" returntype="101">
<options/>
<params>
<P1 desc="h (Node sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="V (A memory table’s global variable)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F438>
<F439 desc="Generate a memory table from an entity table." majortype="101" name="memory" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Group the would-be in-memory table by the first field, which must be ordered; when the first field is already segmented and the to-be-retrieved field, the result table will inherit the segmentation" optionchar="p"/>
<O2 defaultselect="false" description="Use pure table sequence" optionchar="v"/>
</options>
<params>
<P1 desc="C(A column name; import all columns when the parameter is omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="w(Filtering condition; won’t perform filtering when the parameter is omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F439>
<F440 desc="Generate a cluster memory table from a cluster entity table." majortype="101" name="memory" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="C(A column name; import all columns when the parameter is omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="w(Filtering condition; won’t perform filtering when the parameter is omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F440>
<F441 desc="Merge multiple table sequences/record sequences." majortype="101" name="merge" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Remove the duplicates from the table sequence/record sequence generated from unioning members of A(i)s in certain order; records with same xi have same corresponding members of A(i)" optionchar="u"/>
<O2 defaultselect="false" description="Return a table sequence/record sequence composed of the common members of A(i)s" optionchar="i"/>
<O3 defaultselect="false" description="Generate a new table sequence/record sequence by removing members of A(2)&amp;…A(n) from A(1)." optionchar="d"/>
<O4 defaultselect="false" description="Do not assume that A(i) is already sorted by [xi,…]" optionchar="o"/>
<O5 defaultselect="false" description="Put records with null values at the end" optionchar="0"/>
<O6 defaultselect="false" description="Remove common members of A(i) and union the other members to generate a new table sequence/sequence" optionchar="x"/>
</options>
<params>
<P1 desc="xi  (A field of A(i). If performing merge by multiple fields, use the comma to separate them, for example, x1,x2... )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F441>
<F442 desc="Merge data of the member cursors of a cursor/composite table cursor sequence. " majortype="101" name="mergex" postfix="CS." returntype="101">
<options>
<O1 defaultselect="false" description="Combine members of CS, the sequence of cursors, in a certain order to create a new cursor. All duplicate members are included by default." optionchar="u"/>
<O2 defaultselect="false" description="Return a cursor composed of common members of CS, the sequence of cursors." optionchar="i"/>
<O3 defaultselect="false" description="The new cursor created by removing members of CS2&amp;…CSn from CS1." optionchar="d"/>
<O4 defaultselect="false" description="Put records with null values at the end" optionchar="0"/>
<O5 defaultselect="false" description="Only merge distinct records in member cursors" optionchar="x"/>
</options>
<params>
<P1 desc="xi (An expression. If perfoming merge by multiple fields, use comma to separate them, for example, x1,x2....)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F442>
<F443 desc="Merge all parts of a cluster cursor into a local ordinary cursor." majortype="101" name="mergex" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="xi (A field expression; use the comma to separate multiple expressions if it is a merge by multiple fields, like x1,x2...)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F443>
<F444 desc="Merge multicursors into an ordinary cursor." majortype="101" name="mergex" postfix="mcs." returntype="101">
<options/>
<params>
<P1 desc="xi (A field expression; use the comma to separate multiple expressions if it is a merge by multiple fields, like x1,x2...)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F444>
<F445 desc="Search for positions of non-zero members in a vector or matrix." majortype="102" name="mfind" postfix="" returntype="102">
<options/>
<params>
<P1 desc="A(A vector or a matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(A positive integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F445>
<F446 desc="Create indicator variable for missing values in a sequence variable" majortype="101" name="mi" postfix="A." returntype="101">
<options/>
<params/>
</F446>
<F447 desc="Create indicator variable for missing values for a table sequence/record sequence variable during modeling" majortype="101" name="mi" postfix="P." returntype="101">
<options/>
<params>
<P1 desc="cn(A string/number, which is the name of column (or the column number starting from 1) – the to-be-pre-processed variable – in a table sequence or record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F447>
<F448 desc="Return the substring of a string " majortype="102" name="mid" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s  (Source string from which to get the substring )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="start (Get the starting position of substring )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="len (Get the length of substring. By default, the length will be counted from the starting character to the  end of the source string) " filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F448>
<F449 desc="Get the millisecond from a specified datetime value." majortype="102" name="millisecond" postfix="" returntype="101">
<options/>
<params>
<P1 desc="datetimeExp (An expression whose result is a date or a datetime value of standard format)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F449>
<F450 desc="Compute the minimum value of all the non-null members in a sequence.Equivalent to min(x1,…,xn)" majortype="101" name="min" postfix="A." returntype="101">
<options/>
<params/>
</F450>
<F451 desc="Compute x with each member of the sequence and then compute the minimum value of the members of the new sequence" majortype="101" name="min" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (Generally an expression of a single field name, or a legal expression composed of multiple field names)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F451>
<F452 desc="Get the member that makes the minimum value for the expression" majortype="101" name="minp" postfix="A." returntype="101">
<options>
<O1 defaultselect="true" description="Return the first member that fulfills the conditions" optionchar="1"/>
<O2 defaultselect="false" description="Return all the members that fulfill the conditions. By default, it is @1" optionchar="a"/>
<O3 defaultselect="false" description="Search the members from back to front " optionchar="z"/>
</options>
<params>
<P1 desc="x (the expression to be computed)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F452>
<F453 desc="Get the minute from a datetime value." majortype="102" name="minute" postfix="" returntype="101">
<options/>
<params>
<P1 desc="datetimeExp (An expression whose result is a date or a datetime value of standard format)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F453>
<F454 desc="Calculate the mean value within a matrix or a multidimensional marix." majortype="102" name="mmean" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Calculate the mean on all elements of matrix A and parameter n is invalid" optionchar="a"/>
</options>
<params>
<P1 desc="A(A matrix or a multidimensional matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(A positive integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F454>
<F455 desc="Normalize a matrix or a multidimensional matrix, during which the center value is 0 and the standard deviation is 1." majortype="102" name="mnorm" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Handle the normalization using a statistical method where n-1 is the divisor" optionchar="s"/>
</options>
<params>
<P1 desc="A(A matrix or a multidimensional matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(A positive integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F455>
<F456 desc="Get the most frequently appearing members from a sequence or a table sequence." majortype="101" name="mode" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (Fields of the table sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F456>
<F457 desc="Modify the field values of a record" majortype="101" name="modify" postfix="r." returntype="101">
<options>
<O1 defaultselect="false" description="" optionchar="r"/>
</options>
<params>
<P1 desc="xi  (Modification expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Name of the field to be modified. The ith field in r will be modified if Fi isn’t supplied.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F457>
<F458 desc="Modify the kth record, which is equal to T(k).modify(xi:Fi,…)" majortype="101" name="modify" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the newly-modified records or record sequences" optionchar="n"/>
<O2 defaultselect="false" description="@r(k:A)    Modify table sequence T using squence A from the kth record according to the order of the fields" optionchar="r"/>
<O3 defaultselect="false" description="@f(k:A)    Modify table sequence T using squence A from the kth record; only the common fields are modified. " optionchar="f"/>
</options>
<params>
<P1 desc="k   (The position at which the record will be modified. If k exceeds the limit, then append a new record in the end.) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="xi   (The value of Fi field to be modified)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi   (Name of the field of the record which will be modified. If Fi is omitted, then modify the ith field of T.)" filtertype="1" identifieronly="true" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F458>
<F459 desc="Modify the records from the kth record to the (k+|A|-1)th record" majortype="101" name="modify" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the newly-modified records or record sequences" optionchar="n"/>
<O2 defaultselect="false" description="@r(k:A)   Modify table sequence T using squence A from the kth record according to the order of the fields" optionchar="r"/>
<O3 defaultselect="false" description="@f(k:A)   Modify table sequence T using squence A from the kth record; only the common fields are modified. " optionchar="f"/>
</options>
<params>
<P1 desc="k (The position at which the record will be modified. If k exceeds the limit, then append a new record in the end.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="A (A sequence or an integer; If A is an integer, then it is equal to to(A))" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="xi (The value of Fi field to be modified)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="Fi (Name of the field of the record which will be modified. If Fi is omitted, then modify the ith field of T.)" filtertype="1" identifieronly="true" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F459>
<F460 desc="Assign x to the kth member of sequence A" majortype="101" name="modify" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return the modified record or a record sequence of modified records" optionchar="n"/>
</options>
<params>
<P1 desc="k (A member position; If k is greater than the length of sequence A, then append the member in the end)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (a member value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F460>
<F461 desc="Assign members of X to members of A in order from the kth position to the (k+|X|-1)th position " majortype="101" name="modify" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return the modified record or a record sequence of modified records" optionchar="n"/>
</options>
<params>
<P1 desc="k  (A member position; If k is greater than the length of sequence A, then append the member in the end)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="X (a sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F461>
<F462 desc="Close conncetion to MongoDB database" majortype="101" name="mongo_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="fd (MongoDB connection object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F462>
<F463 desc="Insert data to a MongoDB database." majortype="102" name="mongo_insert" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd(A MongoDB database object to be connected)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="collection(A MongoDB collection)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="T(A table sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F463>
<F464 desc="Insert data to a MongoDB database." majortype="102" name="mongo_insert" postfix="" returntype="102">
<options/>
<params>
<P1 desc="fd (A MongoDB database object to be connected)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="collection (A MongoDB collection)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="cs (A cursor)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F464>
<F465 desc="Connect to the MongoDB server." majortype="101" name="mongo_open" postfix="" returntype="101">
<options/>
<params>
<P1 desc="url (mongodb://[username:password@]host1[:port1]       [,host2[:port2],...[,hostN[:portN]]]/database[?options])" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F465>
<F466 desc="Query and manipulate the databsase and return result value." majortype="102" name="mongo_shell" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Return a table sequence" optionchar="d"/>
<O2 defaultselect="false" description="Return a cursor; should be used together with @d option, otherwise it is invalid" optionchar="c"/>
</options>
<params>
<P1 desc="fd (MongoDB connection object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s (An MongoDB function, which supports find, count, distinct and aggregate and follows the MongoDB syntax)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F466>
<F467 desc="Get the month from a specified date/datetime value." majortype="102" name="month" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Return a 6-digit number if there is a year part in the parameter" optionchar="y"/>
</options>
<params>
<P1 desc="dateExp (An expression whose result is a date or a datetime value of standard format; it can be an integer, which we can regard as the value of computing days@o().)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F467>
<F468 desc="Move, delete, or rename a file." majortype="102" name="movefile" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Force an execution of the function if the target file already exists. Without the option you can’t force an execution. Delete the target file if parameter path is absent." optionchar="y"/>
<O2 defaultselect="false" description="Copy the file. If the target file name is the same as that of the specified file to which it will be moved, the copy fails." optionchar="c"/>
<O3 defaultselect="false" description="path is relative to the main directory when it is a relative path; default is relative to fn’s parent directory" optionchar="p"/>
</options>
<params>
<P1 desc="fn(A file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="path(The path (with file name) along which the file is moved, or a file name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F468>
<F469 desc="Move a file from a node to another" majortype="102" name="movefile" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Force moving to overwerite a namesake file while default is failure, and deletion when path is null;" optionchar="y"/>
<O2 defaultselect="false" description="Copy the file, and the copy fails if there is already a namesake file" optionchar="c"/>
</options>
<params>
<P1 desc="fn(A file name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="z(An integer that can be omitted, or a zone table number when fn is a homo-name files group; can )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="h(A node)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="path(A path (that contains file name) to which a file is moved, or a file name)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="hs(A node or a node sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F469>
<F470 desc="Calculate the standard error of the mean between two vectors." majortype="101" name="mse" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(Vectors)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(Vectors)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F470>
<F471 desc="Calculate the standard deviation on a matrix or a multidimensional marix." majortype="102" name="mstd" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Perform the calculation using a statistical method, during which the n-1 is the divisor" optionchar="s"/>
<O2 defaultselect="false" description="Calculate the standard deviation on all elements of matrix A and parameter n is invalid" optionchar="a"/>
</options>
<params>
<P1 desc="A(A matrix or a multidimensional matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(A positive integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F471>
<F472 desc="Calculate sum on a matrix or a multidimensional marix." majortype="102" name="msum" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Calculate sum on all elements of matrix A and parameter n is invalid" optionchar="a"/>
</options>
<params>
<P1 desc="A(A matrix or a multidimensional matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(A positive integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F472>
<F473 desc="Calculate the product of two matrices or vectors." majortype="101" name="mul" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A matrix or a vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(A matrix or a vector)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F473>
<F474 desc="Create indicator variables for the MVP analysis and automatically perform the subsequent handling according to a sequence of indicator variables for missing values" majortype="101" name="mvp" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Each option specifies a target type, and options are mutual-exclusive; automatically judge the type when no option is used; the order of priorities of the options is binary, numeric, integer and enumerated" optionchar="bnie"/>
</options>
<params>
<P1 desc="T(A sequence of target variable values)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Rec(A sequence of creation and handling records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F474>
<F475 desc="Create indicator variables for the MVP analysis and automatically perform the subsequent handling according to a table sequence/record sequence of indicator variables for missing values" majortype="101" name="mvp" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Each option specifies a target type, and options are mutual-exclusive; automatically judge the type when no option is used; the order of priorities of the options is binary, numeric, integer and enumerated" optionchar="bnie"/>
</options>
<params>
<P1 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F475>
<F476 desc="Return a file’s path relative to the main directory." majortype="2" name="name" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Return a full path" optionchar="p"/>
</options>
<params/>
</F476>
<F477 desc="Generate a new table sequence/record sequence, whose field values are computed from the field values of a table sequence/record sequence." majortype="101" name="new" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Use parallel algorithm to handle data-intensive or computation-intensive tasks; no definite order for the records in the result set." optionchar="m"/>
<O2 defaultselect="false" description="Won’t generate a record if the result of expression xi is null." optionchar="i"/>
<O3 defaultselect="false" description="When parameter A is a pure table sequence, directly reference an old column if it is unmodified instead of generating a new column" optionchar="o"/>
</options>
<params>
<P1 desc="xi (Expression whose result is the field value. If omitted, field values will be null and :Fi must not be omitted at the same time. The sign # is used to represent a field with a sequence number.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Field name. If omitting it, then use the identifier parsed from the xi.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F477>
<F478 desc="Return the channel with newly-computed field values for its records." majortype="101" name="new" postfix="ch." returntype="101">
<options>
<O1 defaultselect="false" description="Won’t generate the corresponding record when the result of computing expression xi is null" optionchar="i"/>
</options>
<params>
<P1 desc="xi  (An expression, whose values are uses as the new field values. It is treated as null if omitted; in that case, : Fi can’t be omitted. The sign # is used to represent a field with a sequence number )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi  (Field name in the given channel; use the identifiers parsed from expression xi if it is omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F478>
<F479 desc="Return a cursor with newly-computed field values for its records." majortype="101" name="new" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Won’t generate a record if the result of expression xi is null" optionchar="i"/>
</options>
<params>
<P1 desc="xi (An expression, whose values are uses as the new field values. It is treated as null if omitted; in that case, : Fi can’t be omitted. The sign # is used to represent a field with a sequence number)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Field name of cs; use the identifiers parsed from expression xi if it is omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F479>
<F480 desc="Retrieve specified fields from a cluster composite table according to key values of a cluster table or a cluster cursor and return a cluster cursor." majortype="101" name="new" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="A/cs (A cluster table cluster cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Field values)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="C (Column alias)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="wi(Filtering condition; separate multiple conditions, which should be met at the same time, by comma(s))" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F480>
<F481 desc="Compute an expression on a specified field of a pseudo table, assign results to the field and return a new pseudo table" majortype="101" name="new" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Won’t generate the corresponding record when parameter is present but its result of computing a record is null" optionchar="i"/>
</options>
<params>
<P1 desc="xi(An expression whose values are assigned to a specific field; record the field values as null when the parameter is absent, and in this case, : Fi after it should be kept; when it is the number sign #, locate a value by the sequence number of its corresponding field)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi(Field names in the result psudo table; use the identifiers parsed from expression xi when it is absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F481>
<F482 desc="Compute field values based on a table sequence/record sequence, and concatenate them to generate a new one." majortype="101" name="news" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Left join, which creates an empty record when record sequence X is empty" optionchar="1"/>
</options>
<params>
<P1 desc="X (A record sequence/integer; equivalent to to(X) if it is an integer, meaning the frequency of inserting each record in A)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="xi (Expression, whose results will be field values; the sign ~ used in the parameter references data from record sequence X instead of A. The sign # is used to represent a field with a sequence number  )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi (Field name of the new table sequence/record sequence; when omitted, it will be automatically identified  )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F482>
<F483 desc="Get new values for the fields of records in a channel and update them into the channel." majortype="101" name="news" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="X  (Record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="xi  (Expression, whose results will be field values; the sign ~ used in the parameter references data from X instead of A. The sign # is used to represent a field with a sequence number)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi  (Field name in the given channel; will be automatically identified if the parameter is omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F483>
<F484 desc="Compute new cursor field values to update them into the original cursor." majortype="101" name="news" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Left join, which creates an empty record when record sequence X is empty" optionchar="1"/>
</options>
<params>
<P1 desc="X (Record sequence )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="xi (An expression, whose values are uses as the new field values. It is treated as null if omitted; in that case, : Fi can’t be omitted. The sign # is used to represent a field with a sequence number)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi (Filed name of the new cs; use the identifiers parsed from expression xi if it is omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F484>
<F485 desc="Get values of specified field(s) in a composite table according to key values in a table sequence or a cursor, concatenate them and return result as a table sequence or a cursor." majortype="102" name="news" postfix="T." returntype="102">
<options>
<O1 defaultselect="false" description="Copy records of the primary table and return result that aligned by A/cs and where aggregation can be performed" optionchar="r"/>
</options>
<params>
<P1 desc="A/cs(A table sequence/cursor/composite table cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="K(Field names; when there are K… parameters after A/cs, correspond them with theses specified fields)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="x(Field value)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="C(Column alias)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="wi(Filtering condition; multiple conditions are separated by comma(s) and they must be all met at the same time)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F485>
<F486 desc="Get values of specified field(s) from a cluster table according to key values of a cluster in-memory table or a cluster cursor, and concatenate them into a new table sequence or a cluster multicursor." majortype="101" name="news" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Match existing fields of A/cs with T’s dimension/key" optionchar="z"/>
</options>
<params>
<P1 desc="A/cs(A pseudo table/table sequence/cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x(Field values)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="C(Column alias)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="wi(Filtering condition separated by commas and where the relationship between them is AND)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F486>
<F487 desc="Find records in a recursive way where the foreign key values reference a specified record." majortype="101" name="nodes" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Make the function return leaf-level nodes " optionchar="d"/>
<O2 defaultselect="false" description="Make the function return all child nodes and their level relative to the root node. " optionchar="p"/>
</options>
<params>
<P1 desc="F (Field name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="r (A record)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="n (A number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F487>
<F488 desc="Normalize a matrix or a vector" majortype="102" name="norm" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Enable subtracting the mean from each row only without keeping lengths same;the mean value after normalization is 0." optionchar="0"/>
<O2 defaultselect="false" description="0-1 normalization; mean value after normalization is 0, and standard deviation is 1" optionchar="s"/>
</options>
<params>
<P1 desc="A(A matrix or a vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F488>
<F489 desc="An inverse normal cumulative distribution function." majortype="102" name="norminv" postfix="" returntype="102">
<options/>
<params>
<P1 desc="P(Probability,  within the interval (0,1))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="mu(The mean value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="sigma(The standard deviation, which is a positive number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F489>
<F490 desc="On integers, perform bitwise NOT operation to get the logical negation on each bit" majortype="102" name="not" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x  (The numeric expression for which you want to find the logical negation on each bit)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F490>
<F491 desc="Get the current system date time" majortype="102" name="now" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Return the date part only, date type" optionchar="d"/>
<O2 defaultselect="false" description="Return the time part only, time type" optionchar="t"/>
<O3 defaultselect="false" description="Acurrate to minute" optionchar="m"/>
<O4 defaultselect="false" description="Accurate to second" optionchar="s"/>
</options>
<params/>
</F491>
<F492 desc="Divide a set of natural numbers into a number of subsets of equal length k, and find out the bucket number of the subset where the ith member settles" majortype="102" name="ntile" postfix="" returntype="101">
<options/>
<params>
<P1 desc="i (Integer; the sequence number of a member.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (Integer; the length of a subset.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F492>
<F493 desc="Divide a set with length of n into a number of subsets of equal length k, and find out the bucket number of the subset where the ith member settles" majortype="102" name="ntile" postfix="" returntype="101">
<options/>
<params>
<P1 desc="i (The sequence number of a member, which is an integer and meets i&lt;=n)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="k (The length of each subset, which is an integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="n (Length of the set, which is an integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F493>
<F494 desc="Convert a string to a number." majortype="101" name="number" postfix="" returntype="101">
<options/>
<params>
<P1 desc="stringExp (A string expression, the result of which is a numeric value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="format (A format string;can be absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F494>
<F495 desc="Normalize a sequence type numeric variable during modeling" majortype="101" name="numnorm" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Modify the original data to the normalization result after execution" optionchar="c"/>
</options>
<params>
<P1 desc="Rec(A sequence of normalization process records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F495>
<F496 desc="Normalize a table sequence/record sequence numeric variable during modeling" majortype="101" name="numnorm" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Modify the original data to the normalization result after execution" optionchar="c"/>
</options>
<params>
<P1 desc="cn(A string/number, which is the name of column (or the column number starting from 1) – the to-be-pre-processed variable – in a table sequence or record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Rec(A sequence of normalization process records)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F496>
<F497 desc="Get the first non-null member that isn’t double quoted from an integer sequence." majortype="101" name="nvl" postfix="A." returntype="101">
<options/>
<params/>
</F497>
<F498 desc="Close connection to a multidimensional database." majortype="102" name="olap_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="conn (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F498>
<F499 desc="Establish connection to multidimensional database." majortype="101" name="olap_open" postfix="" returntype="101">
<options/>
<params>
<P1 desc="url (Address of the server on which a multidimensional database runs)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="catalog (The multidimensional database name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="user (User name for accessing a multidimensional database)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="pwd (Password for accessing a multidimensional database)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F499>
<F500 desc="Query data in a multidimensional database and return the result." majortype="101" name="olap_query" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Return a cursor" optionchar="c"/>
</options>
<params>
<P1 desc="conn (The connection object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="mdx (A multidimensional database query that allows one or two axes)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F500>
<F501 desc="Create a multidimensional matrix where all the elements are1." majortype="102" name="ones" postfix="" returntype="102">
<options/>
<params>
<P1 desc="ni(A positive integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F501>
<F502 desc="Open a composite table’s base table" majortype="101" name="open" postfix="f." returntype="101">
<options/>
<params/>
</F502>
<F503 desc="Generate a cluster table from a cluster file." majortype="2" name="open" postfix="" returntype="101">
<options/>
<params/>
</F503>
<F504 desc="Perform bitwise OR operation on integers" majortype="102" name="or" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (A numeric expression based on which you perform the bitwise OR operation)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F504>
<F505 desc="Perform bitwise OR operation on integers" majortype="102" name="or" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A (Sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F505>
<F506 desc="Print out data to console" majortype="102" name="output" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Print out the print data along with current time and place the current time before the print data " optionchar="t"/>
<O2 defaultselect="false" description="Won’t create a new line using carriage return after the current info is output, which means info of the next cell will be printed on same line of that of the current one" optionchar="s"/>
</options>
<params>
<P1 desc="x  (Export parameters separated with comma)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F506>
<F507 desc="Get serial numbers of the members at the specified positions.-n≤i≤n and i is not equal to 0; For 1≤i≤n, it indicates to get the serial number of the ith  member; For -n≤i≤-1, it indicates to get the serial number of the ith member from the last. " majortype="101" name="p" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Turn back the position exceeding the boundary of A, that is, to set i=if(i%n==0,n,i%n), where n is the length of A." optionchar="r"/>
<O2 defaultselect="false" description="The position exceeding the boundary of A will be ignored." optionchar="0"/>
</options>
<params>
<P1 desc="i (an integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F507>
<F508 desc="Get serial numbers of the members at the specified positions.P is the n integer sequence whose length is m, the member values of which should be larger  than -n and less than n, but not equal to 0. " majortype="101" name="p" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Turn back the position exceeding the boundary of A, that is, to set i=if(i%n==0,n,i%n), where n is the length of A." optionchar="r"/>
<O2 defaultselect="false" description="The position exceeding the boundary of A will be ignored." optionchar="0"/>
</options>
<params>
<P1 desc="P(the n integer sequence whose length is m)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F508>
<F509 desc="Pad another character string ahead of the character string until reaching the specified length." majortype="102" name="pad" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Pad another character string on the right of the character string" optionchar="r"/>
</options>
<params>
<P1 desc="s (Character string expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="c (Character string expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="l (Character string whose result is the numeric value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F509>
<F510 desc="Add members of a sequence to another one until the latter reaches certain length." majortype="101" name="pad" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Add members before the existing members of sequence A; by default the additions will be placed at its end." optionchar="l"/>
<O2 defaultselect="false" description="If the length of sequence A is the multiple of n, do not perform the adding action. If the length of A isn’t the multiple of n, add members to A until its length is the multiple of n; the number of additions – which are members of sequence x – need to be added after the existing members can be calculated with the formula – m=n-A.len()%n. " optionchar="m"/>
</options>
<params>
<P1 desc="x (A single value or a sequence; with a sequence, add its members sequentially to sequence A)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (An integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F510>
<F511 desc="Parse a string into the corresponding data type" majortype="102" name="parse" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Remove quotes of the string before starting an escape sequence including the escape character and unicode. By default the string will not be escaped." optionchar="e"/>
<O2 defaultselect="false" description="Retrieve a substring with enough length starting from the left side and parse it, while ignoring the unparsable rest. Note that the string needs to begin with the numeric value." optionchar="n"/>
<O3 defaultselect="false" description="If a string starts with the squotation marks, parse it until the next quotation marks appears and leave the rest of the string alone, and return a string." optionchar="q"/>
</options>
<params>
<P1 desc="s (String)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F511>
<F512 desc="Loop through the records of a sequence to modify the specified field of a table sequence in order. " majortype="101" name="paste" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Loop through the records of sequence Ai to insert them to Fi field of table sequence T before the kth record." optionchar="i"/>
</options>
<params>
<P1 desc="Ai (A table sequence/record sequence/sequence, whose records/members will be values of Fi field)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (The field to be modified; when it isn’t supplied, modify the ith field of T)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="k (The position the modification starts. The default is 0, in which case records or members will be appended at the end. )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F512>
<F513 desc="Perform PCA (Principal Component Analysis) on matrix A and return data for dimensionality reduction; n is the number of principal components" majortype="102" name="pca" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="" optionchar="r"/>
</options>
<params>
<P1 desc="A(A matrix )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(Number of principal components)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F513>
<F514 desc="Reduce dimensionality for another matrix having same number of columns" majortype="102" name="pca" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A matrix )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F(The PCA fiiting object returned by pca(A,n))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F514>
<F515 desc="Get the first and the last days of the week/month/quarter to which a date belongs" majortype="102" name="pdate" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Get the Sunday of the week to which the specified date belongs" optionchar="w"/>
<O2 defaultselect="false" description="Get the Saturday of the week to which the specified date belongs" optionchar="we"/>
<O3 defaultselect="false" description="Get the beginning day of the month to which the specified date belongs" optionchar="m"/>
<O4 defaultselect="false" description="Get the last day of the month to which the specified date belongs" optionchar="me"/>
<O5 defaultselect="false" description="Get the beginning day of the quarter to which the specified date belongs" optionchar="q"/>
<O6 defaultselect="false" description="Get the last day of the quarter to which the specified date belongs" optionchar="qe"/>
<O7 defaultselect="false" description="Get the first day of the year to which the specified data belongs" optionchar="y"/>
</options>
<params>
<P1 desc="dateExp    (Expression whose result is a date or date time)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F515>
<F516 desc="Calculate Pearson’s correlation coefficient between two vectors" majortype="102" name="pearson" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Enable the calculation of r2, that is, pearson(norm@0(A),norm@0(B))" optionchar="r"/>
<O2 defaultselect="false" description="Equivalent to @a(…;k) that calculates the adjusted r2 with degrees of freedom being k" optionchar="a"/>
</options>
<params>
<P1 desc="A(A vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(A vector)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F516>
<F517 desc="Judge to which enum group an object belongs." majortype="101" name="penum" postfix="E." returntype="101">
<options>
<O1 defaultselect="false" description="Return the serial numbers of all the group satisfying the group conditions, and the default is to  return the serial number of the first group " optionchar="r"/>
<O2 defaultselect="false" description="If no sequence member is found, return the length of E plus 1. This option is mutual exclusive to @r." optionchar="n"/>
</options>
<params>
<P1 desc="y (y is allowed to be omitted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F517>
<F518 desc="Generate a date/time sequence with same interval." majortype="101" name="periods" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="i is in years" optionchar="y"/>
<O2 defaultselect="false" description="i is in quarters" optionchar="q"/>
<O3 defaultselect="false" description="i is in months" optionchar="m"/>
<O4 defaultselect="false" description="i is in ten-days" optionchar="t"/>
<O5 defaultselect="false" description="i is in seconds" optionchar="s"/>
<O6 defaultselect="false" description="exclusive of end point" optionchar="x"/>
<O7 defaultselect="false" description="Not be adjusted. By default, the result will be adjusted to the original start point of the time unit and adjustment must be done in case of @t." optionchar="o"/>
</options>
<params>
<P1 desc="s (a date time variable)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="e (a date time variable)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="i  (an integer indicating the interval; its unit is day and its value is 1 by default)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F518>
<F519 desc="Return the number of permutations" majortype="102" name="permut" postfix="" returntype="101">
<options/>
<params>
<P1 desc="n   (An integer that is the number of the objects)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="k (An integer that is the number of each way of permutation)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F519>
<F520 desc="To find the serial number of a record by its primary key" majortype="101" name="pfind" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Enable the binary search which requires that A must be ordered by the key, otherwise the result will be wrong." optionchar="b"/>
<O2 defaultselect="false" description="Return the opposite number of an insertable position number when the eligible record cannot be found" optionchar="s"/>
</options>
<params>
<P1 desc="k  (Primary key; multiple field values from a composite primary key will be presented in sequence [k1,k2,…] or (k1,k2,…).)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F520>
<F521 desc="Compute the circumference ratio and its multiples" majortype="102" name="pi" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp (Multiples. If omitting this parameter, then return the circumference ratio)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F521>
<F522 desc="Perform row-to-column transposition for a sequence." majortype="101" name="pivot" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Transpose rows to columns. In this case the default fields in Ni are the fields of A that are not included in g. " optionchar="r"/>
<O2 defaultselect="false" description="@s(g:G,…;F,f(V);Ni:N'i,…),Parameter f can be an aggregate function, which is sum, count, max, min or avg. One and only one Ni can be ignored. In that case the function performs aggregate over all the other Nis." optionchar="s"/>
</options>
<params>
<P1 desc="g (Grouping fields/expressions)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="G(A field in the result set)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="F (A to-be-transposed field in the specified sequence)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="V (A field in the specified sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="Ni (Values of F field)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="Ni`(The new name of Ni field)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P6>
</params>
</F522>
<F523 desc="Compute the plotting string on the canvas G, with the chart element e to plot. Assign the chart element parameter ai with the value xi. If the corresponding coordinate axis is available for this parameter value, then this coordinate axis is Ai." majortype="101" name="plot" postfix="G." returntype="101">
<options/>
<params>
<P1 desc="e (Chart element, for example, MapAxis, NumericAxis, EnumAxis, DateAxis, BackGround, Column, Line, Dot, Polygon, Text, Legend and Sector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="ai (Parameters of chart element, for example, the name, logicData, and physicalData parameters in the chart element of MapAxis. For the parameter introduction of each chart element, please refer to parameter chapter)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="xi (parameter value)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="Ai (Coordinate axis corresponding to the parameter value)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F523>
<F524 desc="Fit matrix A and matrix T and return the coefficient; n is the number of principal components" majortype="102" name="pls" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="T(A matrix)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="n(Number of principal components)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F524>
<F525 desc="Fit together matrices using PLS technique and return the coefficient." majortype="102" name="pls" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F(PLS fitting object returned by pls(A,T,n))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F525>
<F526 desc="Get the position of the maximum member of a sequence" majortype="101" name="pmax" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a sequence composed of serial numbers of all the members that fulfill the rules. So the  result is an n integer sequence " optionchar="a"/>
<O2 defaultselect="false" description="Perform the search backwards from the last member; by default perform the search from the first member." optionchar="z"/>
</options>
<params>
<P1 desc="x   (A field name or an expression, in which &quot;~&quot; is used to reference the current record.) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F526>
<F527 desc="Get the position of the minimum member of a sequence" majortype="101" name="pmin" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a sequence composed of serial numbers of all the members that fulfill the rules. So the  result is an n integer sequence " optionchar="a"/>
<O2 defaultselect="false" description="Perform the search backwards from the last member; by default perform the search from the first member." optionchar="z"/>
</options>
<params>
<P1 desc="x (A field name or an expression, in which &quot;~&quot; is used to reference the current record.) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F527>
<F528 desc="Calculate the coefficient between two vectors in polynomial fitting. " majortype="101" name="polyfit" postfix="" returntype="101">
<options/>
<params>
<P1 desc="X(Vectors of same dimension)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Y(Vectors of same dimension)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="n(A non-zero positive integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F528>
<F529 desc="Get the position of a member in a sequence" majortype="101" name="pos" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="A is a sorted sequence by default, so dichotomizing search will be used. Increasing and decreasing are all applicable" optionchar="b"/>
<O2 defaultselect="false" description="Return a sequence composed of serial numbers of all the members that fulfill the rules. So the  result is an n integer sequence " optionchar="a"/>
<O3 defaultselect="false" description="Perform the search backwards from the last member; by default perform the search from the first member." optionchar="z"/>
<O4 defaultselect="false" description="Members of A are in order. With the binary search, return the position of x if x is a member of A; otherwise, return a number opposite to the sequence number at which position the x can be inserted orderly." optionchar="s"/>
<O5 defaultselect="false" description="If x is a sequence, then treat it as an single value. In this case, A is a sequence composed of sequences" optionchar="p"/>
<O6 defaultselect="false" description="If no sequence member is found, return the length of A plus 1. This option is mutual exclusive to @a." optionchar="n"/>
</options>
<params>
<P1 desc="x (A member.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F529>
<F530 desc="Get the positions of sequence members in another sequence." majortype="101" name="pos" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return single ascending ISeq p to make A(p)==x" optionchar="i"/>
<O2 defaultselect="false" description="Return the position in which the sequence x firstly appears in A. By doing so, seek the position of sub sequence x in the sequence A. If x is not the sub sequence of A, then return null." optionchar="c"/>
<O3 defaultselect="false" description=" A is a sorted sequence by default, so dichotomizing search will be used. Increasing and decreasing  are all applicable " optionchar="b"/>
</options>
<params>
<P1 desc="x  (a sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F530>
<F531 desc="Search the position of a substring in a parent string, and return null if not found" majortype="102" name="pos" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Perform the search leftward starting from begin, while the search will be done rightward by default." optionchar="z"/>
<O2 defaultselect="false" description="Case-insensitive" optionchar="c"/>
<O3 defaultselect="false" description="Search for the subsring at the beginning of the parent string by ignoring parameter begin" optionchar="h"/>
</options>
<params>
<P1 desc="s1 (The parent string where you want to search for the substring.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s2 (Substring of interest.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="begin (The position from which the search starts; the default search is from the beginning.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F531>
<F532 desc="Compute the powers of a numeric value" majortype="102" name="power" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (Base)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (Power; default is 2)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F532>
<F533 desc="Among the records, query fields referred by the foreign key recursively" majortype="101" name="prior" postfix="r." returntype="101">
<options/>
<params>
<P1 desc="F (Field name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="r1 (A record)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="n (A Number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F533>
<F534 desc="Call a storage procedure by a database connection" majortype="1" name="proc" postfix="db." returntype="101">
<options/>
<params>
<P1 desc="sql  (The execution statement for the storage procedure; for example, call test(?,?))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="param ( The value of an input argument,  If param:type:mode:variable appears repeatedly, then separate it with comma, like param:type:mode:variable,... )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="type (The data type of an argument)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="mode (&quot;i&quot; or &quot;o&quot;. &quot;i&quot; indicates an input argument and &quot;o&quot; indicates an output argument)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="variable (The output argument's name, which will be referenced in the current program cellset)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F534>
<F535 desc="Return the product of a set of numbers." majortype="102" name="product" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (An expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F535>
<F536 desc="Return the product of a set of numbers." majortype="102" name="product" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A (Sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F536>
<F537 desc="Retrieve property value from the property file." majortype="2" name="property" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Read a property value and parse it as what it is; by default return the value as a string." optionchar="v"/>
</options>
<params>
<P1 desc="p  (Property name; the function returns a table sequence composed of all properties if it is omitted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F537>
<F538 desc="Read property values from node strings." majortype="101" name="property" postfix="xs." returntype="101">
<options>
<O1 defaultselect="false" description="Separate node strings by commas or semicolons; use spaces by default" optionchar="c"/>
<O2 defaultselect="false" description="Use colons to separate node string name and its value; use the equal sign by default" optionchar="j"/>
<O3 defaultselect="false" description="Enclose values by double quotation marks" optionchar="q"/>
<O4 defaultselect="false" description="Read the string and then parse it into value; return a sequence by default" optionchar="v"/>
</options>
<params>
<P1 desc="xs(Node strings, whose format is“name1=value1 name2=value2...”)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(Node string name; return a table sequene made up fo all properties when it is absent)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="v(Null or a string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F538>
<F539 desc="Return the sequence number of the interval in which the parameter falls" majortype="101" name="pseg" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Use intervals that are left-open and right-closed" optionchar="r"/>
</options>
<params>
<P1 desc="x (An expression, which is a field name or a legal expression made up of field name and in which the sign ~ can be used to reference the current record; can be absent)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y (An expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F539>
<F540 desc="Get the positions of the selected members from a sequence" majortype="101" name="pselect" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Perform the binary search when A is an ordered sequence by default. Note that in this case xi must be in ascending or descending order. If A is not an ordered sequence, this option could return incorrect result. When it is used with A.pselect(x1:y1,x2:y2,......xi:yi) to find out members that make cmp(x,y) return 0, simply write A.pselect@b(x1:y1,x2:y2,......xi:yi) without including cmp()." optionchar="b"/>
<O2 defaultselect="false" description="Return a sequence composed of serial numbers of all the members that fulfill the rules. So the  result is an n integer sequence " optionchar="a"/>
<O3 defaultselect="false" description="Perform the search backwards from the last member; by default perform the search from the first member." optionchar="z"/>
<O4 defaultselect="false" description="The member in A is ordered for formula x. With the binary search, if none members in A can make the formula x generate a result of 0, then return a number opposite to the position at which the number meeting the conditions can be inserted." optionchar="s"/>
<O5 defaultselect="false" description="If no sequence member is found, return the length of A plus 1. This option is mutual exclusive to @a" optionchar="n"/>
</options>
<params>
<P1 desc="x  (A boolean expression, whose value can be null. when using @b option, x should be an expression whose return value is an integer) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F540>
<F541 desc="Get the positions of the selected members from a sequence, the simplified syntax for multiple conditions using &quot;&amp;&amp;&quot; to do the union query, it is equal to A.pselect(x1==y1 &amp;&amp; x2==y2 &amp;&amp;...... xi==yi {,k})." majortype="101" name="pselect" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Perform the binary search when A is an ordered sequence by default. Note that in this case xi must be in ascending or descending order. If A is not an ordered sequence, this option could return incorrect result. When it is used with A.pselect(x1:y1,x2:y2,......xi:yi) to find out members that make cmp(x,y) return 0, simply write A.pselect@b(x1:y1,x2:y2,......xi:yi) without including cmp()." optionchar="b"/>
<O2 defaultselect="false" description="Return a sequence composed of serial numbers of all the members that fulfill the rules. So the  result is an n integer sequence " optionchar="a"/>
<O3 defaultselect="false" description="Perform the search backwards from the last member; by default perform the search from the first member." optionchar="z"/>
<O4 defaultselect="false" description="All members of A are in descending/ascending order for formula xk. With binary search, if no members meeting the conditions are found, then return a number opposite to the sequence number of position at which the number meeting the conditions can be inserted." optionchar="s"/>
<O5 defaultselect="false" description="If no sequence member is found, return the length of A plus 1. This option is mutual exclusive to @a" optionchar="n"/>
</options>
<params>
<P1 desc="xi    (xi is an expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="yi    (yi is a comparing value)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F541>
<F542 desc="Generate a pseudo table definition object" majortype="102" name="pseudo" postfix="" returntype="101">
<options/>
<params>
<P1 desc="pd (A pseudo table definition record)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F542>
<F543 desc="Get the original positions of the sorted members of a sequence." majortype="101" name="psort" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Perform parallel algorithm to enhance performance of handling data-intensive or computation-intensive tasks." optionchar="m"/>
<O2 defaultselect="false" description="Sort a sequence in descending order and return the position of a member in the original sequence" optionchar="z"/>
<O3 defaultselect="false" description="Put records with null values at the end" optionchar="0"/>
</options>
<params>
<P1 desc="x (the sorting expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F543>
<F544 desc="Get the original positions of the sorted members of a sequence." majortype="101" name="psort" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Perform parallel algorithm to enhance performance of handling data-intensive or computation-intensive tasks." optionchar="m"/>
<O2 defaultselect="false" description="Sort a sequence in descending order and return the position of a member in the original sequence" optionchar="z"/>
<O3 defaultselect="false" description="Put records with null values at the end" optionchar="0"/>
</options>
<params>
<P1 desc="xi (If there are multiple sorting expressions, they can be written as xi:di,.., a compound expression consisting of multiple expressions)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="di (Sorting order: &gt;0 represents ascending order, which is the default, and &lt;0 descending order)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F544>
<F545 desc="Get the sequence numbers of the top n smallest members in a sequence" majortype="101" name="ptop" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a single value if n is ±1" optionchar="1"/>
</options>
<params>
<P1 desc="n (Integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Sort expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F545>
<F546 desc="Push data in a channel into another channel." majortype="101" name="push" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="chi  (Channel)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F546>
<F547 desc="Push data in a cursor into a channel." majortype="101" name="push" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="chi  (Channel)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F547>
<F548 desc="Execute a SQL statement on a data source and return a table sequence composed of the query results.  " majortype="1" name="query" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="Return only the first-found record satisfying the condition, which can be a single value if only one field is involved or a sequence if multiple fields are involved." optionchar="1"/>
<O2 defaultselect="false" description="Return a sequence if the result set has only one column." optionchar="i"/>
<O3 defaultselect="false" description="Convert the numeric data type to the double data type, instead of the decimal data type." optionchar="d"/>
<O4 defaultselect="false" description="Close the database connection automatically when the statement finishes execution. Only valid with the database connection established through the connect function." optionchar="x"/>
</options>
<params>
<P1 desc="sql (A SQL statement, like select * from table)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="args (An argument value passed into the specified SQL command sql. It can be a constant or an expression. The comma is used to separate multiple arguments.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F548>
<F549 desc="Perform sql based on A and return a table sequence composed of query results. Here, args can be an expression evaluated based on each member of A. This type of syntax can work with @idx options." majortype="1" name="query" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="Return only the first-found record satisfying the condition, which can be a single value if only one field is involved or a sequence if multiple fields are involved." optionchar="1"/>
<O2 defaultselect="false" description="Return a sequence if the result set has only one column." optionchar="i"/>
<O3 defaultselect="false" description="Convert the numeric data type to the double data type, instead of the decimal data type." optionchar="d"/>
<O4 defaultselect="false" description="Close the database connection automatically when the statement finishes execution. Only valid with the database connection established through the connect function. " optionchar="x"/>
</options>
<params>
<P1 desc="A  (A sequence. sql is executed on each member of A. Generally args is computed against each member of A and the value is passed to sql for execution.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql  (A SQL statement, like select * from table)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="args  (An argument value passed into the specified SQL command sql. It can be a constant or an expression. The comma is used to separate multiple arguments.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F549>
<F550 desc="Connect to esProc-ODBC data source db to call the specified dfx file and return a result" majortype="101" name="query" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="Return only the first-found record satisfying the condition, which is a single value if only one field is involved or a sequence if multiple fields are involved." optionchar="1"/>
<O2 defaultselect="false" description="Return a sequence if the result set has only one column." optionchar="i"/>
<O3 defaultselect="false" description="Convert the numeric data type to the double data type, instead of the decimal data type." optionchar="d"/>
<O4 defaultselect="false" description="Close the database connection automatically when the statement finishes execution. Only valid with the database connection established through the connect function. " optionchar="x"/>
</options>
<params>
<P1 desc="call dfx() (Dfx is a cellset file; can be specified using a relative path, which is relative to the search path, or an absolute path)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="args (An argument value passed into the specified SQL command sql. It can be a constant or an expression. The comma is used to separate multiple arguments. )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F550>
<F551 desc="Find a certain field of a specified row in a table sequence/memory table" majortype="101" name="r" postfix="k." returntype="101">
<options/>
<params>
<P1 desc="T(A table sequence/memory table)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F(A field of T; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F551>
<F552 desc="Close R2DBC connection." majortype="102" name="r2dbc_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="r2dbc_open(R2DBC connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F552>
<F553 desc="Execute a SQL statement through R2DBC." majortype="102" name="r2dbc_exec" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con(Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql(A SQL statement)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F553>
<F554 desc="Connect to R2DBC and return a cursor." majortype="102" name="r2dbc_open" postfix="" returntype="102">
<options/>
<params>
<P1 desc="url(The URL for accessing a database, whose format is r2dbc:dbtype://&lt;host&gt;:port/&lt;database&gt;)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F554>
<F555 desc="Query a database through R2DBC." majortype="102" name="r2dbc_query" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con(Databae connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql(The SQL statement to be queried, such as select * from table)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F555>
<F556 desc="Get the integers from 0 to n-1." majortype="102" name="rand" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Set the seed value for generating random number." optionchar="s"/>
</options>
<params>
<P1 desc="n (Integer,by default, the result is a random float number between 0 and 1.0)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F556>
<F557 desc="Get a random character string" majortype="102" name="rands" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s (Character string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="l (Integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F557>
<F558 desc="Get the beginning members of the specified segment and its next segment" majortype="101" name="range" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s (Starting data)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="e (Ending data)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="k (The kth segment whose beginning member is to be returned)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="n (The number of segments data is divided)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F558>
<F559 desc="Divide a sequence into a specified number of equal segments according to its length and returns the kth segment." majortype="101" name="range" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="k(An integer, which is the ordinal number of a specified segment)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(An integer representing the total number of segments)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F559>
<F560 desc="Compute the ranking of a specified value in a sequence" majortype="101" name="rank" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a ranking according to members sorted in descending order (in ascending order by default). Here “z” is in lowercase." optionchar="z"/>
<O2 defaultselect="false" description="Deduplicate sequence A before getting y’s ranking. " optionchar="i"/>
<O3 defaultselect="false" description="Perform average operation for each of the duplicate ranking and return the result, which could contain non-integers. Take the sequence [3,2,6,6,9] for example, a default ranking is [2,1,3,3,5]; but with @s option, the ranking becomes [2.0,1.0,(3+4)/2,(3+4)/2,5.0] after we get averages for the two duplicates." optionchar="s"/>
</options>
<params>
<P1 desc="y (A member of sequence A)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F560>
<F561 desc="Get the ranking of a certain member in the computed sequence." majortype="101" name="rank" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a ranking according to members sorted in descending order (in ascending order by default). Here “z” is in lowercase." optionchar="z"/>
<O2 defaultselect="false" description="Deduplicate sequence A.(x) before getting y’s ranking." optionchar="i"/>
<O3 defaultselect="false" description="Perform average operation for each of the duplicate ranking and return the result, which could contain non-integers. Take the sequence [3,2,6,6,9] for example, a default ranking is [2,1,3,3,5]; but with @s option, the ranking becomes [2.0,1.0,(3+4)/2,(3+4)/2,5.0] after we get averages for the two duplicates." optionchar="s"/>
</options>
<params>
<P1 desc="y (A member of sequence A or it is used to compare with values of sequence A.(x))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (An expression computed according to sequence A)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F561>
<F562 desc="An interative loop for numbering records according to the values of certain fields." majortype="102" name="rank" postfix="" returntype="101">
<options/>
<params>
<P1 desc="F (Field name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Gi (Field name)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F562>
<F563 desc="An interative loop for numbering records according to the values of certain fields." majortype="102" name="ranki" postfix="" returntype="101">
<options/>
<params>
<P1 desc="F (Field name; under same Gi field value, records with same F field value have same sequence number; add 1 to the sequence number if F field value changes)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Gi (Field name; in a loop function, number records under same Gi field value by the changes of F field value; renumber a record when Gi field value changes. )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F563>
<F564 desc="Get the rankings of members of sequence A.(x)" majortype="101" name="ranks" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a ranking according to members sorted in descending order. Here “z” is in lowercase." optionchar="z"/>
<O2 defaultselect="false" description="Deduplicate sequence A.(x) before getting the rankings." optionchar="i"/>
<O3 defaultselect="false" description="Perform average operation for each of the duplicate ranking and return the result, which could contain non-integers. Take the sequence [3,2,6,6,9] for example, a default ranking is [2,1,3,3,5]; but with @s option, the ranking becomes [2.0,1.0,(3+4)/2,(3+4)/2,5.0] after we get averages for the two duplicates." optionchar="s"/>
</options>
<params>
<P1 desc="x (An expression computed according to sequence A)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F564>
<F565 desc="Compute the ranking of each member in a sequence." majortype="101" name="ranks" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a ranking according to members sorted in descending order. Here “z” is in lowercase." optionchar="z"/>
<O2 defaultselect="false" description="Deduplicate sequence A before getting the rankings." optionchar="i"/>
<O3 defaultselect="false" description="Perform average operation for each of the duplicate ranking and return the result, which could contain non-integers. Take the sequence [3,2,6,6,9] for example, a default ranking is [2,1,3,3,5]; but with @s option, the ranking becomes [2.0,1.0,(3+4)/2,(3+4)/2,5.0] after we get averages for the two duplicates." optionchar="s"/>
</options>
<params/>
</F565>
<F566 desc="Read contents from a file object" majortype="2" name="read" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Return the contents of the file object f as a string sequence; each row is corresponding to a member." optionchar="n"/>
<O2 defaultselect="false" description="Interpret the returned string as the corresponding data type. The combined use of this option and @n is acceptable" optionchar="v"/>
<O3 defaultselect="false" description="Read the file once and return the total number of bytes in it; used for test" optionchar="0"/>
</options>
<params>
<P1 desc="b(A byte number beginning from 0)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="e(A byte number beginning from 0)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F566>
<F567 desc="Make the members of a sequence the new field values of records of a table sequence." majortype="101" name="record" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="insert new records before the specified position k" optionchar="i"/>
<O2 defaultselect="false" description="Return the newly-inserted or -modified records or record sequences" optionchar="n"/>
</options>
<params>
<P1 desc="A (a sequence whose members will be used as field values of T)" filtertype="1" identifieronly="true" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="k (an integer, which indicates the record position from which the records will be modified        If k==0 or k is omitted, then append new records to T )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F567>
<F568 desc="Modify field values of a record with members of a sequence." majortype="101" name="record" postfix="r." returntype="101">
<options/>
<params>
<P1 desc="A (A sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F568>
<F569 desc="Connect to a Redis database under the single machine model" majortype="102" name="redis" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hostAndPort   (The Redis database’s IP and port number, which is a string in the format of ip:port)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="password  (The Redis database’s authentication password. )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="connectionTimeout  (Timeout value when trying to connect to the database (in seconds))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="soTimeout  (Timeout value when trying to read data(in seconds))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F569>
<F570 desc="Close a Redis database connection" majortype="102" name="redis_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F570>
<F571 desc="Connect to Redis Cluster" majortype="102" name="redis_cluster" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hostAndPort  (The Redis database’s IP and port number, which is a string in the format of ip:port)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="password  (The Redis database’s authentication password.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="connectionTimeout  (Timeout value when trying to connect to the database (in seconds); can be omitted.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="soTimeout  (Timeout value when trying to read data(in seconds); can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="maxRedirections  (The maximum number of allowed redirections; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="poolConfig  (Connection property configuration, which is a string in the format of “key:value[,key1:value1,…]”; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F571>
<F572 desc="Get the values of all the given keys" majortype="102" name="redis_get" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Key name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F572>
<F573 desc="Get a substring of the string stored at a key" majortype="102" name="redis_getrange" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Key name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="start  (The beginning of the substring)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="end  (The end of the substring)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F573>
<F574 desc="Get all the fields in a hash" majortype="102" name="redis_hkeys" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tbl  (Hash table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F574>
<F575 desc="Get the number of fields in a hash" majortype="102" name="redis_hlen" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tbl  (Hash table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F575>
<F576 desc="Get the values of all the given hash fields" majortype="102" name="redis_hmget" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tbl  (Hash table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="field  (Field name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F576>
<F577 desc="Get the values of all hash fields" majortype="102" name="redis_hvals" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tbl  (Hash table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F577>
<F578 desc="Find all keys matching the specified pattern" majortype="102" name="redis_keys" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="pattern  (A matching string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F578>
<F579 desc="Get a member from a list by its index" majortype="102" name="redis_lindex" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (List name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="index  (Index)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F579>
<F580 desc="Get the length of a list" majortype="102" name="redis_llen" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (List name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F580>
<F581 desc="Get a range of members in a list with indexes within the given offset values start and stop." majortype="102" name="redis_lrange" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (List name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="start  (Starting index)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="stop  (Ending index)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F581>
<F582 desc="Connect to Redis database in buffer pool mode" majortype="102" name="redis_pool" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hostAndPort  (The Redis database’s IP and port number, which is a string in the format of ip:port)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="password  (The Redis database’s authentication password.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="connectionTimeout  (Timeout value when trying to connect to the database (in seconds); can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="database  (Database indexes, which within the range of 0~15; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="clientName  (Client name; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="poolConfig  (Connection property configuration, which is a string in the format of “key:value[,key1:value1,…]”; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F582>
<F583 desc="Get the the number of members in a set" majortype="102" name="redis_scard" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F583>
<F584 desc="Get members of the difference set of all the given sets" majortype="102" name="redis_sdiff" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Set name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F584>
<F585 desc="Change the selected database for the current connection; the database index is a number that starts from 0" majortype="102" name="redis_select" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="index  (Index number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F585>
<F586 desc="Connect to distributed Redis cluster" majortype="102" name="redis_sentinel" postfix="" returntype="102">
<options/>
<params>
<P1 desc="master  (Master node name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="hostAndPort  (The Redis database’s IP and port number, which is a string in the format of ip:port)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="password  (The Redis database’s authentication password.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="connectionTimeout  (Timeout value when trying to connect to the database (in seconds); can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="poolConfig  (Connection property configuration, which is a string in the format of “key:value[,key1:value1,…]”; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F586>
<F587 desc="Connect to a Redis database in shared pool mode" majortype="102" name="redis_shared" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hostAndPort  (The Redis database’s IP and port number, which is a string in the format of ip:port)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="password  (The Redis database’s authentication password)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="connectionTimeout  (Timeout value when trying to connect to the database (in seconds); can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="soTimeout  (Timeout value when trying to read data(in seconds))" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="pattern  (Key pattern by which the user-defined sharding algorithm is implemented; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F587>
<F588 desc="Connect to a Redis database in a mode of both buffer pool and shared pool" majortype="102" name="redis_sharedpool" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hostAndPort  (The Redis database’s IP and port number, which is a string in the format of ip:port)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="password  (The Redis database’s authentication password)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="connectionTimeout  (Timeout value when trying to connect to the database (in seconds); can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="soTimeout  (Timeout value when trying to read data(in seconds))" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="pattern  (Key pattern by which the user-defined sharding algorithm is implemented; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="poolConfig  (Connection property configuration, which is a string in the format of “key:value[,key1:value1,…]”; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F588>
<F589 desc="Get members of the intersection of all the given sets" majortype="102" name="redis_sinter" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Set name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F589>
<F590 desc="Determine if a given value is a member of a set" majortype="102" name="redis_sismember" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="member  (Set element)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F590>
<F591 desc="Get all members of a set" majortype="102" name="redis_smembers" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F591>
<F592 desc="Get one or multiple random members from a set" majortype="102" name="redis_srandmember" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="count  (The number of returned members; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F592>
<F593 desc="Get the length of the string value stored in the key" majortype="102" name="redis_strlen" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Key name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F593>
<F594 desc="Get the members of the union of all the given sets" majortype="102" name="redis_sunion" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Set name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F594>
<F595 desc="Get the data type of the value stored in the key" majortype="102" name="redis_type" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Key name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F595>
<F596 desc="Get the number of members in a sorted set" majortype="102" name="redis_zcard" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Sorted set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F596>
<F597 desc="Count the number of members in a sorted set with scores between a given interval" majortype="102" name="redis_zcount" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Sorted set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="min  (The starting score)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="max  (The ending score)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F597>
<F598 desc="Return a range of members in a sorted set, by index" majortype="102" name="redis_zrange" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Arrange members in a descending order" optionchar="z"/>
</options>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="start  (Starting index)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="stop  (Ending index)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="withscores  (Also return the scores; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F598>
<F599 desc="Return a range of members in sorted set, by score" majortype="102" name="redis_zrangebyscore" postfix="" returntype="102">
<options/>
<params>
<P1 desc=" con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Sorted set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="min  (The smallest score; can be –inf, meaning infinitely small)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="max  (The greatest score; can be +inf, meaning inifinitely large)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="offset  (Offset interval; can be omitted along with the parameter n)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="n  (Offset value; can be omitted along with the parameter offset)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
<P7 desc="withscores  (Also return the scores; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P7>
</params>
</F599>
<F600 desc="Determine the index of a member in a sorted set" majortype="102" name="redis_zrank" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Arrange sorted set members in descending order" optionchar="z"/>
</options>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Sorted set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="member  (Sorted set member)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F600>
<F601 desc="Get the score associated with the given member in a sorted set" majortype="102" name="redis_zscore" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Sorted set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="member  (Sorted set member)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F601>
<F602 desc="If no extracting item is specified in rs which represents regular expressions, match field Fi of the string data type with rs. Then return the new RSeq after RSeq A is filtered. Use the current record to match with rs if omitting Fi" majortype="101" name="regex" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Case is insensitive" optionchar="c"/>
<O2 defaultselect="false" description="Use Unicode to match" optionchar="u"/>
</options>
<params>
<P1 desc="rs (Regular expressions. The specified regular expressions will be separated from each other by separators and each will be surrounded with the parentheses. They will match the corresponding fields respectively. For example, &quot;(.*),(a.*)&quot; are two specified regular expressions separated by a comma. )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Resulting field names of string type)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F602>
<F603 desc="Split the string members of sequence A according to specified regular expressions in rs, the series of regular expressions, and return the results as a TSeq whose fields are Fi " majortype="101" name="regex" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Case is insensitive" optionchar="c"/>
<O2 defaultselect="false" description="Use Unicode to match" optionchar="u"/>
</options>
<params>
<P1 desc="rs (Regular expressions. The specified regular expressions will be separated from each other by separators and each will be surrounded with the parentheses. They will match the corresponding fields respectively. For example, &quot;(.*),(a.*)&quot; are two specified regular expressions separated by a comma. )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Resulting field names of string type)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="..." filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F603>
<F604 desc="Match the character string with regular expression" majortype="101" name="regex" postfix="s." returntype="101">
<options>
<O1 defaultselect="false" description="Case is insensitive" optionchar="c"/>
<O2 defaultselect="false" description="Use Unicode" optionchar="u"/>
</options>
<params>
<P1 desc="rs (Regular expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F604>
<F605 desc="Match the member of character string in the cursor with the regular expression" majortype="101" name="regex" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Case is insensitive" optionchar="c"/>
<O2 defaultselect="false" description="Use Unicode" optionchar="u"/>
</options>
<params>
<P1 desc="rs (Regular expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Result field name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F605>
<F606 desc="Register a .dfx/.splx file as a function to be called." majortype="102" name="register" postfix="" returntype="101">
<options/>
<params>
<P1 desc="f(Function name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="spl(.dfx/splx file path, which can be an absolute path or a relative path; a relative path is relative to the main directory)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F606>
<F607 desc="Calculate remainder for degree to radian conversion" majortype="102" name="remainder" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x(An integer or a real number)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y(An integer or a real number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F607>
<F608 desc="Rename the fields in a table sequence/(multi-zone) entity table" majortype="101" name="rename" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="F (Field name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F608>
<F609 desc="Rename a field of a cursor" majortype="101" name="rename" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="F(Field name/index name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F1 (New name of the field; If omitted, delete the original names and name the fields _1,2...)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F609>
<F610 desc="Change the substring of a source string" majortype="102" name="replace" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Quoted characters need not to be replaced" optionchar="q"/>
<O2 defaultselect="false" description="Enble to replace the first-found specified substring only" optionchar="1"/>
<O3 defaultselect="false" description="Case-insensitive" optionchar="c"/>
</options>
<params>
<P1 desc="src (Source string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="a (The source substring)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="b (The target substring)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F610>
<F611 desc="Read information from the configuration file. " majortype="101" name="report_config" postfix="" returntype="101">
<options/>
<params>
<P1 desc="filePath(A file path, which is either a relative path or an absolute path; for a relative path, its base directory is the esProc installation directory.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F611>
<F612 desc="Export a report as a HTML file or an MHT file. " majortype="101" name="report_exportHtml" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Export the report file into an MHT format; the default format of the exported file is HTMl." optionchar="x"/>
</options>
<params>
<P1 desc="rpt(A report object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="filePath(The exported file path, which is either a relative path or an absolute path; for a relative path, its base directory is the content of &lt;home&gt; in the configuration file.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F612>
<F613 desc="Export a report as a PDF file. " majortype="101" name="report_exportPdf" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Export a report as a paginated PDF" optionchar="p"/>
</options>
<params>
<P1 desc="rpt(A report object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="filePath(The exported file path, which is either a relative path or an absolute path; for a relative path, its base directory is the content of &lt;home&gt; in the configuration file.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F613>
<F614 desc="Export a report as an xls file or an xlsx file." majortype="101" name="report_exportXls" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Export the report as an xlsx file" optionchar="x"/>
</options>
<params>
<P1 desc="rpt(A report object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="filePath(The exported file path, which is either a relative path or an absolute path; for a relative path, its base directory is the content of &lt;home&gt; in the configuration file.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F614>
<F615 desc="Read a report file. " majortype="101" name="report_open" postfix="" returntype="101">
<options/>
<params>
<P1 desc="filePath(The report file path, which is either a relative path or an absolute path; for a relative path, its base directory is the content of &lt;home&gt; in the configuration file.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F615>
<F616 desc="Compute a report file." majortype="101" name="report_run" postfix="" returntype="101">
<options/>
<params>
<P1 desc="rpt(A report object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="paramValue(Report parameter value; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="paramName(Report parameter name; if it is omitted, write the report parameter values in its original order. It is illegal to write only some report parameter names while omitting others; the colon (;) following the parameter should always be rertained.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F616>
<F617 desc="Reset a cursor by moving it back to the beginning" majortype="102" name="reset" postfix="cs." returntype="102">
<options/>
<params/>
</F617>
<F618 desc="Reorganize a composite table and write it to another composite table file." majortype="2" name="reset" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Write the file as an uncompressed one; perform the write as usual if the parameter is omitted" optionchar="u"/>
<O2 defaultselect="false" description="Write the file as a compressed one; won’t perform compression if the option is absent" optionchar="z"/>
<O3 defaultselect="false" description="Write the file by row; perform the write as usual if the parameter is omitted" optionchar="r"/>
<O4 defaultselect="false" description="Write the file by column" optionchar="c"/>
<O5 defaultselect="false" description="A quick reset" optionchar="q"/>
</options>
<params>
<P1 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F618>
<F619 desc="Clear the members of a table sequence" majortype="101" name="reset" postfix="T." returntype="101">
<options/>
<params/>
</F619>
<F620 desc="Get result of an operation performed in a channel." majortype="101" name="result" postfix="ch." returntype="101">
<options/>
<params/>
</F620>
<F621 desc="Convert the red, green, blue, and transparency value to the corresponding color value" majortype="102" name="rgb" postfix="" returntype="101">
<options/>
<params>
<P1 desc="redIntExp      (The integer expression to indicate the red, of which the value is between 0-255)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="greenIntExp (The integer expression to indicate the green, of which the value is between 0-255 )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="blueIntExp    (The integer expression to indicate the blue, of which the value is between 0-255 )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="alphaIntExp  (The integer expression to indicate the transparency, of which the value is between 0-255 )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F621>
<F622 desc="Build models and perform predictions using the ridge regression method." majortype="102" name="ridge" postfix="" returntype="102">
<options/>
<params>
<P1 desc="X(A matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Y(A vector having the same number of rows as matrix X)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="learning_rate(Learning rate that is a decimal between 0 and 1; default value is 0.01)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="iterations(Learning rate that is a decimal between 0 and 1; default value is 0.01)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F622>
<F623 desc="Get the substring from the right of a string" majortype="102" name="right" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s     (Source string from which to get the substring )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n     (Get the length of substring)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F623>
<F624 desc="Roll back a database transaction." majortype="1" name="rollback" postfix="db." returntype="102">
<options/>
<params>
<P1 desc="spn (Savepoint name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F624>
<F625 desc="Restore a composite table file to the previous state when update error happens" majortype="101" name="rollback" postfix="f." returntype="101">
<options/>
<params/>
</F625>
<F626 desc="Truncate the data at the specified position, and round off the remaining part" majortype="102" name="round" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp (Data to be intercepted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nExp (Integer to specify the position at which to intercept ,＞0: Move the decimal point to the right for nExp places,＜0: Move the decimal point to the left for nExp places,=0: Indicate the current decimal places)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F626>
<F627 desc="Find the record where the key value(s) is/are the specified one(s)." majortype="101" name="row" postfix="k." returntype="101">
<options/>
<params>
<P1 desc="T (A record sequence/a table sequence/a sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F627>
<F628 desc="Find records from a memory table according to the specified primary key value(s)." majortype="101" name="row" postfix="k." returntype="101">
<options/>
<params>
<P1 desc="T (A memory table)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F628>
<F629 desc="Compute an expression against a record and return the modified record.  The function computes the expression x against record r and return the modified record. Usually it is used to change the field values of r, for example, when x is col1=col2+1, it will change the field value of col1." majortype="101" name="run" postfix="r." returntype="101">
<options/>
<params>
<P1 desc="xi (An expression, which is generally a field name or a legal expression composed of field names, and in which &quot;~&quot; references the current record.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F629>
<F630 desc="Compute expressions against each member of a sequence. Set the field value of Fi to xi." majortype="101" name="run" postfix="P." returntype="101">
<options/>
<params>
<P1 desc="xi    (The new value of Fi field )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi    (A field of A)" filtertype="1" identifieronly="true" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F630>
<F631 desc="Compute one or more expressions against each member in a sequence/record sequence and return a sequence composed of values of the expression." majortype="101" name="run" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Use parallel algorithm to handle data-intensive or computation-intensive tasks; no definite order for the records in the result set." optionchar="m"/>
</options>
<params>
<P1 desc="x (An expression, which is generally a field name or a legal expression that is composed of field names, and in which &quot;~&quot; is used to reference the current record. ) " filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F631>
<F632 desc="Compute an expression against each of the records in a channel and return the channel with new field values." majortype="101" name="run" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="xi  (New values of Fi field)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi  (Field name in the given channel)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F632>
<F633 desc="Compute one or more expressions against each of the records in a cursor and return the modified cursor. " majortype="101" name="run" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="xi (An expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (A field of cs)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F633>
<F634 desc="Generate a new sequence by reversing the members in a sequence" majortype="101" name="rvs" postfix="A." returntype="101">
<options/>
<params/>
</F634>
<F635 desc="Exit an SAP server connection" majortype="102" name="sap_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="client (SAP connection file handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F635>
<F636 desc="Return the list of table-valued result set as a cursor" majortype="102" name="sap_cursor" postfix="" returntype="101">
<options/>
<params>
<P1 desc="client (SAP server connection handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="functionName The to-be-called function)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="tableName (Table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F636>
<F637 desc="Get a function object according to the import parameter(s)" majortype="102" name="sap_execute" postfix="" returntype="101">
<options/>
<params>
<P1 desc="client (SAP server connection handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="functionName (The to-be-called function)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="paramName (Function parameter name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="paramValue (Function parameter value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F637>
<F638 desc="Get data records according to the import parameter(s)" majortype="102" name="sap_getparam" postfix="" returntype="101">
<options/>
<params>
<P1 desc="excutefunction (The execute function handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="paramName (Function parameter name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F638>
<F639 desc="Connect to an SAP server" majortype="102" name="sap_client" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="" optionchar="f"/>
</options>
<params>
<P1 desc="filename (Connection configuration file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F639>
<F640 desc="Connect to an SAP server" majortype="102" name="sap_client" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="" optionchar="f"/>
</options>
<params>
<P1 desc="filename (Connection configuration file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="charset (Character set of the connection configuration file)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F640>
<F641 desc="Connect to an SAP server" majortype="102" name="sap_client" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="" optionchar="f"/>
</options>
<params>
<P1 desc="FileObject (Connection configuration file object handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F641>
<F642 desc="Connect to an SAP server" majortype="102" name="sap_client" postfix="" returntype="101">
<options/>
<params>
<P1 desc="user (SAP user name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="passwd (SAP password)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="hostname" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="sysnc (SAP server’s IP)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="client (System number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="lang (Language)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F642>
<F643 desc="Return a list according to the import table-valued parameter" majortype="102" name="sap_table " postfix="" returntype="101">
<options/>
<params>
<P1 desc="excutefunction (The execute function handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tableName (Table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F643>
<F644 desc="Set the savepoint to which you can later rollback" majortype="102" name="savepoint" postfix="db." returntype="101">
<options/>
<params>
<P1 desc="spn (Savepoint name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F644>
<F645 desc="Get an integer consisting of certain bytes of a serial byte key" majortype="101" name="sbs" postfix="k." returntype="101">
<options/>
<params>
<P1 desc="a (The ath byte of serial byte k; begin from the first byte when this parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b (The bth byte of serial byte k; stop at he last byte when this parameter is absent, and get the ath byte only when :b is absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F645>
<F646 desc="The function gets multiple substrings from string s to form a new string" majortype="101" name="sbs" postfix="s." returntype="101">
<options/>
<params>
<P1 desc="a (The start position for getting the future substrings; default is 1)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b (The end position for getting the future substrings, whose defaut is s.len(); let b=a when :b is absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F646>
<F647 desc="Calculate the standard error of a numeric sequence" majortype="102" name="se" postfix="A." returntype="102">
<options/>
<params/>
</F647>
<F648 desc="Get the second from a time" majortype="102" name="second" postfix="" returntype="101">
<options/>
<params>
<P1 desc="datetimeExp    (Expression whose result is a time or date time)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F648>
<F649 desc="Return the member in a sequence corresponding to a certain interval number" majortype="101" name="segp" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Use left-open and right-closed intervals" optionchar="r"/>
</options>
<params>
<P1 desc="x(A field expression or a legal expression made up of field names, in which “~” can be used to reference the current record and which can be absent)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y(An expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F649>
<F650 desc="Pick out members from a sequence which satisfied a condition." majortype="101" name="select" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="return the first member that fulfills the conditions." optionchar="1"/>
<O2 defaultselect="false" description="search the members from back to front" optionchar="z"/>
<O3 defaultselect="false" description="A is a sorted sequence by default, so dichotomizing search will be used. Increasing and decreasing  are all applicable. Note: If A is not a sorted sequence, then option @b should not be used, or it may  bring about the incorrect result. When option @b is used in A.select(x1:y1, x2:y2, ......xi:yi), that is to find out the members whose &quot;Return value&quot; are 0 in cmp(x,y), cmp() is not needed in this  syntax, A.select@b(x1:y1, x2:y2, ......xi:yi) is enough. " optionchar="b"/>
<O4 defaultselect="false" description="Use parallel algorithm to handle data-intensive or computation-intensive tasks; no definite order for the records in the result set; it can’t be used with @1bz options." optionchar="m"/>
<O5 defaultselect="false" description="Return an empty table sequence with data structure if the grouping and aggregate operation over the sequence returns null" optionchar="t"/>
<O6 defaultselect="false" description="Enable getting the first ineligible member from left to right beginning from the first member" optionchar="c"/>
<O7 defaultselect="false" description="Enable searching for the first eligible members from left to right and getting all members after it (inclusive)" optionchar="r"/>
</options>
<params>
<P1 desc="x (an Boolean expression, which may be null. when using option @b, x should be an expression  whose return value is a number )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F650>
<F651 desc="Pick out members from a sequence which satisfied a condition. The simplified syntax used for the combining query with multiple conditions using &quot;&amp;&amp;&quot;, which is equal to A.select(x1== y1 &amp;&amp; x2== y2 &amp;&amp;...... xi==yi). While using option @b in case of multiple conditions, cmp() is not needed in this syntax and A.select@b(x1:y1, x2:y2, ......xi:yi) is enough" majortype="101" name="select" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="return the first member that fulfills the conditions. " optionchar="1"/>
<O2 defaultselect="false" description="search the members from back to front" optionchar="z"/>
<O3 defaultselect="false" description="A is a sorted sequence by default, so dichotomizing search will be used. Increasing and decreasing  are all applicable. Note: If A is not a sorted sequence, then option @b should not be used, or it may  bring about the incorrect result. When option @b is used in A.select(x1:y1, x2:y2, ......xi:yi), that  is to find out the members whose &quot;Return value&quot; are 0 in cmp(x,y), cmp() is not needed in this  syntax, A.select@b(x1:y1, x2:y2, ......xi:yi) is enough. " optionchar="b"/>
<O4 defaultselect="false" description="Use parallel algorithm to handle data-intensive or computation-intensive tasks; no definite order for the records in the result set; it can’t be used with @1bz options." optionchar="m"/>
<O5 defaultselect="false" description="Return an empty table sequence with data structure if the grouping and aggregate operation over the sequence returns null" optionchar="t"/>
</options>
<params>
<P1 desc="xi   (an expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="yi   (a comparing value)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F651>
<F652 desc="Return members of a table sequence which satisfy a condition" majortype="101" name="select" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Reuse T’s index, which may disrupt the order of the result set" optionchar="i"/>
</options>
<params>
<P1 desc="x(Filtering expression; can be null)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F652>
<F653 desc="Return a channel with records that meet the given condition." majortype="101" name="select" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="x  (Boolean expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F653>
<F654 desc="Send records in a channel that can’t meet the given condition into another channel." majortype="101" name="select" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="x  (A boolean expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="ch1  (Channel)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F654>
<F655 desc="Return a cursor with records meeting the given condition" majortype="101" name="select" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="x  (A boolean value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F655>
<F656 desc="Send records in a cursor that can’t meet the given condition into a channel." majortype="101" name="select" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="x (A boolean value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="ch1 (Channel)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F656>
<F657 desc="Write the records that unsatisfy the specified expression into a BIN file" majortype="101" name="select" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="x (Boolean expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="f (BIN file)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F657>
<F658 desc="Select records from a pseudo table according to a specified condition." majortype="101" name="select" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="x (A Boolean expression that is a filter condition, which can be null)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F658>
<F659 desc="An interative loop for numbering records in which a certain field contains same values." majortype="102" name="seq" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The option can increase the numbering efficiency, but can only be used when the specified expression returns a positive integer; support using sequence numbers Return value: " optionchar="n"/>
</options>
<params>
<P1 desc="Gi (Field name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F659>
<F660 desc="Remove outliers from a sequence type numeric variable during modeling" majortype="101" name="sert" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Outliers are removed from the original data after execution" optionchar="c"/>
</options>
<params>
<P1 desc="Rec(A sequence of removing process records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F660>
<F661 desc="Remove outliers from a table sequence/record sequence numeric variable during modeling" majortype="101" name="sert" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Outliers are removed from the original data after execution" optionchar="c"/>
</options>
<params>
<P1 desc="cn(A string/number, which is the name of column (or the column number starting from 1) – the to-be-pre-processed variable – in a table sequence or record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Rec(A sequence of removing process records)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F661>
<F662 desc="Map enumerated values as integers" majortype="101" name="setenum" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Change original data into mapping result after execution" optionchar="c"/>
</options>
<params>
<P1 desc="Rec(A sequence of mapping process records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F662>
<F663 desc="Map enumerated variable values as integers" majortype="101" name="setenum" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Change original data into mapping result after execution" optionchar="c"/>
</options>
<params>
<P1 desc="cn(A string/number, which is the name of column (or the column number starting from 1) – the to-be-pre-processed variable – in a table sequence or record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Rec(A sequence of mapping process records)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F663>
<F664 desc="Close Salesforce cloud server connected through the way of rest api." majortype="102" name="sf_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="fd(restclient object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F664>
<F665 desc="Connect to Salesforce cloud server through the way of rest api." majortype="102" name="sf_open" postfix="" returntype="102">
<options/>
<params>
<P1 desc="jsonFile(The JSON file name; by default call user.json in the directory containing SalesforcCli external library)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F665>
<F666 desc="Query data and return result." majortype="102" name="sf_query" postfix="" returntype="102">
<options/>
<params>
<P1 desc="url(The service domain path preceded by /services)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="params(The parameter corresponding to url)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F666>
<F667 desc="Close the cloud server Salesforce server connected through soap api." majortype="102" name="sf_wsdlclose" postfix="" returntype="102">
<options/>
<params>
<P1 desc="fd(restclient object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F667>
<F668 desc="Connect to Salesforce server cloud service through soap api." majortype="102" name="sf_wsdlopen" postfix="" returntype="102">
<options/>
<params>
<P1 desc="username(User name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="password(Password)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F668>
<F669 desc="Query data and return query result." majortype="102" name="sf_wsdlquery" postfix="" returntype="102">
<options/>
<params>
<P1 desc="sql(A SQL statement; does not support select * from table. Users can refer to the value returned by sf_wsdlview() to write corresponding fields)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F669>
<F670 desc="Query data in an Sobject object and return a table sequence made up of field names and field types." majortype="102" name="sf_wsdlview" postfix="" returntype="102">
<options/>
<params>
<P1 desc="sobject(The Soobject data object to be queried)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F670>
<F671 desc="Perform SG smoothing on each row of a vector or a matrix." majortype="102" name="sg" postfix="" returntype="102">
<options/>
<params>
<P1 desc="A(A vector or a matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(Degree of a polynomial that satisfies n&lt;m-1)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="m(A set of data points, which is an odd number greater than 1 and will automatically plus 1 if it isn’t an odd number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="d(The nth order derivative, which satisfies d&lt;n)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F671>
<F672 desc="Perform a shift operation." majortype="102" name="shift" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="When shifting right, shift a sign into the leftmost position and shif a zero to this position by default" optionchar="s"/>
</options>
<params>
<P1 desc="x (The expression based on which you perform the shift operation)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s (An integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F672>
<F673 desc="Get a shuffled sequence." majortype="101" name="shift" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="i (The starting position, which is a positive integer; 1 is the default value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s (The offset value, which is a positive integer; 1 is the default value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F673>
<F674 desc="Judge whether the parameter is a positive number, a negative number or 0." majortype="102" name="sign" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (Data for which you want to judge whether it is positive or negative)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F674>
<F675 desc="Compute the sine value." majortype="102" name="sin" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (Radians for which you want to compute the sine)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F675>
<F676 desc="Return the hyperbolic sine" majortype="102" name="sinh" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (The real number for which you want to find the hyperbolic sine)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F676>
<F677 desc="Get the length of a file." majortype="2" name="size" postfix="f." returntype="101">
<options/>
<params/>
</F677>
<F678 desc="Calculate the skewness of a sequence of numeric data" majortype="101" name="skew" postfix="A." returntype="101">
<options/>
<params/>
</F678>
<F679 desc="To skip records while fetching records from a database cursor" majortype="101" name="skip" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="n (An integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Grouping expression, by which cs is sorted. With x, n will be ignored.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F679>
<F680 desc="Make esProc program sleep." majortype="102" name="sleep" postfix="" returntype="102">
<options/>
<params>
<P1 desc="n (Millisecond)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F680>
<F681 desc="Perform smoothing on a sequence type variable during modeling" majortype="101" name="smooth" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Modify the original data to the smoothing result after execution" optionchar="c"/>
<O2 defaultselect="false" description="Each option specifies a target type, and options are mutual-exclusive; automatically judge the type when no option is used; the order of priorities of the options is binary, numeric, integer and enumerated" optionchar="bnie"/>
</options>
<params>
<P1 desc="T(A sequence of target variable values)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Rec(A sequence of smoothing process records)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F681>
<F682 desc="Perform smoothing on a table sequence/record sequence variable of a table sequence/ record sequence during modeling" majortype="101" name="smooth" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Modify the original data to the smoothing result after execution" optionchar="c"/>
<O2 defaultselect="false" description="Each option specifies a target type, and options are mutual-exclusive; automatically judge the type when no option is used; the order of priorities of the options is binary, numeric, integer and enumerated" optionchar="bnie"/>
</options>
<params>
<P1 desc="T(A sequence of target variable values)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cn(A string/number, which is the name of column (or the column number starting from 1) – the to-be-pre-processed variable – in a table sequence or record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Rec(A sequence of smoothing process records)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F682>
<F683 desc="Generate a new sequence by sorting the members of a sequence" majortype="101" name="sort" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Create multi-level sorting based on specified fields and according to the original order in which records first appear. " optionchar="u"/>
<O2 defaultselect="false" description="Use parallel algorithm to enhance performance to handle data-intensive and computation-intensive tasks." optionchar="m"/>
<O3 defaultselect="false" description="Sorting in descending order" optionchar="z"/>
<O4 defaultselect="false" description="The option can increase the numbering efficiency, but can only be used when the specified expression returns a positive integer; support using sequence numbers" optionchar="n"/>
<O5 defaultselect="false" description="Put a null-value member or ecords with null values at the end" optionchar="0"/>
</options>
<params>
<P1 desc="x (an expression, according to which the members of sequence A will be sorted ascendingly)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="loc (Language name)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F683>
<F684 desc="Generate a new sequence by sorting the members of a sequence" majortype="101" name="sort" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Create multi-level sorting based on specified fields and according to the original order in which records first appear. " optionchar="u"/>
<O2 defaultselect="false" description="Use parallel algorithm to enhance performance to handle data-intensive and computation-intensive tasks." optionchar="m"/>
<O3 defaultselect="false" description="Sorting in descending order" optionchar="z"/>
<O4 defaultselect="false" description="The option can increase the numbering efficiency, but can only be used when the specified expression returns a positive integer; support using sequence numbers" optionchar="n"/>
<O5 defaultselect="false" description="Put a null-value member or ecords with null values at the end" optionchar="0"/>
</options>
<params>
<P1 desc="xi (An expression, which is a member of sequence A and which will be sorted in ascending order. If there are multiple expressions, they can be written as a compound expression in the form of xi:di,.., according to which the sorting will be performed)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="di (Sorting order: &gt;0 represents ascending order, which is the default, and &lt;0 descending order)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="loc (Language name)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F684>
<F685 desc="Sort records in a channel." majortype="101" name="sortx" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="xi  (An expression, according to which the records in a given channel is sorted in acending order)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F685>
<F686 desc="Sort data of a cursor." majortype="101" name="sortx" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Put records with null values at the end; @0 and @n can’t work together." optionchar="0"/>
<O2 defaultselect="false" description="It can only be used to make the calculation faster when the value of expression x is a positive integer over which group of records can be directly numbered. @0 and @n can’t work together." optionchar="n"/>
<O3 defaultselect="false" description="Treat parameter n as the segmentation expression by which records are first segmented and then grouped and sorted" optionchar="g"/>
</options>
<params>
<P1 desc="x (An expression to sort members of cursor cs in ascending order )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(Number of buffer rows; if the number of groups reaches n, write the grouping result to a temporary file; its value will be n times of the default if it is less than 1; by default esProc will uto-compute the value  )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F686>
<F687 desc="Sort a cluster cursor." majortype="101" name="sortx" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Won’t merge result sets returned by the nodes but return a cluster cursor segmented in the same way " optionchar="c"/>
</options>
<params>
<P1 desc="x(An expression to sort members of cursor cs in ascending order )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(Number of buffer rows; if the number of groups reaches n, write the grouping result to a temporary file; its value will be n times of the default if it is less than 1; by default esProc will uto-compute the value )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F687>
<F688 desc="Close a Spark database connection." majortype="102" name="spark_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con(Spark database connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F688>
<F689 desc="Query a Spark database, and return the result as a cursor." majortype="102" name="spark_cursor" postfix="" returntype="101">
<options/>
<params>
<P1 desc="con (Database connection string.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL query statement, like select * from table.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F689>
<F690 desc="Create a Spark database connection." majortype="102" name="spark_open" postfix="" returntype="1">
<options/>
<params>
<P1 desc="hdfsUrl (HDFS file connection information; the format is hdfs://ip:port, which represents the HDFS file’s IP and port number)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="thriftUrl (Thrift file connection information; the format is thrift://ip:port, which represents the Thrift file’s IP and port number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="dbname (A database name.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F690>
<F691 desc="Query a Spark database, and return the result as a sequence." majortype="102" name="spark_query" postfix="" returntype="101">
<options/>
<params>
<P1 desc="con (Database connection string.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL query statement, like select * from table.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F691>
<F692 desc="Read a file stored in Spark database." majortype="102" name="spark_read" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Read content of a file and return result as a cursor" optionchar="c"/>
<O2 defaultselect="false" description="Read the first row of a text file as field names, which is equivalent to &quot;header&quot;:&quot;true&quot;; by default, use the automatically generated field names c0, _c1…" optionchar="t"/>
<O3 defaultselect="false" description="Close Spark database connection" optionchar="x"/>
</options>
<params>
<P1 desc="con(Local or HDFS connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sfile(File name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="k:v(Parameters that can be omitted. When sfile is a text file separated by “；”, set the pair as ”sep”:”;”; and when the text file is separated by “#”, set the pair as ”sep”:”#”)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F692>
<F693 desc="Calculate Spearman’s correlation coefficient between two vectors" majortype="102" name="spearman" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(A vector)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F693>
<F694 desc="Split a string by delimiter so as to form a new sequence" majortype="101" name="split" postfix="s." returntype="101">
<options>
<O1 defaultselect="false" description="It splits string into 2 parts by the first d found" optionchar="1"/>
<O2 defaultselect="false" description="Parse members into corresponding data types after the splitting. That is to say, numbers shall be handled as numeric values, members enclosed by [] shall be recognized as sequences, dates like 2001-01-01 shall be treated as date type data, and so on. The parsing of the sign [] also involves the same handling of a sub-sequence. In addition, parentheses matching needs to be handled." optionchar="p"/>
<O3 defaultselect="false" description="It parses members into corresponding data types without handling quotation marks matching and parentheses matching" optionchar="b"/>
<O4 defaultselect="false" description="Perform trim operation to remove blank characters from the front and end of each string member, and split the original string according to continuous blank characters when d==&quot;&quot;" optionchar="t"/>
<O5 defaultselect="false" description="Treat parameter d as a regular expression" optionchar="r"/>
<O6 defaultselect="false" description="Spit a string using the carriage return \n, and split each substring according to the other options if there are any, and return a sequence of sequences" optionchar="n"/>
</options>
<params>
<P1 desc="d  (The delimiter; if it is omitted, split the string into a sequence of single characters.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F694>
<F695 desc="Split a SQL query into a sequence." majortype="101" name="sqlparse" postfix="sql." returntype="101">
<options>
<O1 defaultselect="false" description="SELECT statement" optionchar="s"/>
<O2 defaultselect="false" description="FROM clause, including the JOIN" optionchar="f"/>
<O3 defaultselect="false" description="WHERE clause" optionchar="w"/>
<O4 defaultselect="false" description="GROUP BY statement" optionchar="g"/>
<O5 defaultselect="false" description="HAVING clause" optionchar="h"/>
<O6 defaultselect="false" description="ORDER BY statement" optionchar="o"/>
<O7 defaultselect="false" description="Split each statement/clause into smaller parts; separate WHERE and HAVING clauses according to AND" optionchar="a"/>
</options>
<params>
<P1 desc="part (A SQL string for replacing a statement/clause in the original SQL query; need to work with a certain option)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F695>
<F696 desc="Translates standard SQL functions into functions a specified database defines." majortype="101" name="sqltranslate" postfix="sql." returntype="101">
<options/>
<params>
<P1 desc="dbtype (Database type)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F696>
<F697 desc="Find the square root of a number" majortype="102" name="sqrt" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (Data for which you want to find the square root)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (The n)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F697>
<F698 desc="Close connection to the Cassandra database" majortype="102" name="stax_close" postfix="" returntype="101">
<options/>
<params>
<P1 desc="staxClient (Cassandra database connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F698>
<F699 desc="Query the Cassandra database and return result as a cursor" majortype="102" name="stax_cursor" postfix="" returntype="101">
<options/>
<params>
<P1 desc="staxClient(The database connection handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cql(A CQL query statement)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="args(A parameter value; can be absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F699>
<F700 desc="Create connection to the Cassandra database" majortype="102" name="stax_open" postfix="" returntype="101">
<options/>
<params>
<P1 desc="nodes (The to-be-connected database’s IP address)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="port (Port number; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="user:pwd (User name and password; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="keyspace (The keyspace name; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="compressor (A compression algorithm, which is LZ4, Snappy and none; default is none)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="version(Protocol version information; can be absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
<P7 desc="queryOptions(A query option, which includes ANY, ONE, TOW, THREE, ALL and QUORUM; there are details in Cssandra documentation)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P7>
</params>
</F700>
<F701 desc="Query a Cassandra database and return the query result as a table sequence" majortype="102" name="stax_query" postfix="" returntype="101">
<options/>
<params>
<P1 desc="staxClient (Database connection handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cql (The query statement)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="args (Parameter values; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F701>
<F702 desc="Create a sequence by getting members from a sequence according to the specified starting position and a step." majortype="101" name="step" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="m  (a positive integer used to specify the span)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="ki  (the starting serial number, 1≤ki.The default is 1.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F702>
<F703 desc="Convert the object of other type to the string type and format it" majortype="102" name="string" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Enclosed the string expression in double quotes and ignore parameter format" optionchar="q"/>
<O2 defaultselect="false" description="Escape the undisplayable character. Represent the tab, carriage return, line break in the string expression with the escape characters. Add an escape character before the single quotes, double quotes or an escape character if there is any in the string. Ignore parameter format" optionchar="e"/>
<O3 defaultselect="false" description="With the use of @e option, if there is large character set in the string expression, convert it to Unicode characters" optionchar="u"/>
</options>
<params>
<P1 desc="expression (The constant object or expression to be converted to string.)" filtertype="0" identifieronly="true" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="format  (A format string used to format the result of expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F703>
<F704 desc="Find a substring and return the string after the substring" majortype="101" name="substr" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Return the string before s2; return null if there is nothing before s2" optionchar="l"/>
<O2 defaultselect="false" description="Skip the quoted string" optionchar="q"/>
<O3 defaultselect="false" description="Case-insensitive" optionchar="c"/>
</options>
<params>
<P1 desc="s1 (A string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s2 (A string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F704>
<F705 desc="Compute x with each member of the sequence and compute the summary value of the members of the new sequence, Equivalent to A.(x).sum()" majortype="101" name="sum" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (Generally an expression of a single field name, or a legal expression composed of multiple field names. The data type of the computed result of the expression is numerical value.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F705>
<F706 desc="Compute the sum of members of a sequence.  Equivalent to sum(x1,…,xn)" majortype="101" name="sum" postfix="A." returntype="101">
<options/>
<params/>
</F706>
<F707 desc="Solve binary classification problems and regression problems using SVM algorithm" majortype="101" name="svm" postfix="" returntype="101">
<options/>
<params>
<P1 desc="X(A sequence representing the training set independent variable)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Y(A sequence representing the training set objective variable)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="param(A sequence of SVM model parameters)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="R(A sequence, which is result returned by syntax svm(X,Y,param))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="XPre(A sequence representing the scoring data set)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F707>
<F708 desc="Generate a new sequence by swapping the member positions of two specified intervals of a sequence" majortype="101" name="swap" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="p  (an integer sequence interval composed of positive integers, for example [1,2,3 ], to (1,3))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="q  (an integer sequence interval composed of positive integers and does not have intersection with p, for example [ 4,5,6], to(4,6))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F708>
<F709 desc="Switch the reference field between the field value and the referenced record" majortype="101" name="switch" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Remove this record if no value corresponding to F is found in the procedure." optionchar="i"/>
<O2 defaultselect="false" description="Perform the inverse operation of @i, which obtains the records that have no value corresponding to F; with the option do not populate F with nulls. " optionchar="d"/>
<O3 defaultselect="false" description="If the specified F field value of a specified record in sequence A doesn’t exist in sequence B, generate a record of the same structure as one in B with F field as the primary key" optionchar="1"/>
</options>
<params>
<P1 desc="Fi  (The key of A. When Ai:x;… is omitted, Fi stores the records of the referenced table Ai. They can be replaced by Ai’s primary key values through the function.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ai  (When Ai is available, Fi is the reference field of A, which stores corresponding primary key values. The function is used to switch them to the referenced records. The ma. )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="x  (When both parameter Ai and the primary key x are available, get the first record from Ai in which value x is equal to Fi and make it the value of Fi field. If x is #, locate the records directly through the sequence numbers.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F709>
<F710 desc="Switch the values of a reference field in a channel between the corresponding primary key values and the referenced records, or, sometimes switch between them in a reverse direction. " majortype="101" name="switch" postfix="ch." returntype="101">
<options>
<O1 defaultselect="false" description="If no value corresponding to F is found, then remove this record." optionchar="i"/>
<O2 defaultselect="false" description="Perform the inverse operation of @i, which obtains the records that have no value corresponding to F." optionchar="d"/>
<O3 defaultselect="false" description="If the F field value of a record in channel ch doesn’t exist in Ai , then generate a record of the same structure as Ai with expression x being the primay key" optionchar="1"/>
</options>
<params>
<P1 desc="Fi  (The reference field of A. When Ai:x;… is omitted, Fi stores the records of the referenced table Ai . They can be replaced by Ai’s primary key values through the function.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ai  (When Ai is available, Fi is the reference field of A, which stores corresponding primary key values. The function is used to switch them to the referenced records in Ai.The matching condition is that Fi is equal to the primary key value of Ai. )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="x  (When both Ai and x are available, get the first record from Ai in which value x is equal to Fi and make it the value of Fi field.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F710>
<F711 desc="Replace values of a certain field in a cursor with the referencing field values of the corresponding record in another table" majortype="101" name="switch" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Connect on condition that the values are equal. By default, start connecting from the left. If no value corresponding to F is found, then remove this record." optionchar="i"/>
<O2 defaultselect="false" description="Perform the inverse operation of @i, which obtains the records that have no value corresponding to F" optionchar="d"/>
<O3 defaultselect="false" description="If the F field value of a record in channel ch doesn’t exist in Ai , then generate a record of the same structure as Ai with expression x being the primay key" optionchar="1"/>
</options>
<params>
<P1 desc="Fi (A field of a cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F711>
<F712 desc="Replace values of a specified field in a cluster cursor with the referencing field values of the corresponding record in another table" majortype="102" name="switch" postfix="cs." returntype="102">
<options>
<O1 defaultselect="false" description="With a distributed cluster memory table, the operation won’t involve a cross-node reference but it assumes that the referenced records are local" optionchar="c"/>
</options>
<params>
<P1 desc="Fi (A field in the cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ai (A cluster memory table)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="x (The primary key or logical of Ai; the parameter can be omitted if Ai has the primary key)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F712>
<F713 desc="Replace values of specified fields in an in-memory table with the corresponding referencing field values" majortype="101" name="switch" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Delete a record from T if its Fi value does not have a match in Ai" optionchar="i"/>
<O2 defaultselect="false" description="Opposite to @i option, it enables to retain only the non-matching records in T; and in this case, Fi won’t be recorded as null" optionchar="d"/>
<O3 defaultselect="false" description="Generate a record of same structure as Ai if the Fi value of a record of T does not have a match in Ai; the primary key of the new record will be Fi" optionchar="1"/>
</options>
<params>
<P1 desc="Fi(A field of T)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ai(An in-memory table or a table squence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="x(The (logical) primary key of Ai; if a specific primary is set for Ai, the parameter can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F713>
<F714 desc="Synchronize a local path onto a sequence of nodes." majortype="102" name="syncfile" postfix="" returntype="101">
<options/>
<params>
<P1 desc="hs(A node sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="p(A local path)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F714>
<F715 desc="It is used to call the system command, and return the result once completed. For example, to open the bat and exe file." majortype="102" name="system" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Proceed with the execution without pause" optionchar="p"/>
</options>
<params>
<P1 desc="cmd/sh   (&lt;strong&gt;cmd&lt;/strong&gt; cmd parameter style is set to “cmd /c +command”(Windows). &lt;br&gt; or &lt;strong&gt;sh&lt;/strong&gt; sh parameter style is set to “sh -c +command” (Linux).)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F715>
<F716 desc="Compute the tangent value" majortype="102" name="tan" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (Radians for which you want to compute the tangent value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F716>
<F717 desc="Return the hyperbolic tangent" majortype="102" name="tanh" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number  (The real number for which you want to find the hyperbolic tangent)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F717>
<F718 desc="Correct skewness of a sequence of numeric target variables" majortype="101" name="tarcorskew" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Modify the original data to the corrected values after execution" optionchar="c"/>
</options>
<params>
<P1 desc="Rec(The sequence of correction and handling records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F718>
<F719 desc="Correct skewness of a table sequence/record sequence numeric variable" majortype="101" name="tarcorskew" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Modify the original data to the corrected values after execution" optionchar="c"/>
</options>
<params>
<P1 desc="tn(A string/number, which is the alias of the target variable (or the column number starting from 1) in a table sequence or record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Rec(The sequence of correction and handling records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F719>
<F720 desc="Get the time part from the datetime value" majortype="102" name="time" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Measure to minute" optionchar="m"/>
<O2 defaultselect="false" description="Measure to second" optionchar="s"/>
</options>
<params>
<P1 desc="datetimeExp (datetime data )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F720>
<F721 desc="Convert the string stringExp to time data type according to the format specified by format and return null if the conversion fails. If there is no parameter format, format of stringExp must be in consistent with the time format in the configuration information. Parameter loc is the language used in stringExp; default is the system language." majortype="102" name="time" postfix="" returntype="101">
<options/>
<params>
<P1 desc="stringExp    (A string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="format (A string specifying data format)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="loc (Language name, which is case insensitive. The most commonly used languages are Chinese (zh) and English (en); see A.sort() to know other languages supported in esProc)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F721>
<F722 desc="Convert h,m,s of integer type to time data type" majortype="102" name="time" postfix="" returntype="101">
<options/>
<params>
<P1 desc="H  (integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="m (integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="s  (integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F722>
<F723 desc="T inverse cumulative distribution function." majortype="102" name="tinv" postfix="" returntype="102">
<options/>
<params>
<P1 desc="P(Probability within the interval (0,1))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nu(Degrees of freedom corresponding to probabilities)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F723>
<F724 desc="From sequence A, generate a sequence composed of the first a members; when a&lt;0, get members from the (A.len()+1+a)th one to the (A.len())th one." majortype="101" name="to" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="a (the integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F724>
<F725 desc="From the sequence A, generate a sequence composed of the members from the ath to the bth. If omitting a, then start from the first member by default; if omitting b, get all members of A, that is A.len(), by default, and in this case the comma must not be omitted; if a&gt;b, find the members backwards; members of the newly-generated sequence are ordered in an opposite direction relative to their original order." majortype="101" name="to" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="@z(i,n)  Split a sequence into a number of segments (the number is n), and get and return the ith segment. If the number of members in the sequence can’t be evenly divided, the additional members will be returned along with the last segment" optionchar="z"/>
</options>
<params>
<P1 desc="a (The integer specifying the starting position.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b (The integer specifying the ending position.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F725>
<F726 desc="Generate a sequence composed of continuous integers between a and b." majortype="102" name="to" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Generate a sequence composed of continuous b integers starting from a. If b is less than 0, generate the sequence backward sequentially in descending order." optionchar="s"/>
</options>
<params>
<P1 desc="start (the starting integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="end (the ending integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F726>
<F727 desc="Generate a sequence composed of continuous integers from 1 to n." majortype="102" name="to" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Generate a sequence composed of continuous b integers starting from a. If b is less than 0, generate the sequence backward sequentially in descending order." optionchar="s"/>
</options>
<params>
<P1 desc="n (n&gt;0)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F727>
<F728 desc="Calculates expression x over each member of the sequence and return a sequence consisting of the first n smallest values of x" majortype="101" name="top" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a single value if n is ±1; and null if n is 0" optionchar="1"/>
<O2 defaultselect="false" description="Calculate the concatenation of all sequence-type members in sequence A and get the first n smallest members from the new sequence" optionchar="2"/>
</options>
<params>
<P1 desc="n (An integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (An expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F728>
<F729 desc="Calculates expression x over each member of the sequence and return a sequence consisting of the first n smallest members" majortype="101" name="top" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a single value if n is ±1; and null if n is 0" optionchar="1"/>
<O2 defaultselect="false" description="Calculate the concatenation of all sequence-type members in sequence A and get the first n smallest members from the new sequence" optionchar="2"/>
</options>
<params>
<P1 desc="n (An integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (An expression)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="..." filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F729>
<F730 desc="Loop members of sequence A to compute expression x, then loop the results to compute expression y, and finally return a sequene of x’s results that correspond to the top n smallest values of y." majortype="101" name="top" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a single value if n is ±1; and null if n is 0" optionchar="1"/>
<O2 defaultselect="false" description="Calculate the concatenation of all sequence-type members in sequence A and get the first n smallest members from the new sequence" optionchar="2"/>
</options>
<params>
<P1 desc="n (An integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y (An expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="x (An expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F730>
<F731 desc="Perform aggregatgion over records in a cursor" majortype="101" name="total" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="y (Aggregate function, only support sum/count/max/min/top/avg/iterate; Parameter Gi should not be present when the function works with iterate(x,a;Gi,…) function)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F731>
<F732 desc="Perform aggregatgion over records in a channel" majortype="101" name="total" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="y (Aggregate function, only support sum/count/max/min/top/avg/iterate; Parameter Gi should not be present when the function works with iterate(x,a;Gi,…) function)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F732>
<F733 desc="Transpose a matrix." majortype="101" name="transpose" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F733>
<F734 desc="Remove the space on both ends of a string" majortype="102" name="trim" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Remove the spaces on the left of the string s, and the option is letter l" optionchar="l"/>
<O2 defaultselect="false" description="Remove the spaces on the right of string s" optionchar="r"/>
<O3 defaultselect="false" description="Remove all extra whitespaces. If there is one or continuous whitespaces within the string, retain only one whitespace; remove the whitespaces between a character and a word, but retain the whitespaces within the quotation marks." optionchar="a"/>
</options>
<params>
<P1 desc="s      (Source string from which you want to remove the space)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F734>
<F735 desc="Try to continue with the execution of a code block by ignoring the error. " majortype="101" name="try" postfix="" returntype="101">
<options/>
<params/>
</F735>
<F736 desc="Calculate t-test’s p-value" majortype="101" name="ttest_p" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A sequence of numeric targets or binary targets )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(A sequence of binary variables or numeric variables )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F736>
<F737 desc="Compute the union of members in a sequence whose members are sequences" majortype="101" name="union" postfix="A." returntype="101">
<options/>
<params/>
</F737>
<F738 desc="Compute x with each member of the sequence whose members are sequences, and then perform union operation on members of the new sequence" majortype="101" name="union" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (Generally an expression of a single field name, or a legal expression composed of multiple field names)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F738>
<F739 desc="Update a database table based on a sequence/record sequence" majortype="1" name="update" postfix="db." returntype="102">
<options>
<O1 defaultselect="false" description="Compare primary keys between the database table and A1 to generate an UPDATE statement; skip the comparison and directly upadate the database table with A if A1 is absent." optionchar="u"/>
<O2 defaultselect="false" description="Compare primary keys between the database table with A1 generate INSERT statement; skip the comparison and directly insert records into the database table with A if A1 is absent." optionchar="i"/>
<O3 defaultselect="false" description="Clear the target table before the update is executed; empty the database table before executing db.update(A:A1,tbl,Fi:xi,...;P,...)." optionchar="a"/>
<O4 defaultselect="false" description="After the execution is completed, the transaction won not be committed. If this option is omitted, the transaction will be committed." optionchar="k"/>
<O5 defaultselect="false" description="The first field is an auto-increment field with no corresponding expression." optionchar="1"/>
<O6 defaultselect="false" description="Only perform delete operation and A1 must be in place. " optionchar="d"/>
</options>
<params>
<P1 desc="A  (A sequence / record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="A1 (The original sequence/record sequence, whose data is considered consistent with the database table. )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="tbl (The name of a table in the database)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="Fi  (A field in tbl)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="xi (An expression which will be computed against A and then will be used as the new value of Fi.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="P (The primary key of tbl.If omitted, these keys will be retrieved from tbl. If retrival is failed, then use A)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F739>
<F740 desc="Update a database table based on a cursor" majortype="1" name="update" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="Generate UPDATE statement" optionchar="u"/>
<O2 defaultselect="false" description="Generate INSERT statement" optionchar="i"/>
<O3 defaultselect="false" description="Clear the target table before the update is executed; empty the database table before executing db.update()" optionchar="a"/>
<O4 defaultselect="false" description="After the execution is completed, the transaction won not  be committed. If this option is omitted, the transaction will be committed." optionchar="k"/>
<O5 defaultselect="false" description="The first field is an auto-increment field with no corresponding expression." optionchar="l"/>
</options>
<params>
<P1 desc="cs (A cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tbl (The name of a database table )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi (A field in tbl)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="xi (An expression which will be computed based on A and its value will be the new value of Fi.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="P (The key of tbl. If omitted, it will be retrieved from tbl; if the retrieval fails, then use A’s)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F740>
<F741 desc="Update records in an entity table." majortype="101" name="update" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Update the records that can be inserted and ignore those whose values exist in the memory table" optionchar="i"/>
<O2 defaultselect="false" description="Update the records that can be modified and ignore those whose values don’t exist in the memory table" optionchar="u"/>
<O3 defaultselect="false" description="Return only the records that are updated and inserted" optionchar="n"/>
</options>
<params>
<P1 desc="P (A table sequence/record sequence having same structure as T)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F741>
<F742 desc="Update records in a pseudo table" majortype="101" name="update" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Only append or insert non-matching records and ignore the matching ones" optionchar="i"/>
<O2 defaultselect="false" description="Only update the matching records and ignore the non-matching ones" optionchar="u"/>
<O3 defaultselect="false" description="Return records that are updated and inserted" optionchar="n"/>
<O4 defaultselect="false" description="When parameter P is a cursor having same order as the original entity table, update the latter’s fields that P has; only valid for column-wise storage format and no records should be added" optionchar="w"/>
</options>
<params>
<P1 desc="P (A table sequence/record sequence having same structure as T)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F742>
<F743 desc="Convert all characters to upper case" majortype="102" name="upper" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The quoted strings won’t be converted" optionchar="q"/>
</options>
<params>
<P1 desc="s     (Source string to be converted to upper case)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F743>
<F744 desc="Convert a URL string into an encoded string" majortype="102" name="urlencode" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Decode, which is the inverse operation of the urlencode function" optionchar="r"/>
</options>
<params>
<P1 desc="s (A URL string to be encoded)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cs (Character set)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F744>
<F745 desc="Get the primary key value of the record pointed by a referencing field." majortype="101" name="v" postfix="v." returntype="101">
<options/>
<params>
<P1 desc="v  (a record, a sequence or a number.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F745>
<F746 desc="Calculate the generalized variance of a vector (sequence)." majortype="101" name="var" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Calculate sample variance of a vector by dividing by n-1" optionchar="s"/>
</options>
<params>
<P1 desc="V(A vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F746>
<F747 desc="Implement an operation on file data, such as download and upload." majortype="102" name="webhdfs" postfix="" returntype="102">
<options/>
<params>
<P1 desc="url(URL of the target file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="localFile(The target file; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F747>
<F748 desc="Implement file read and write." majortype="102" name="webhdfs_file" postfix="" returntype="102">
<options/>
<params>
<P1 desc="fileUrl(URL of the target file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="params(Parameter in the file URL)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F748>
<F749 desc="Select the English words out of a string" majortype="101" name="words" postfix="s." returntype="101">
<options>
<O1 defaultselect="false" description="Select the numbers out of the string s" optionchar="d"/>
<O2 defaultselect="false" description="Select both the English words and the numbers out of the string s" optionchar="a"/>
<O3 defaultselect="false" description="Extract all characters from a string; extract a string in Chinese /a sign as inidvidual characters and a string of English letters/a number as what they are" optionchar="w"/>
<O4 defaultselect="false" description="Use with @w option to identify the preceder of a number or a datetime data as a part of it" optionchar="p"/>
<O5 defaultselect="false" description="Treat English letters in a row and continuous English letters plus numbers as a whole" optionchar="i"/>
</options>
<params/>
</F749>
<F750 desc="Compute a date time of n workdays from the specified date." majortype="102" name="workday" postfix="" returntype="101">
<options/>
<params>
<P1 desc="t (date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="k (integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="h (time sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F750>
<F751 desc="Return a sequence of workdays between two dates inclusive" majortype="102" name="workdays" postfix="" returntype="101">
<options/>
<params>
<P1 desc="b (Date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="e (Date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="h (A sequence composed of data of date type)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F751>
<F752 desc="Write string or a sequence into a file object. The write-in string can be binary data." majortype="2" name="write" postfix="f." returntype="102">
<options>
<O1 defaultselect="false" description="Append contents into a file, instead of overwritting. If contents exist in the file before appending, then new a line (carriage return) and append." optionchar="a"/>
<O2 defaultselect="false" description="Write a binary file" optionchar="b"/>
<O3 defaultselect="false" description="Use Windows-style \r\n line break; by default the line break is specified by the operating system." optionchar="w"/>
</options>
<params>
<P1 desc="s  (A string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F752>
<F753 desc="Convert every member in the sequence A to a string and write to the file f; each member occupies one row" majortype="2" name="write" postfix="f." returntype="102">
<options>
<O1 defaultselect="false" description="Append contents into a file, instead of overwritting. If contents exist in the file before appending, then new a line (carriage return) and append." optionchar="a"/>
<O2 defaultselect="false" description="Write a binary file" optionchar="b"/>
<O3 defaultselect="false" description="Use Windows-style \r\n line break; by default the line break is specified by the operating system." optionchar="w"/>
</options>
<params>
<P1 desc="A (a sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F753>
<F754 desc="Send a query request to the web service server to get the returned data" majortype="102" name="ws_call" postfix="" returntype="101">
<options/>
<params>
<P1 desc="client (Web service client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="service_name (Service name; the parameter can be omitted when the WSDL URL contains only one service)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="service_port (Service port; the parameter can be omitted when the specified service has only one port )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="operation_name (Query operation name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="value: paramName (Parameter value&amp;Parameter name; multiple pairs are allowed. If the name part is omitted, names defined in WDSL message will be referenced in order)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F754>
<F755 desc="Create a web service client" majortype="102" name="ws_client" postfix="" returntype="101">
<options/>
<params>
<P1 desc="wsdl_url (The WSDL URL provided by the server)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F755>
<F756 desc="Cross-join multiple sequences together." majortype="102" name="xjoin" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Perform left join (Note: here is the number 1). Use null to participate in the cross join if there is no matching members in sequence Ai" optionchar="1"/>
</options>
<params>
<P1 desc="Ai (The sequence on which cross-join is to be performed)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Field names of the resulting TSeq)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="xi (Criterion of filtering expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F756>
<F757 desc="Perform cross join over single cursors or table sequences" majortype="102" name="xjoinx" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Perform left join (Note: here is the number 1). Use null to participate in the cross join if there is no matching members in cursors csi" optionchar="1"/>
<O2 defaultselect="false" description="If field values of the sequences to be joined are records, the joining values will be unfolded" optionchar="x"/>
</options>
<params>
<P1 desc="csi (Single cursors or table sequences to be joined)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Names of fields of the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="xj (Filtering expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F757>
<F758 desc="Enter cell values to an Excel file object or read data from it." majortype="101" name="xlscell" postfix="xo." returntype="101">
<options>
<O1 defaultselect="false" description="Insert a row after the row containing cell a and enter the specified data; by default there won’t be insertion and the existing data will be overwritten" optionchar="i"/>
<O2 defaultselect="false" description="Enable returning a sequence of sequences of cell values at read-in" optionchar="w"/>
<O3 defaultselect="false" description="Parameter :b will be absent and parameter t is blob type when using this option to read in or configure an image; support jpg an pnag only" optionchar="g"/>
<O4 defaultselect="false" description="Work with @w to return a sequence of sequences; each sub-sequence is made up of column values" optionchar="p"/>
<O5 defaultselect="false" description="Remove blanck spaces on both sides of a string; read an empty string as null" optionchar="n"/>
</options>
<params>
<P1 desc="a (Cell a)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b (Cell b; when omitted, it is the last non-empty cell)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="s (Sheet number, which should not exceed 31 characters and contain special characters []:/\?*, or sheet name; it is the first page when omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="t (The to-be-populated string; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F758>
<F759 desc="Close an Excel file object." majortype="101" name="xlsclose" postfix="xo." returntype="102">
<options/>
<params/>
</F759>
<F760 desc="Write a table sequence or a cursor to an Excel file." majortype="101" name="xlsexport" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Write the first record as the header into a file; when a namesake file with content already exists, the last non-empty row will be treated as the header row" optionchar="t"/>
<O2 defaultselect="false" description="Import a whole big file (but shouldn’t be too big) with stream style" optionchar="c"/>
<O3 defaultselect="false" description="Write data after the last row according to the current format if the Excel file exists" optionchar="a"/>
<O4 defaultselect="false" description="Use this option when parameter A is a sequence of sequences or a string delimited by /tab; it cannot work with both @t and @c, and requires the absence of parameters x:F" optionchar="w"/>
<O5 defaultselect="false" description="If the table sequence/cursor to be exported is a sequence of sequence, use this option to transpose rows to columns before writing data to a target Excel file; the option must work with @w option" optionchar="p"/>
</options>
<params>
<P1 desc="A(Table sequence/cursor to be exported)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x(Fields to be exported. If omitted, then export all fields which can be textualized in the record sequence A/cursor. The sign # is used to represent a field with a sequence number)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="F(Resulting field name; if omitted, then use the original field names)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="s(Sheet name, which should not exceed 31 characters and contain special characters []:/\?*, or sheet number; when omitted, the exported data will be appended to the first sheet)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="p(The password for opening the exported Excel file)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F760>
<F761 desc="Write a sequence into an Excel file object." majortype="101" name="xlsexport" postfix="xo." returntype="101">
<options>
<O1 defaultselect="false" description="Export headers; headers will overwrite the last row if there is data already " optionchar="t"/>
</options>
<params>
<P1 desc="A (A cursor/a table sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (To-be-entered field names; all fields will be populated when omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi (The alias of the Excel file; use the original name when omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="s (Sheet name, which should not exceed 31 characters and contain special characters []:/\?*, or sheet number)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F761>
<F762 desc="Retrieve contents as record from Excel file object, and return in the form of TSeq" majortype="2" name="xlsimport" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Export the first row in f as the field names; if not supplied, then use _1, and _2,… as the field names; with parameter b supplied, row b is treated as the header row." optionchar="t"/>
</options>
<params/>
</F762>
<F763 desc="From f, retrieve the data of entire rows from contents of b to e, and return in the form of TSeq. The &quot;e&lt;0&quot; represents the reciprocal number, and &quot;Fi&quot; represents the retrieved fields. By default, all fields will be retrieved. s is the name or sequence number of sheet." majortype="2" name="xlsimport" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Export the first row in f as the field names; if not supplied, then use _1, and _2,… as the field names; with parameter b supplied, row b is treated as the header row." optionchar="t"/>
<O2 defaultselect="false" description="Remove blank rows before and after the Excel data when reading content in; it becomes invalid when @c option is also present" optionchar="b"/>
<O3 defaultselect="false" description="Enable returning a sequence of sequences where members of sub-sequences are cell values; it cannot work with @t, @c and @b options" optionchar="w"/>
<O4 defaultselect="false" description="Enable returning a string delimited by /tab" optionchar="s"/>
<O5 defaultselect="false" description="Work with @w to return a sequence of sequences; each sub-sequence is made up of column values" optionchar="p"/>
<O6 defaultselect="false" description="Remove blanck spaces on both sides of a string; read an empty string as null" optionchar="n"/>
</options>
<params>
<P1 desc="Fi (To-be-retrieved fields; by default all fields will be retrieved.The sign # is used to represent a field with a sequence number.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s (sheet name or sequence number. If s is omitted, use the first Excel sheet.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="b (The starting row. If b is omitted, the data from the first row to the row e will be retrieved. In this case, &quot;:&quot; can be omitted.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="e (The ending row. If e is omitted, the data will be retrieved from the row b to the last row. In this case, &quot;:&quot; cannot be omitted. If e is greater than the actual number of rows, then the actual number of rows shall prevail.         If both b and e are omitted, the data will be retrieved from the first row to the last row. )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F763>
<F764 desc="Retrieve a table sequence from an Excel file object." majortype="101" name="xlsimport" postfix="xo." returntype="101">
<options>
<O1 defaultselect="false" description="The first row is the header row; when parameter b is present, the header row is row b" optionchar="t"/>
<O2 defaultselect="false" description="Return the retrieved table sequence as a cursor; here the Excel file object must be read with @r option" optionchar="c"/>
<O3 defaultselect="false" description="Remove blank rows before and after the Excel data when reading content in; it becomes invalid when @c option is also present" optionchar="b"/>
<O4 defaultselect="false" description="Enable returning a string delimited by /tab" optionchar="s"/>
<O5 defaultselect="false" description="Work with @w to return a sequence of sequences; each sub-sequence is made up of column values" optionchar="p"/>
<O6 defaultselect="false" description="Remove blanck spaces on both sides of a string; read an empty string as null" optionchar="n"/>
</options>
<params>
<P1 desc="Fi (Excel column name; retrieve all fields when omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s (Page name/page number)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="b (Row number; the first row by default)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="e (Row number; when e &lt; 0, it is the row counted backwards; retrieve data to the last row when omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F764>
<F765 desc="Read an Excel file and return an Excel file object." majortype="101" name="xlsopen" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Read data in a stream style; support only xlsx files" optionchar="r"/>
<O2 defaultselect="false" description="Write data in a stream style; doesn’t support returning the index and support only xlsx files; the option and @r option are mutually exclusive" optionchar="w"/>
</options>
<params>
<P1 desc="p (The password for opening an Excel file; can be omitted if no password is set for the to-be-opened file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F765>
<F766 desc="Save an Excel file object into an Excel file." majortype="101" name="xlswrite" postfix="f." returntype="101">
<options/>
<params>
<P1 desc="xo (An Excel object read in non-@r@w way)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="p (The password for opening an Excel file; by default there isn’t one)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F766>
<F767 desc="Parse an XML string/a table sequence and return result." majortype="102" name="xml" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The options enables parsing an XML string in the format of K F=v F=v …&gt;D&lt;/K&gt; into records made up of fields K,F,… Three situations: If K’s value is D and D is multilevel XML data, the parsing result is a record sequence; if &lt;K …./K&gt;, D is parsed into null; if &lt;K…&gt;&lt;/K&gt;, D is parsed into an empty string." optionchar="s"/>
</options>
<params>
<P1 desc="x(An XML string/a table sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s(An XML string/a table sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F767>
<F768 desc="Perform XOR operation on integers" majortype="102" name="xor" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (The numerical expresion based on which you perform the XOR operation)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F768>
<F769 desc="Perform XOR operation on integers" majortype="102" name="xor" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A (Sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F769>
<F770 desc="Generate a new sequence by uniting and rearranging distinct members in each of a sequence’s sub-sequences" majortype="101" name="xunion" postfix="A." returntype="101">
<options/>
<params/>
</F770>
<F771 desc="Calculate an expression with each member of every sub-sequence of a sequence to generate a new sequence by uniting and rearranging distinct members in each of the resulting sub-sequences" majortype="101" name="xunion" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x(An expression whose value is a sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F771>
<F772 desc="Get the year from a date" majortype="102" name="year" postfix="" returntype="101">
<options/>
<params>
<P1 desc="dateExp   (Expression whose result is a date or date time; it can be an integer, which we can regard as the value of computing days@o())" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F772>
<F773 desc="Perform model building operation" majortype="102" name="ym_build_model" postfix="" returntype="101">
<options/>
<params>
<P1 desc="md(An MD model)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="mdfile(A model file with the extension pcf)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F773>
<F774 desc="Release resource usage." majortype="102" name="ym_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="env(An env object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F774>
<F775 desc="Initialize the environment by setting an environment variable.      ym_env(1) forces a restart of Python service." majortype="102" name="ym_env" postfix="" returntype="101">
<options/>
<params/>
</F775>
<F776 desc="Execute a Python file to define a data file and the target variable for data scoring." majortype="101" name="ym_exec" postfix="" returntype="102">
<options/>
<params>
<P1 desc="pyfile(A Python module file that implements def apply(lists) interface; parameter lists is the list data type)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="data(A data file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="jsonstr(A JSON string like: {target:0,n_components:3,deflation_mode:'regression',                 mode:'A',norm_y_weights:False,                  scale:False,algorithm:'nipals',                 max_iter:500,tol:0.000001,copy:True} In which target specifies the column holding the target variable  )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F776>
<F777 desc="List the degrees of importance for model building variables" majortype="102" name="ym_importance" postfix="" returntype="101">
<options/>
<params>
<P1 desc="pd(PD model object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F777>
<F778 desc="Return model information as a JSON string." majortype="101" name="ym_json" postfix="" returntype="102">
<options/>
<params>
<P1 desc="pd(The model object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="ps(The scoring result object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F778>
<F779 desc="Generate a model object based on the model building file." majortype="101" name="ym_load_pcf" postfix="" returntype="102">
<options/>
<params>
<P1 desc="pdfile(A model building file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F779>
<F780 desc="Load data for model building" majortype="102" name="ym_model" postfix="" returntype="101">
<options/>
<params>
<P1 desc="env(An env object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="data(Data for model building)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F780>
<F781 desc="Get information about the performance of a model" majortype="102" name="ym_performance" postfix="" returntype="101">
<options/>
<params>
<P1 desc="pd(A PD model object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F781>
<F782 desc="Perform data scoring.    Return a table sequence of scoring results when the data to be scored is a single record or concurrent records;     Return scoring result object when the data to be scored contains multiple records or it is a file. " majortype="102" name="ym_predict" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The function @m(pd,data;duration) performs data scoring with a parallel processing. Parameter duration defines a time period (Unit: millisecond) during which the data is to be scored." optionchar="m"/>
</options>
<params>
<P1 desc="pd(A model object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="data(To-be-scored data)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F782>
<F783 desc="Get model description data" majortype="102" name="ym_present" postfix="" returntype="101">
<options/>
<params>
<P1 desc="pd(A PD model object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F783>
<F784 desc="Get data from the scoring result object." majortype="102" name="ym_result" postfix="" returntype="101">
<options/>
<params>
<P1 desc="ps(The scoring result object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F784>
<F785 desc="Generate a model file according to a model object." majortype="101" name="ym_save_pcf" postfix="" returntype="102">
<options/>
<params>
<P1 desc="pd(A model object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="pdfile(A model file with the extension pcf)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F785>
<F786 desc="Close Python service." majortype="102" name="ym_server_quit" postfix="" returntype="102">
<options/>
<params/>
</F786>
<F787 desc="Set model building parameter" majortype="102" name="ym_setparam" postfix="" returntype="101">
<options/>
<params>
<P1 desc="md(An MD object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key(A parameter name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="value(A parameter value)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F787>
<F788 desc="Get a series of information about a specified variable" majortype="102" name="ym_statistics" postfix="" returntype="101">
<options/>
<params>
<P1 desc="md(An MD object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="field(Variable name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F788>
<F789 desc="Set a target variable for model building" majortype="102" name="ym_target" postfix="" returntype="101">
<options/>
<params>
<P1 desc="md(An MD object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="targetName(Target variable name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F789>
<F790 desc="Create a multidimensional matrix where all the elements are zero." majortype="102" name="zeros" postfix="" returntype="102">
<options/>
<params>
<P1 desc="ni(A positive integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F790>
<F791 desc="Perform file compression operations" majortype="102" name="zip" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Decompression" optionchar="u"/>
<O2 defaultselect="false" description="Append a new compressed file to an existing compressed file" optionchar="a"/>
<O3 defaultselect="false" description="Delete a file in a compressed file" optionchar="d"/>
<O4 defaultselect="false" description="Won’t perform recursive compression over subdirectories, only compress files of the current level" optionchar="n"/>
<O5 defaultselect="false" description="List files in a compressed file" optionchar="f"/>
<O6 defaultselect="false" description="List directories in a compressed file" optionchar="p"/>
</options>
<params>
<P1 desc="zipfile(A compressed file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="encoding(Charset; default is utf-8)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="password (A password; can be absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="path(The root directory holding a to-be-compressed file; it is the directory holding zipfile when the parameter is null or absent. The comma (“,”) after the parameter should be retained even the parameter is absent)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="files(A file or a sequence of files. Wildcard characters * and ? are allowed in a file name; the former represents any string and the latter represents a single character. With wildcard characters and if the name of the directory where the to-be-compressed file(s) are located isn’t the same with that of the directory holding the future compressed file(s), then the function will also compressed the directory, which contains the absolute path. In that case, the directory list generated via @p option is empty )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F791>
<F792 desc="Add one or more files to a zip file" majortype="102" name="zip_add" postfix="" returntype="101">
<options/>
<params>
<P1 desc="zip(A zip file object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="files(Name of a to-be-compressed file or FileObject; can be a sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F792>
<F793 desc=" Close a zip file." majortype="102" name="zip_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="zip(A zip file object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F793>
<F794 desc="Set compression mode and level for a would-be zip file" majortype="102" name="zip_compress" postfix="" returntype="101">
<options/>
<params>
<P1 desc="zip(A zip file object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="mode(Compression mode 0: Won’t compress 1: Standard compression  2: AES_ENC mode compression Other values: Standard compression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="level(Compression level 1: DEFLATE_LEVEL_FASTEST 2: DEFLATE_LEVEL_FAST 3: DEFLATE_LEVEL_NORMAL 4: DEFLATE_LEVEL_MAXIMUM 5: DEFLATE_LEVEL_ULTRA Other values: DEFLATE_LEVEL_NORMAL)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F794>
<F795 desc=" Delete one or more files from a zip file" majortype="102" name="zip_del" postfix="" returntype="101">
<options/>
<params>
<P1 desc="zip(A zip file ovject)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="files(A compressed file or a FileObject; can be a sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F795>
<F796 desc="Set encryption mode for a zip file" majortype="102" name="zip_encrypt" postfix="" returntype="101">
<options/>
<params>
<P1 desc="zip(A zip file object )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="mode(0: Won’t encrypt 1: Standard encryption 2: AES encryption with key length 128 3: AES encryption with key length 192 4: AES encryption with key length 256 Other values:Won’t encrypt)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F796>
<F797 desc="Extract one or more files from a zip file" majortype="102" name="zip_extract" postfix="" returntype="101">
<options/>
<params>
<P1 desc="zip(A zip file object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="files(A compressed file or a FileObject; can be a sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F797>
<F798 desc="Convert a string, an integer, or a long integer to a date value" majortype="102" name="date" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="date@o(day), Convert integer type day to date type data; parameter day can be regarded as the value of computing days@o()" optionchar="o"/>
</options>
<params>
<P1 desc="day(Integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F798>
<F799 desc="Convert a specified sequence to a pure sequence." majortype="101" name="i" postfix="A." returntype="101">
<options/>
<params/>
</F799>
<F800 desc="Convert a specified record sequence/table sequence to a pure record sequence/pure table sequence." majortype="101" name="i" postfix="P." returntype="101">
<options/>
<params/>
</F800>
<F801 desc="Get specified field(s) from a composite table according to correspondence between its key values and the fields in a table sequence or a cursor, and return result as a table sequence or a cursor." majortype="101" name="new" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Copy records of the primary table and return result set aligned by A/cs" optionchar="r"/>
</options>
<params>
<P1 desc="A/cs(A table sequence/cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="K(Field names; when there are K… parameters after A/cs, correspond them with theses specified fields)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="x(Field values)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="C(Column alias; can be absent)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="wi(Filtering condition; separate multiple conditions, which should all be met, by comma(s))" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F801>
<F802 desc="Convert a sequence to an ordinary one." majortype="101" name="o" postfix="A." returntype="101">
<options/>
<params/>
</F802>
<F803 desc="Convert a record sequence/table sequence to an ordinary record sequence/table sequence." majortype="101" name="o" postfix="P." returntype="101">
<options/>
<params/>
</F803>
<F804 desc="Start or stop an SPL process on the current machine." majortype="102" name="splserver" postfix="" returntype="101">
<options/>
<params>
<P1 desc="port(The port number)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cfg(XML configuration file name; stop the process at the specified port when it is absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F804>
</normal>
</funcs>
